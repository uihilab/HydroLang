<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>modules/data/utils/gridded-data-utils.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="https://code.ionicframework.com/ionicons/2.0.1/css/ionicons.min.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="AORCDataSource.html">AORCDataSource</a><ul class='methods'><li data-type='method'><a href="AORCDataSource.html#calculateIndices">calculateIndices</a></li><li data-type='method'><a href="AORCDataSource.html#extractGridData">extractGridData</a></li><li data-type='method'><a href="AORCDataSource.html#extractPointData">extractPointData</a></li><li data-type='method'><a href="AORCDataSource.html#fetchAndDecompressChunk">fetchAndDecompressChunk</a></li><li data-type='method'><a href="AORCDataSource.html#fetchMetadata">fetchMetadata</a></li><li data-type='method'><a href="AORCDataSource.html#getDatasetInfo">getDatasetInfo</a></li><li data-type='method'><a href="AORCDataSource.html#loadDatasource">loadDatasource</a></li></ul></li><li><a href="data.html">data</a><ul class='methods'><li data-type='method'><a href="data.html#.download">download</a></li><li data-type='method'><a href="data.html#.generateDateString">generateDateString</a></li><li data-type='method'><a href="data.html#.lowercasing">lowercasing</a></li><li data-type='method'><a href="data.html#.recursiveSearch">recursiveSearch</a></li><li data-type='method'><a href="data.html#.retrieve">retrieve</a></li><li data-type='method'><a href="data.html#.transform">transform</a></li><li data-type='method'><a href="data.html#.transformAORCData">transformAORCData</a></li><li data-type='method'><a href="data.html#.upload">upload</a></li><li data-type='method'><a href="data.html#.xml2json">xml2json</a></li></ul></li><li><a href="DEPDataSource.html">DEPDataSource</a><ul class='methods'><li data-type='method'><a href="DEPDataSource.html#calculateSize">calculateSize</a></li><li data-type='method'><a href="DEPDataSource.html#fetchDEMData">fetchDEMData</a></li><li data-type='method'><a href="DEPDataSource.html#fetchPointElevation">fetchPointElevation</a></li><li data-type='method'><a href="DEPDataSource.html#generateGeoTiffUrl">generateGeoTiffUrl</a></li><li data-type='method'><a href="DEPDataSource.html#getDatasetInfo">getDatasetInfo</a></li></ul></li><li><a href="divisors.html">divisors</a><ul class='methods'><li data-type='method'><a href="divisors.html#.createDiv">createDiv</a></li><li data-type='method'><a href="divisors.html#.createScript">createScript</a></li><li data-type='method'><a href="divisors.html#.isdivAdded">isdivAdded</a></li><li data-type='method'><a href="divisors.html#.isScriptAdded">isScriptAdded</a></li></ul></li><li><a href="ECMWFDataSource.html">ECMWFDataSource</a><ul class='methods'><li data-type='method'><a href="ECMWFDataSource.html#extractGridData">extractGridData</a></li><li data-type='method'><a href="ECMWFDataSource.html#extractPointData">extractPointData</a></li><li data-type='method'><a href="ECMWFDataSource.html#extractRawGRIB2">extractRawGRIB2</a></li><li data-type='method'><a href="ECMWFDataSource.html#fetch">fetch</a></li><li data-type='method'><a href="ECMWFDataSource.html#processGRIB2File">processGRIB2File</a></li></ul></li><li><a href="floodDM.html">floodDM</a><ul class='methods'><li data-type='method'><a href="floodDM.html#.buildPropertyDMScenario">buildPropertyDMScenario</a></li><li data-type='method'><a href="floodDM.html#.createTableFromObject">createTableFromObject</a></li><li data-type='method'><a href="floodDM.html#.getBridgeDamage">getBridgeDamage</a></li><li data-type='method'><a href="floodDM.html#.getCityFloodDamage">getCityFloodDamage</a></li><li data-type='method'><a href="floodDM.html#.getFloodInundation">getFloodInundation</a></li><li data-type='method'><a href="floodDM.html#.getLifeLoss">getLifeLoss</a></li><li data-type='method'><a href="floodDM.html#.getPropertyLoss">getPropertyLoss</a></li><li data-type='method'><a href="floodDM.html#.getUtilityDamage">getUtilityDamage</a></li><li data-type='method'><a href="floodDM.html#.getVehicleDamage">getVehicleDamage</a></li><li data-type='method'><a href="floodDM.html#initDamageScenario">initDamageScenario</a></li><li data-type='method'><a href="floodDM.html#initMitigationScenario">initMitigationScenario</a></li><li data-type='method'><a href="floodDM.html#runMitigationScenario">runMitigationScenario</a></li></ul></li><li><a href="geoprocessor.html">geoprocessor</a><ul class='methods'><li data-type='method'><a href="geoprocessor.html#.flowAccumulation">flowAccumulation</a></li><li data-type='method'><a href="geoprocessor.html#.flowDirection">flowDirection</a></li><li data-type='method'><a href="geoprocessor.html#.roughness">roughness</a></li><li data-type='method'><a href="geoprocessor.html#.tpi">tpi</a></li><li data-type='method'><a href="geoprocessor.html#.tri">tri</a></li><li data-type='method'><a href="geoprocessor.html#.watershed">watershed</a></li></ul></li><li><a href="GeoTIFFDataSource.html">GeoTIFFDataSource</a><ul class='methods'><li data-type='method'><a href="GeoTIFFDataSource.html#extractFromZip">extractFromZip</a></li><li data-type='method'><a href="GeoTIFFDataSource.html#getGeoTIFFGrid">getGeoTIFFGrid</a></li><li data-type='method'><a href="GeoTIFFDataSource.html#getGeoTIFFValueAtPoint">getGeoTIFFValueAtPoint</a></li><li data-type='method'><a href="GeoTIFFDataSource.html#parseGeoTIFF">parseGeoTIFF</a></li></ul></li><li><a href="GRIB2DataSource.html">GRIB2DataSource</a><ul class='methods'><li data-type='method'><a href="GRIB2DataSource.html#findGRIB2Message">findGRIB2Message</a></li><li data-type='method'><a href="GRIB2DataSource.html#getGRIB2Grid">getGRIB2Grid</a></li><li data-type='method'><a href="GRIB2DataSource.html#getGRIB2ValueAtPoint">getGRIB2ValueAtPoint</a></li><li data-type='method'><a href="GRIB2DataSource.html#parseGRIB2">parseGRIB2</a></li></ul></li><li><a href="GRIB2Integration.html">GRIB2Integration</a><ul class='methods'><li data-type='method'><a href="GRIB2Integration.html#applySpatialSubsetting">applySpatialSubsetting</a></li><li data-type='method'><a href="GRIB2Integration.html#extractGRIB2Data">extractGRIB2Data</a></li><li data-type='method'><a href="GRIB2Integration.html#parseGRIB2Buffer">parseGRIB2Buffer</a></li></ul></li><li><a href="GriddedDataSource.html">GriddedDataSource</a><ul class='methods'><li data-type='method'><a href="GriddedDataSource.html#aggregateSpatially">aggregateSpatially</a></li><li data-type='method'><a href="GriddedDataSource.html#aggregateTemporally">aggregateTemporally</a></li><li data-type='method'><a href="GriddedDataSource.html#applyScaling">applyScaling</a></li><li data-type='method'><a href="GriddedDataSource.html#buildURL">buildURL</a></li><li data-type='method'><a href="GriddedDataSource.html#decompress">decompress</a></li><li data-type='method'><a href="GriddedDataSource.html#extractGridTimeSeries">extractGridTimeSeries</a></li><li data-type='method'><a href="GriddedDataSource.html#extractMultiplePoints">extractMultiplePoints</a></li><li data-type='method'><a href="GriddedDataSource.html#extractPointData">extractPointData</a></li><li data-type='method'><a href="GriddedDataSource.html#extractTimeSeries">extractTimeSeries</a></li><li data-type='method'><a href="GriddedDataSource.html#fetch">fetch</a></li><li data-type='method'><a href="GriddedDataSource.html#fetchJSON">fetchJSON</a></li><li data-type='method'><a href="GriddedDataSource.html#findNearestIndex">findNearestIndex</a></li><li data-type='method'><a href="GriddedDataSource.html#formatTimestamp">formatTimestamp</a></li><li data-type='method'><a href="GriddedDataSource.html#handleError">handleError</a></li><li data-type='method'><a href="GriddedDataSource.html#loadLibrary">loadLibrary</a></li><li data-type='method'><a href="GriddedDataSource.html#toCSV">toCSV</a></li><li data-type='method'><a href="GriddedDataSource.html#toNetCDF">toNetCDF</a></li><li data-type='method'><a href="GriddedDataSource.html#validateCoordinates">validateCoordinates</a></li></ul></li><li><a href="HLclearCreek.html">HLclearCreek</a><ul class='methods'><li data-type='method'><a href="HLclearCreek.html#.additionalData">additionalData</a></li><li data-type='method'><a href="HLclearCreek.html#.dataStep">dataStep</a></li><li data-type='method'><a href="HLclearCreek.html#.get_time_step">get_time_step</a></li><li data-type='method'><a href="HLclearCreek.html#.get_value_at_indices">get_value_at_indices</a></li><li data-type='method'><a href="HLclearCreek.html#.retrieveData">retrieveData</a></li><li data-type='method'><a href="HLclearCreek.html#.retrieveGauge">retrieveGauge</a></li><li data-type='method'><a href="HLclearCreek.html#.spreadGauge">spreadGauge</a></li><li data-type='method'><a href="HLclearCreek.html#.spreadResults">spreadResults</a></li><li data-type='method'><a href="HLclearCreek.html#.update">update</a></li><li data-type='method'><a href="HLclearCreek.html#.update_until">update_until</a></li><li data-type='method'><a href="HLclearCreek.html#rainID">rainID</a></li></ul></li><li><a href="HRRRDataSource.html">HRRRDataSource</a><ul class='methods'><li data-type='method'><a href="HRRRDataSource.html#extractGridData">extractGridData</a></li><li data-type='method'><a href="HRRRDataSource.html#extractPointData">extractPointData</a></li><li data-type='method'><a href="HRRRDataSource.html#fetch">fetch</a></li><li data-type='method'><a href="HRRRDataSource.html#findProductForVariable">findProductForVariable</a></li><li data-type='method'><a href="HRRRDataSource.html#generateURL">generateURL</a></li><li data-type='method'><a href="HRRRDataSource.html#getDatasetInfo">getDatasetInfo</a></li><li data-type='method'><a href="HRRRDataSource.html#processFile">processFile</a></li></ul></li><li><a href="hydro.html">hydro</a><ul class='methods'><li data-type='method'><a href="hydro.html#.analyzeCollectionofEvents">analyzeCollectionofEvents</a></li><li data-type='method'><a href="hydro.html#.analyzeEvent">analyzeEvent</a></li><li data-type='method'><a href="hydro.html#.arithmetic">arithmetic</a></li><li data-type='method'><a href="hydro.html#.bucketmodel">bucketmodel</a></li><li data-type='method'><a href="hydro.html#.calculate_tds">calculate_tds</a></li><li data-type='method'><a href="hydro.html#.calculate_tss">calculate_tss</a></li><li data-type='method'><a href="hydro.html#.calculateDOSaturation">calculateDOSaturation</a></li><li data-type='method'><a href="hydro.html#.calculatepH">calculatepH</a></li><li data-type='method'><a href="hydro.html#.calculatePrecipitationMinMax">calculatePrecipitationMinMax</a></li><li data-type='method'><a href="hydro.html#.calibratePH">calibratePH</a></li><li data-type='method'><a href="hydro.html#.compensateORP">compensateORP</a></li><li data-type='method'><a href="hydro.html#.convertTemperature">convertTemperature</a></li><li data-type='method'><a href="hydro.html#.convertTurbidity">convertTurbidity</a></li><li data-type='method'><a href="hydro.html#.darcysLaw">darcysLaw</a></li><li data-type='method'><a href="hydro.html#.detectPrecipEvents">detectPrecipEvents</a></li><li data-type='method'><a href="hydro.html#.dimunithydro">dimunithydro</a></li><li data-type='method'><a href="hydro.html#.dissolvedOxygenDemand">dissolvedOxygenDemand</a></li><li data-type='method'><a href="hydro.html#.dynamicGround1D">dynamicGround1D</a></li><li data-type='method'><a href="hydro.html#.equationsystemsolver">equationsystemsolver</a></li><li data-type='method'><a href="hydro.html#.ETBlaneyCriddle">ETBlaneyCriddle</a></li><li data-type='method'><a href="hydro.html#.ETHargreaves">ETHargreaves</a></li><li data-type='method'><a href="hydro.html#.ETPenmanMontheith">ETPenmanMontheith</a></li><li data-type='method'><a href="hydro.html#.ETPriestelyTaylor">ETPriestelyTaylor</a></li><li data-type='method'><a href="hydro.html#.ETThornthwaite">ETThornthwaite</a></li><li data-type='method'><a href="hydro.html#.floodhydro">floodhydro</a></li><li data-type='method'><a href="hydro.html#.floodhydro">floodhydro</a></li><li data-type='method'><a href="hydro.html#.generateSyntheticValue">generateSyntheticValue</a></li><li data-type='method'><a href="hydro.html#.getJulianDay">getJulianDay</a></li><li data-type='method'><a href="hydro.html#.hyetogen">hyetogen</a></li><li data-type='method'><a href="hydro.html#.InfGreenAmpt">InfGreenAmpt</a></li><li data-type='method'><a href="hydro.html#.InfHorton">InfHorton</a></li><li data-type='method'><a href="hydro.html#.InfKostiakov">InfKostiakov</a></li><li data-type='method'><a href="hydro.html#.InfPhilip">InfPhilip</a></li><li data-type='method'><a href="hydro.html#.InfSmithParlange">InfSmithParlange</a></li><li data-type='method'><a href="hydro.html#.inverseDistanceWeighting">inverseDistanceWeighting</a></li><li data-type='method'><a href="hydro.html#.kinematicWaveRouting">kinematicWaveRouting</a></li><li data-type='method'><a href="hydro.html#.lagAndRoute">lagAndRoute</a></li><li data-type='method'><a href="hydro.html#.matrix">matrix</a></li><li data-type='method'><a href="hydro.html#.move">move</a></li><li data-type='method'><a href="hydro.html#.muskingumCunge">muskingumCunge</a></li><li data-type='method'><a href="hydro.html#.precipitationFrequencyAnalysis">precipitationFrequencyAnalysis</a></li><li data-type='method'><a href="hydro.html#.rainaggr">rainaggr</a></li><li data-type='method'><a href="hydro.html#.rainfallErosivityIndex">rainfallErosivityIndex</a></li><li data-type='method'><a href="hydro.html#.rainfallIntensityDurationFrequency">rainfallIntensityDurationFrequency</a></li><li data-type='method'><a href="hydro.html#.rainfallInterceptionModel">rainfallInterceptionModel</a></li><li data-type='method'><a href="hydro.html#.rainfallThresholdAnalysis">rainfallThresholdAnalysis</a></li><li data-type='method'><a href="hydro.html#.stageDischarge">stageDischarge</a></li><li data-type='method'><a href="hydro.html#.staticGround1d">staticGround1d</a></li><li data-type='method'><a href="hydro.html#.stochasticRainfallGeneration">stochasticRainfallGeneration</a></li><li data-type='method'><a href="hydro.html#.syntheticalc">syntheticalc</a></li><li data-type='method'><a href="hydro.html#.thiessen">thiessen</a></li><li data-type='method'><a href="hydro.html#.timeAreaMethod">timeAreaMethod</a></li><li data-type='method'><a href="hydro.html#.totalprec">totalprec</a></li><li data-type='method'><a href="hydro.html#.unithydrocons">unithydrocons</a></li></ul></li><li><a href="HydroBMI.BMI.html">BMI</a></li><li><a href="HydroLangBMI.html">HydroLangBMI</a><ul class='methods'><li data-type='method'><a href="HydroLangBMI.html#.dataTypes">dataTypes</a></li><li data-type='method'><a href="HydroLangBMI.html#.finalize">finalize</a></li><li data-type='method'><a href="HydroLangBMI.html#.generateOutputs">generateOutputs</a></li><li data-type='method'><a href="HydroLangBMI.html#.get_component_name">get_component_name</a></li><li data-type='method'><a href="HydroLangBMI.html#.get_current_time">get_current_time</a></li><li data-type='method'><a href="HydroLangBMI.html#.get_end_time">get_end_time</a></li><li data-type='method'><a href="HydroLangBMI.html#.get_grid_edge_count">get_grid_edge_count</a></li><li data-type='method'><a href="HydroLangBMI.html#.get_grid_edge_nodes">get_grid_edge_nodes</a></li><li data-type='method'><a href="HydroLangBMI.html#.get_grid_face_count">get_grid_face_count</a></li><li data-type='method'><a href="HydroLangBMI.html#.get_grid_face_nodes">get_grid_face_nodes</a></li><li data-type='method'><a href="HydroLangBMI.html#.get_grid_face_nodes">get_grid_face_nodes</a></li><li data-type='method'><a href="HydroLangBMI.html#.get_grid_node_count">get_grid_node_count</a></li><li data-type='method'><a href="HydroLangBMI.html#.get_grid_nodes_per_face">get_grid_nodes_per_face</a></li><li data-type='method'><a href="HydroLangBMI.html#.get_grid_origin">get_grid_origin</a></li><li data-type='method'><a href="HydroLangBMI.html#.get_grid_shape">get_grid_shape</a></li><li data-type='method'><a href="HydroLangBMI.html#.get_grid_size">get_grid_size</a></li><li data-type='method'><a href="HydroLangBMI.html#.get_grid_size">get_grid_size</a></li><li data-type='method'><a href="HydroLangBMI.html#.get_grid_spacing">get_grid_spacing</a></li><li data-type='method'><a href="HydroLangBMI.html#.get_grid_type">get_grid_type</a></li><li data-type='method'><a href="HydroLangBMI.html#.get_grid_x">get_grid_x</a></li><li data-type='method'><a href="HydroLangBMI.html#.get_grid_y">get_grid_y</a></li><li data-type='method'><a href="HydroLangBMI.html#.get_grid_z">get_grid_z</a></li><li data-type='method'><a href="HydroLangBMI.html#.get_input_item_count">get_input_item_count</a></li><li data-type='method'><a href="HydroLangBMI.html#.get_time_step">get_time_step</a></li><li data-type='method'><a href="HydroLangBMI.html#.get_time_units">get_time_units</a></li><li data-type='method'><a href="HydroLangBMI.html#.get_value_at_indices">get_value_at_indices</a></li><li data-type='method'><a href="HydroLangBMI.html#.get_value_ptr">get_value_ptr</a></li><li data-type='method'><a href="HydroLangBMI.html#.get_var_type">get_var_type</a></li><li data-type='method'><a href="HydroLangBMI.html#.handleConfig">handleConfig</a></li><li data-type='method'><a href="HydroLangBMI.html#.initialize">initialize</a></li><li data-type='method'><a href="HydroLangBMI.html#.set_value">set_value</a></li><li data-type='method'><a href="HydroLangBMI.html#.set_value_at_indices">set_value_at_indices</a></li><li data-type='method'><a href="HydroLangBMI.html#.update">update</a></li><li data-type='method'><a href="HydroLangBMI.html#.update_until">update_until</a></li><li data-type='method'><a href="HydroLangBMI.html#.visualizer">visualizer</a></li></ul></li><li><a href="HydroLangCache.html">HydroLangCache</a></li><li><a href="HydroLangGRIB2Parser.html">HydroLangGRIB2Parser</a><ul class='methods'><li data-type='method'><a href="HydroLangGRIB2Parser.html#applyScanningMode">applyScanningMode</a></li><li data-type='method'><a href="HydroLangGRIB2Parser.html#calculateGridBounds">calculateGridBounds</a></li><li data-type='method'><a href="HydroLangGRIB2Parser.html#convertTo2DGrid">convertTo2DGrid</a></li><li data-type='method'><a href="HydroLangGRIB2Parser.html#createGridMetadataResponse">createGridMetadataResponse</a></li><li data-type='method'><a href="HydroLangGRIB2Parser.html#extractGRIBMetadataOnly">extractGRIBMetadataOnly</a></li><li data-type='method'><a href="HydroLangGRIB2Parser.html#extractParsedData">extractParsedData</a></li><li data-type='method'><a href="HydroLangGRIB2Parser.html#extractParsedData">extractParsedData</a></li><li data-type='method'><a href="HydroLangGRIB2Parser.html#generateBasicCoordinates">generateBasicCoordinates</a></li><li data-type='method'><a href="HydroLangGRIB2Parser.html#generateCoordinates">generateCoordinates</a></li><li data-type='method'><a href="HydroLangGRIB2Parser.html#generateCoordinatesFromParsedData">generateCoordinatesFromParsedData</a></li><li data-type='method'><a href="HydroLangGRIB2Parser.html#getFullGridBounds">getFullGridBounds</a></li><li data-type='method'><a href="HydroLangGRIB2Parser.html#getFullGridBounds">getFullGridBounds</a></li><li data-type='method'><a href="HydroLangGRIB2Parser.html#getParameterDescriptionFromData">getParameterDescriptionFromData</a></li><li data-type='method'><a href="HydroLangGRIB2Parser.html#getParameterDescriptionFromData">getParameterDescriptionFromData</a></li><li data-type='method'><a href="HydroLangGRIB2Parser.html#getParameterDescriptionFromParsedData">getParameterDescriptionFromParsedData</a></li><li data-type='method'><a href="HydroLangGRIB2Parser.html#getParameterFromData">getParameterFromData</a></li><li data-type='method'><a href="HydroLangGRIB2Parser.html#getParameterFromData">getParameterFromData</a></li><li data-type='method'><a href="HydroLangGRIB2Parser.html#getParameterFromParsedData">getParameterFromParsedData</a></li><li data-type='method'><a href="HydroLangGRIB2Parser.html#getParameterName">getParameterName</a></li><li data-type='method'><a href="HydroLangGRIB2Parser.html#getParameterNameFromData">getParameterNameFromData</a></li><li data-type='method'><a href="HydroLangGRIB2Parser.html#getParameterNameFromData">getParameterNameFromData</a></li><li data-type='method'><a href="HydroLangGRIB2Parser.html#getParameterNameFromParsedData">getParameterNameFromParsedData</a></li><li data-type='method'><a href="HydroLangGRIB2Parser.html#getUnitsFromData">getUnitsFromData</a></li><li data-type='method'><a href="HydroLangGRIB2Parser.html#getUnitsFromData">getUnitsFromData</a></li><li data-type='method'><a href="HydroLangGRIB2Parser.html#getUnitsFromParsedData">getUnitsFromParsedData</a></li><li data-type='method'><a href="HydroLangGRIB2Parser.html#getVariableFromMessage">getVariableFromMessage</a></li><li data-type='method'><a href="HydroLangGRIB2Parser.html#parseBuffer">parseBuffer</a></li><li data-type='method'><a href="HydroLangGRIB2Parser.html#parseBuffer">parseBuffer</a></li><li data-type='method'><a href="HydroLangGRIB2Parser.html#parseBufferStreaming">parseBufferStreaming</a></li><li data-type='method'><a href="HydroLangGRIB2Parser.html#parseGRIBHeaders">parseGRIBHeaders</a></li><li data-type='method'><a href="HydroLangGRIB2Parser.html#parseGridSection">parseGridSection</a></li><li data-type='method'><a href="HydroLangGRIB2Parser.html#parseProductSection">parseProductSection</a></li></ul></li><li><a href="map.html">map</a><ul class='methods'><li data-type='method'><a href="map.html#.addGeoRasterLayer">addGeoRasterLayer</a></li><li data-type='method'><a href="map.html#.addMarker">addMarker</a></li><li data-type='method'><a href="map.html#.addPopup">addPopup</a></li><li data-type='method'><a href="map.html#.draw">draw</a></li><li data-type='method'><a href="map.html#.generateColors">generateColors</a></li><li data-type='method'><a href="map.html#.geoJSON">geoJSON</a></li><li data-type='method'><a href="map.html#.kml">kml</a></li><li data-type='method'><a href="map.html#.Layers">Layers</a></li><li data-type='method'><a href="map.html#.loader">loader</a></li><li data-type='method'><a href="map.html#.markerStyles">markerStyles</a></li><li data-type='method'><a href="map.html#.renderMap">renderMap</a></li></ul></li><li><a href="ModelProxy.html">ModelProxy</a><ul class='methods'><li data-type='method'><a href="ModelProxy.html#.dispose">dispose</a></li><li data-type='method'><a href="ModelProxy.html#.predict">predict</a></li><li data-type='method'><a href="ModelProxy.html#.save">save</a></li><li data-type='method'><a href="ModelProxy.html#.train">train</a></li></ul></li><li><a href="MRMSDataSource.html">MRMSDataSource</a><ul class='methods'><li data-type='method'><a href="MRMSDataSource.html#extractGridData">extractGridData</a></li><li data-type='method'><a href="MRMSDataSource.html#extractPointData">extractPointData</a></li><li data-type='method'><a href="MRMSDataSource.html#fetch">fetch</a></li><li data-type='method'><a href="MRMSDataSource.html#findProductForVariable">findProductForVariable</a></li><li data-type='method'><a href="MRMSDataSource.html#generateURL">generateURL</a></li><li data-type='method'><a href="MRMSDataSource.html#getDatasetInfo">getDatasetInfo</a></li><li data-type='method'><a href="MRMSDataSource.html#inferVariableFromProduct">inferVariableFromProduct</a></li><li data-type='method'><a href="MRMSDataSource.html#loadDatasource">loadDatasource</a></li><li data-type='method'><a href="MRMSDataSource.html#processFile">processFile</a></li></ul></li><li><a href="NetCDFDataSource.html">NetCDFDataSource</a><ul class='methods'><li data-type='method'><a href="NetCDFDataSource.html#getNetCDFSlice">getNetCDFSlice</a></li><li data-type='method'><a href="NetCDFDataSource.html#getNetCDFValue">getNetCDFValue</a></li><li data-type='method'><a href="NetCDFDataSource.html#getNetCDFVariable">getNetCDFVariable</a></li><li data-type='method'><a href="NetCDFDataSource.html#openNetCDF">openNetCDF</a></li></ul></li><li><a href="NLDASDataSource.html">NLDASDataSource</a><ul class='methods'><li data-type='method'><a href="NLDASDataSource.html#extractDayData">extractDayData</a></li><li data-type='method'><a href="NLDASDataSource.html#extractGridData">extractGridData</a></li><li data-type='method'><a href="NLDASDataSource.html#extractPointData">extractPointData</a></li><li data-type='method'><a href="NLDASDataSource.html#extractRawNetCDF">extractRawNetCDF</a></li><li data-type='method'><a href="NLDASDataSource.html#generateFileURL">generateFileURL</a></li></ul></li><li><a href="nn.html">nn</a><ul class='methods'><li data-type='method'><a href="nn.html#.createModel">createModel</a></li><li data-type='method'><a href="nn.html#.loadModel">loadModel</a></li></ul></li><li><a href="nnUtils.html">nnUtils</a></li><li><a href="NWMDataSource.html">NWMDataSource</a><ul class='methods'><li data-type='method'><a href="NWMDataSource.html#buildFileURL">buildFileURL</a></li><li data-type='method'><a href="NWMDataSource.html#convertToTypedArray">convertToTypedArray</a></li><li data-type='method'><a href="NWMDataSource.html#extractData">extractData</a></li><li data-type='method'><a href="NWMDataSource.html#extractNetCDFData">extractNetCDFData</a></li><li data-type='method'><a href="NWMDataSource.html#extractZarrData">extractZarrData</a></li><li data-type='method'><a href="NWMDataSource.html#findCOMIDIndex">findCOMIDIndex</a></li><li data-type='method'><a href="NWMDataSource.html#getDatasetInfo">getDatasetInfo</a></li></ul></li><li><a href="PRISMDataSource.html">PRISMDataSource</a><ul class='methods'><li data-type='method'><a href="PRISMDataSource.html#determinePRISMParams">determinePRISMParams</a></li><li data-type='method'><a href="PRISMDataSource.html#extractGridData">extractGridData</a></li><li data-type='method'><a href="PRISMDataSource.html#extractPointData">extractPointData</a></li><li data-type='method'><a href="PRISMDataSource.html#fetchAndExtractPRISM">fetchAndExtractPRISM</a></li><li data-type='method'><a href="PRISMDataSource.html#generateFileURL">generateFileURL</a></li></ul></li><li><a href="stats.html">stats</a><ul class='methods'><li data-type='method'><a href="stats.html#.andersonDarling">andersonDarling</a></li><li data-type='method'><a href="stats.html#.anova">anova</a></li><li data-type='method'><a href="stats.html#.arrchange">arrchange</a></li><li data-type='method'><a href="stats.html#.autoCorrelation">autoCorrelation</a></li><li data-type='method'><a href="stats.html#.autocovarianceMatrix">autocovarianceMatrix</a></li><li data-type='method'><a href="stats.html#.basicstats">basicstats</a></li><li data-type='method'><a href="stats.html#.bernoulliDist">bernoulliDist</a></li><li data-type='method'><a href="stats.html#.betaDist">betaDist</a></li><li data-type='method'><a href="stats.html#.binomialCoefficient">binomialCoefficient</a></li><li data-type='method'><a href="stats.html#.binomialDist">binomialDist</a></li><li data-type='method'><a href="stats.html#.bootstrap">bootstrap</a></li><li data-type='method'><a href="stats.html#.breuschPaganTest">breuschPaganTest</a></li><li data-type='method'><a href="stats.html#.chisqCDF">chisqCDF</a></li><li data-type='method'><a href="stats.html#.cleaner">cleaner</a></li><li data-type='method'><a href="stats.html#.computeD">computeD</a></li><li data-type='method'><a href="stats.html#.copydata">copydata</a></li><li data-type='method'><a href="stats.html#.correlation">correlation</a></li><li data-type='method'><a href="stats.html#.datagaps">datagaps</a></li><li data-type='method'><a href="stats.html#.dateparser">dateparser</a></li><li data-type='method'><a href="stats.html#.differencing">differencing</a></li><li data-type='method'><a href="stats.html#.dotProduct">dotProduct</a></li><li data-type='method'><a href="stats.html#.efficiencies">efficiencies</a></li><li data-type='method'><a href="stats.html#.errorMetrics">errorMetrics</a></li><li data-type='method'><a href="stats.html#.exponentialDist">exponentialDist</a></li><li data-type='method'><a href="stats.html#.exponentialMovingAverage">exponentialMovingAverage</a></li><li data-type='method'><a href="stats.html#.fastfourier">fastfourier</a></li><li data-type='method'><a href="stats.html#.flatenise">flatenise</a></li><li data-type='method'><a href="stats.html#.forwardFill">forwardFill</a></li><li data-type='method'><a href="stats.html#.frequency">frequency</a></li><li data-type='method'><a href="stats.html#.fTest">fTest</a></li><li data-type='method'><a href="stats.html#.gammaCDFApprox">gammaCDFApprox</a></li><li data-type='method'><a href="stats.html#.gammaDist">gammaDist</a></li><li data-type='method'><a href="stats.html#.gapfiller">gapfiller</a></li><li data-type='method'><a href="stats.html#.gapremoval">gapremoval</a></li><li data-type='method'><a href="stats.html#.gaussianDist">gaussianDist</a></li><li data-type='method'><a href="stats.html#.generateRandomData">generateRandomData</a></li><li data-type='method'><a href="stats.html#.geometricDist">geometricDist</a></li><li data-type='method'><a href="stats.html#.getNextState">getNextState</a></li><li data-type='method'><a href="stats.html#.gevDistribution">gevDistribution</a></li><li data-type='method'><a href="stats.html#.gumbelDist">gumbelDist</a></li><li data-type='method'><a href="stats.html#.interoutliers">interoutliers</a></li><li data-type='method'><a href="stats.html#.itemfilter">itemfilter</a></li><li data-type='method'><a href="stats.html#.joinarray">joinarray</a></li><li data-type='method'><a href="stats.html#.KS_computePValue">KS_computePValue</a></li><li data-type='method'><a href="stats.html#.KS_rejectAtAlpha">KS_rejectAtAlpha</a></li><li data-type='method'><a href="stats.html#.kurtosis">kurtosis</a></li><li data-type='method'><a href="stats.html#.linearMovingAverage">linearMovingAverage</a></li><li data-type='method'><a href="stats.html#.lognormalDist">lognormalDist</a></li><li data-type='method'><a href="stats.html#.LogSeriesDistribution">LogSeriesDistribution</a></li><li data-type='method'><a href="stats.html#.mannWhitney">mannWhitney</a></li><li data-type='method'><a href="stats.html#.matrixInverse">matrixInverse</a></li><li data-type='method'><a href="stats.html#.max">max</a></li><li data-type='method'><a href="stats.html#.mean">mean</a></li><li data-type='method'><a href="stats.html#.median">median</a></li><li data-type='method'><a href="stats.html#.min">min</a></li><li data-type='method'><a href="stats.html#.MK">MK</a></li><li data-type='method'><a href="stats.html#.multinomialDistribution">multinomialDistribution</a></li><li data-type='method'><a href="stats.html#.multiplyMatrix">multiplyMatrix</a></li><li data-type='method'><a href="stats.html#.multiregression">multiregression</a></li><li data-type='method'><a href="stats.html#.normalcdf">normalcdf</a></li><li data-type='method'><a href="stats.html#.normalDistribution">normalDistribution</a></li><li data-type='method'><a href="stats.html#.normoutliers">normoutliers</a></li><li data-type='method'><a href="stats.html#.numerise">numerise</a></li><li data-type='method'><a href="stats.html#.onearray">onearray</a></li><li data-type='method'><a href="stats.html#.outremove">outremove</a></li><li data-type='method'><a href="stats.html#.partialAutoCorrelation">partialAutoCorrelation</a></li><li data-type='method'><a href="stats.html#.poissonProcess">poissonProcess</a></li><li data-type='method'><a href="stats.html#.push">push</a></li><li data-type='method'><a href="stats.html#.quantile">quantile</a></li><li data-type='method'><a href="stats.html#.randomWalk">randomWalk</a></li><li data-type='method'><a href="stats.html#.range">range</a></li><li data-type='method'><a href="stats.html#.regression">regression</a></li><li data-type='method'><a href="stats.html#.residualVariance">residualVariance</a></li><li data-type='method'><a href="stats.html#.returnPeriod">returnPeriod</a></li><li data-type='method'><a href="stats.html#.runMarkovChainMonteCarlo">runMarkovChainMonteCarlo</a></li><li data-type='method'><a href="stats.html#.runMonteCarlo">runMonteCarlo</a></li><li data-type='method'><a href="stats.html#.runSimulation">runSimulation</a></li><li data-type='method'><a href="stats.html#.runVegas">runVegas</a></li><li data-type='method'><a href="stats.html#.seasonalDecompose">seasonalDecompose</a></li><li data-type='method'><a href="stats.html#.shapiroWilk">shapiroWilk</a></li><li data-type='method'><a href="stats.html#.simpleMovingAverage">simpleMovingAverage</a></li><li data-type='method'><a href="stats.html#.skewness">skewness</a></li><li data-type='method'><a href="stats.html#.spiCompute">spiCompute</a></li><li data-type='method'><a href="stats.html#.standardize">standardize</a></li><li data-type='method'><a href="stats.html#.stddev">stddev</a></li><li data-type='method'><a href="stats.html#.sum">sum</a></li><li data-type='method'><a href="stats.html#.sumsqrd">sumsqrd</a></li><li data-type='method'><a href="stats.html#.timegaps">timegaps</a></li><li data-type='method'><a href="stats.html#.transposeMatrix">transposeMatrix</a></li><li data-type='method'><a href="stats.html#.tTest">tTest</a></li><li data-type='method'><a href="stats.html#.uniformDist">uniformDist</a></li><li data-type='method'><a href="stats.html#.unique">unique</a></li><li data-type='method'><a href="stats.html#.variance">variance</a></li><li data-type='method'><a href="stats.html#.weibullDist">weibullDist</a></li><li data-type='method'><a href="stats.html#.wilcoxonSignedRank">wilcoxonSignedRank</a></li></ul></li><li><a href="visualize.html">visualize</a><ul class='methods'><li data-type='method'><a href="visualize.html#.chart">chart</a></li><li data-type='method'><a href="visualize.html#.draw">draw</a></li><li data-type='method'><a href="visualize.html#.drawHtmlTable">drawHtmlTable</a></li><li data-type='method'><a href="visualize.html#.generateReport">generateReport</a></li><li data-type='method'><a href="visualize.html#.prettyPrint">prettyPrint</a></li><li data-type='method'><a href="visualize.html#.table">table</a></li></ul></li><li><a href="ZarrDataSource.html">ZarrDataSource</a><ul class='methods'><li data-type='method'><a href="ZarrDataSource.html#getZarrArrayData">getZarrArrayData</a></li><li data-type='method'><a href="ZarrDataSource.html#getZarrChunk">getZarrChunk</a></li><li data-type='method'><a href="ZarrDataSource.html#getZarrRegion">getZarrRegion</a></li><li data-type='method'><a href="ZarrDataSource.html#getZarrSlice">getZarrSlice</a></li><li data-type='method'><a href="ZarrDataSource.html#getZarrValue">getZarrValue</a></li><li data-type='method'><a href="ZarrDataSource.html#openZarrArray">openZarrArray</a></li></ul></li></ul><h3>Modules</h3><ul><li><a href="module-analyze.html">analyze</a><ul class='methods'><li data-type='method'><a href="module-analyze.html#loadFloodDM">loadFloodDM</a></li></ul></li><li><a href="module-mapsources.html">mapsources</a></li></ul><h3>Externals</h3><ul><li><a href="external-D3.html">D3</a></li><li><a href="external-GeospatialLoader.html">GeospatialLoader</a></li><li><a href="external-GoogleCharts.html">GoogleCharts</a></li><li><a href="external-googlemapsapi.html">googlemapsapi</a></li><li><a href="external-GriddedData.html">GriddedData</a></li><li><a href="external-HDF5Loader.html">HDF5Loader</a></li><li><a href="external-leafletosmapi.html">leafletosmapi</a></li><li><a href="external-NetCDFLoader.html">NetCDFLoader</a></li><li><a href="external-tensorflow.html">tensorflow</a></li><li><a href="external-tileprov.html">tileprov</a></li><li><a href="external-ZarritaLoader.html">ZarritaLoader</a></li></ul><h3>Namespaces</h3><ul><li><a href="data.cache.html">cache</a><ul class='methods'><li data-type='method'><a href="data.cache.html#.checkCache">checkCache</a></li><li data-type='method'><a href="data.cache.html#.clear">clear</a></li><li data-type='method'><a href="data.cache.html#.delete">delete</a></li><li data-type='method'><a href="data.cache.html#.getStats">getStats</a></li><li data-type='method'><a href="data.cache.html#.list">list</a></li></ul></li><li><a href="datasources.html">datasources</a><ul class='members'><li data-type='method'><a href="datasources.html#.AEMET">AEMET</a></li><li data-type='method'><a href="datasources.html#.AORC">AORC</a></li><li data-type='method'><a href="datasources.html#.BMKG">BMKG</a></li><li data-type='method'><a href="datasources.html#.CHIRPS">CHIRPS</a></li><li data-type='method'><a href="datasources.html#.ClearCreek">ClearCreek</a></li><li data-type='method'><a href="datasources.html#.CMA">CMA</a></li><li data-type='method'><a href="datasources.html#.CPTEC">CPTEC</a></li><li data-type='method'><a href="datasources.html#.3DEP">3DEP</a></li><li data-type='method'><a href="datasources.html#.DWD">DWD</a></li><li data-type='method'><a href="datasources.html#.EAUK">EAUK</a></li><li data-type='method'><a href="datasources.html#.ECMWF">ECMWF</a></li><li data-type='method'><a href="datasources.html#.EPA">EPA</a></li><li data-type='method'><a href="datasources.html#.FAO">FAO</a></li><li data-type='method'><a href="datasources.html#.FEMA">FEMA</a></li><li data-type='method'><a href="datasources.html#.flooddamage_dt">flooddamage_dt</a></li><li data-type='method'><a href="datasources.html#.FMI">FMI</a></li><li data-type='method'><a href="datasources.html#.HRRR">HRRR</a></li><li data-type='method'><a href="datasources.html#.HydroGeospatial">HydroGeospatial</a></li><li data-type='method'><a href="datasources.html#.IDEAM">IDEAM</a></li><li data-type='method'><a href="datasources.html#.IFIS">IFIS</a></li><li data-type='method'><a href="datasources.html#.IMD">IMD</a></li><li data-type='method'><a href="datasources.html#.ISRIC">ISRIC</a></li><li data-type='method'><a href="datasources.html#.JMA">JMA</a></li><li data-type='method'><a href="datasources.html#.KMA">KMA</a></li><li data-type='method'><a href="datasources.html#.KNMI">KNMI</a></li><li data-type='method'><a href="datasources.html#.MeteoFrance">MeteoFrance</a></li><li data-type='method'><a href="datasources.html#.MeteoIT">MeteoIT</a></li><li data-type='method'><a href="datasources.html#.MeteoSTAT">MeteoSTAT</a></li><li data-type='method'><a href="datasources.html#.MetNo">MetNo</a></li><li data-type='method'><a href="datasources.html#.mitigation_dt">mitigation_dt</a></li><li data-type='method'><a href="datasources.html#.MRMS">MRMS</a></li><li data-type='method'><a href="datasources.html#.NASAPOWER">NASAPOWER</a></li><li data-type='method'><a href="datasources.html#.NHDPlus">NHDPlus</a></li><li data-type='method'><a href="datasources.html#.NLDAS">NLDAS</a></li><li data-type='method'><a href="datasources.html#.NLDI">NLDI</a></li><li data-type='method'><a href="datasources.html#.NOAA">NOAA</a></li><li data-type='method'><a href="datasources.html#.NWM">NWM</a></li><li data-type='method'><a href="datasources.html#.NWPS">NWPS</a></li><li data-type='method'><a href="datasources.html#.NWS">NWS</a></li><li data-type='method'><a href="datasources.html#.OpenMeteo">OpenMeteo</a></li><li data-type='method'><a href="datasources.html#.PRISM">PRISM</a></li><li data-type='method'><a href="datasources.html#.ProxyServers">ProxyServers</a></li><li data-type='method'><a href="datasources.html#.SILO">SILO</a></li><li data-type='method'><a href="datasources.html#.SISSA">SISSA</a></li><li data-type='method'><a href="datasources.html#.SMHI">SMHI</a></li><li data-type='method'><a href="datasources.html#.SMN">SMN</a></li><li data-type='method'><a href="datasources.html#.soapEnv">soapEnv</a></li><li data-type='method'><a href="datasources.html#.TAMSAT">TAMSAT</a></li><li data-type='method'><a href="datasources.html#.TMD">TMD</a></li><li data-type='method'><a href="datasources.html#.USGS">USGS</a></li><li data-type='method'><a href="datasources.html#.USGS">USGS</a></li><li data-type='method'><a href="datasources.html#.WBD">WBD</a></li><li data-type='method'><a href="datasources.html#.Worldbank">Worldbank</a></li><li data-type='method'><a href="datasources.html#.WQP">WQP</a></li></ul></li><li><a href="datasources.CUAHSI.html">CUAHSI</a><ul class='members'><li data-type='method'><a href="datasources.CUAHSI.html#.hisCentral">hisCentral</a></li><li data-type='method'><a href="datasources.CUAHSI.html#.hydroShare">hydroShare</a></li><li data-type='method'><a href="datasources.CUAHSI.html#.waterOneFlow">waterOneFlow</a></li></ul></li><li><a href="HydroBMI.html">HydroBMI</a><ul class='members'><li data-type='method'><a href="HydroBMI.html#.BMIConfig">BMIConfig</a></li></ul></li><li><a href="HydroBMI.Hydro.html">Hydro</a></li><li><a href="Hydrolang.html">Hydrolang</a></li></ul><h3>Global</h3><ul><li><a href="global.html#_dx">_dx</a></li><li><a href="global.html#_ensureLibraries">_ensureLibraries</a></li><li><a href="global.html#_ensureWorker">_ensureWorker</a></li><li><a href="global.html#_openFromArrayBuffer">_openFromArrayBuffer</a></li><li><a href="global.html#_openGDALSource">_openGDALSource</a></li><li><a href="global.html#_runWorker">_runWorker</a></li><li><a href="global.html#_toGeorasterObject">_toGeorasterObject</a></li><li><a href="global.html#_toGeoTIFF">_toGeoTIFF</a></li><li><a href="global.html#addCustomLegend">addCustomLegend</a></li><li><a href="global.html#aggregateSpatial">aggregateSpatial</a></li><li><a href="global.html#aggregateTemporal">aggregateTemporal</a></li><li><a href="global.html#aggregateTime">aggregateTime</a></li><li><a href="global.html#algebra">algebra</a></li><li><a href="global.html#applyDataScaling">applyDataScaling</a></li><li><a href="global.html#applyQualityControl">applyQualityControl</a></li><li><a href="global.html#applyScalingToValue">applyScalingToValue</a></li><li><a href="global.html#aspect">aspect</a></li><li><a href="global.html#bandMath">bandMath</a></li><li><a href="global.html#cacheAPI">cacheAPI</a></li><li><a href="global.html#cachedFetch">cachedFetch</a></li><li><a href="global.html#calculateStatistics">calculateStatistics</a></li><li><a href="global.html#clip">clip</a></li><li><a href="global.html#clipGeo">clipGeo</a></li><li><a href="global.html#constructNWMFileURL">constructNWMFileURL</a></li><li><a href="global.html#convertAORCToCSV">convertAORCToCSV</a></li><li><a href="global.html#convertAORCToNetCDF">convertAORCToNetCDF</a></li><li><a href="global.html#convertDataUnits">convertDataUnits</a></li><li><a href="global.html#convertGeoTIFFToGeoraster">convertGeoTIFFToGeoraster</a></li><li><a href="global.html#convertNWMToCSV">convertNWMToCSV</a></li><li><a href="global.html#convertToArray">convertToArray</a></li><li><a href="global.html#convertToCSV">convertToCSV</a></li><li><a href="global.html#convertToNetCDF">convertToNetCDF</a></li><li><a href="global.html#createGoogleMapsGeoRasterLayer">createGoogleMapsGeoRasterLayer</a></li><li><a href="global.html#createLeafletCanvasGeoRasterLayer">createLeafletCanvasGeoRasterLayer</a></li><li><a href="global.html#createLeafletGeoRasterLayer">createLeafletGeoRasterLayer</a></li><li><a href="global.html#createSegmentationModel">createSegmentationModel</a></li><li><a href="global.html#createSimpleGeoRasterOverlay">createSimpleGeoRasterOverlay</a></li><li><a href="global.html#createStore">createStore</a></li><li><a href="global.html#createTransformer">createTransformer</a></li><li><a href="global.html#createZarrStore">createZarrStore</a></li><li><a href="global.html#decompressGzip">decompressGzip</a></li><li><a href="global.html#detectFormat">detectFormat</a></li><li><a href="global.html#determinePRISMRegion">determinePRISMRegion</a></li><li><a href="global.html#downloadERA5File">downloadERA5File</a></li><li><a href="global.html#drawHtmlTable">drawHtmlTable</a></li><li><a href="global.html#execute">execute</a></li><li><a href="global.html#expandSpatialBounds">expandSpatialBounds</a></li><li><a href="global.html#extractERA5Data">extractERA5Data</a></li><li><a href="global.html#extractERA5GridData">extractERA5GridData</a></li><li><a href="global.html#extractERA5PointData">extractERA5PointData</a></li><li><a href="global.html#extractERA5TimeSeries">extractERA5TimeSeries</a></li><li><a href="global.html#extractGRIB2Data">extractGRIB2Data</a></li><li><a href="global.html#extractHRRRGridData">extractHRRRGridData</a></li><li><a href="global.html#extractHRRRPointData">extractHRRRPointData</a></li><li><a href="global.html#extractHRRRTimeSeries">extractHRRRTimeSeries</a></li><li><a href="global.html#extractMRMSGridData">extractMRMSGridData</a></li><li><a href="global.html#extractMRMSPointData">extractMRMSPointData</a></li><li><a href="global.html#extractMRMSTimeSeries">extractMRMSTimeSeries</a></li><li><a href="global.html#extractNLDASGridData">extractNLDASGridData</a></li><li><a href="global.html#extractNLDASMultiplePoints">extractNLDASMultiplePoints</a></li><li><a href="global.html#extractNLDASPointData">extractNLDASPointData</a></li><li><a href="global.html#extractNLDASRawNetCDF">extractNLDASRawNetCDF</a></li><li><a href="global.html#extractNWMData">extractNWMData</a></li><li><a href="global.html#extractPRISMGridData">extractPRISMGridData</a></li><li><a href="global.html#extractPRISMPointData">extractPRISMPointData</a></li><li><a href="global.html#extractPRISMTimeSeries">extractPRISMTimeSeries</a></li><li><a href="global.html#fetchDEMData">fetchDEMData</a></li><li><a href="global.html#fetchPointElevation">fetchPointElevation</a></li><li><a href="global.html#fillSinks">fillSinks</a></li><li><a href="global.html#flattenND">flattenND</a></li><li><a href="global.html#formatAORCOutput">formatAORCOutput</a></li><li><a href="global.html#formatData">formatData</a></li><li><a href="global.html#formatNWMOutput">formatNWMOutput</a></li><li><a href="global.html#formatPRISMTimePeriod">formatPRISMTimePeriod</a></li><li><a href="global.html#generateNWMDateRange">generateNWMDateRange</a></li><li><a href="global.html#generatePRISMFileURL">generatePRISMFileURL</a></li><li><a href="global.html#generateProcessedDataKey">generateProcessedDataKey</a></li><li><a href="global.html#generateSimpleCacheKey">generateSimpleCacheKey</a></li><li><a href="global.html#getArrayData">getArrayData</a></li><li><a href="global.html#getAvailableERA5Variables">getAvailableERA5Variables</a></li><li><a href="global.html#getAvailableHRRRVariables">getAvailableHRRRVariables</a></li><li><a href="global.html#getAvailableMRMSProducts">getAvailableMRMSProducts</a></li><li><a href="global.html#getAvailableNLDASVariables">getAvailableNLDASVariables</a></li><li><a href="global.html#getAvailablePRISMVariables">getAvailablePRISMVariables</a></li><li><a href="global.html#getChunk">getChunk</a></li><li><a href="global.html#getFile">getFile</a></li><li><a href="global.html#getGridDataLibrary">getGridDataLibrary</a></li><li><a href="global.html#getHRRRDatasetInfo">getHRRRDatasetInfo</a></li><li><a href="global.html#getInfo">getInfo</a></li><li><a href="global.html#getLeafletColorForElevation">getLeafletColorForElevation</a></li><li><a href="global.html#getMap">getMap</a></li><li><a href="global.html#getMRMSDatasetInfo">getMRMSDatasetInfo</a></li><li><a href="global.html#getNLDASDatasetInfo">getNLDASDatasetInfo</a></li><li><a href="global.html#getNWMTemporalInfo">getNWMTemporalInfo</a></li><li><a href="global.html#getPRISMDatasetInfo">getPRISMDatasetInfo</a></li><li><a href="global.html#getRecommendedPRISMResolution">getRecommendedPRISMResolution</a></li><li><a href="global.html#getRegion">getRegion</a></li><li><a href="global.html#goldfeldQuandtTest">goldfeldQuandtTest</a></li><li><a href="global.html#GRIDDED_SOURCES">GRIDDED_SOURCES</a></li><li><a href="global.html#gridToTensor">gridToTensor</a></li><li><a href="global.html#hillshade">hillshade</a></li><li><a href="global.html#imgToTensor">imgToTensor</a></li><li><a href="global.html#info">info</a></li><li><a href="global.html#isGridDataLibraryLoaded">isGridDataLibraryLoaded</a></li><li><a href="global.html#isLoaded">isLoaded</a></li><li><a href="global.html#isValidBoundingBox">isValidBoundingBox</a></li><li><a href="global.html#isValidCoordinate">isValidCoordinate</a></li><li><a href="global.html#load">load</a></li><li><a href="global.html#loadGeoRasterLayerPlugin">loadGeoRasterLayerPlugin</a></li><li><a href="global.html#loadGeoTIFFFromBuffer">loadGeoTIFFFromBuffer</a></li><li><a href="global.html#loadGridDataLibrary">loadGridDataLibrary</a></li><li><a href="global.html#mapPixels">mapPixels</a></li><li><a href="global.html#mask">mask</a></li><li><a href="global.html#modelRegistry">modelRegistry</a></li><li><a href="global.html#openArray">openArray</a></li><li><a href="global.html#parseGRIB2">parseGRIB2</a></li><li><a href="global.html#pca">pca</a></li><li><a href="global.html#pollECMWFStatus">pollECMWFStatus</a></li><li><a href="global.html#preprocess">preprocess</a></li><li><a href="global.html#preprocessData">preprocessData</a></li><li><a href="global.html#processAORCBulkExtraction">processAORCBulkExtraction</a></li><li><a href="global.html#processAORCDatasetInfo">processAORCDatasetInfo</a></li><li><a href="global.html#processAORCGridData">processAORCGridData</a></li><li><a href="global.html#processAORCPointData">processAORCPointData</a></li><li><a href="global.html#processAORCTimeSeriesData">processAORCTimeSeriesData</a></li><li><a href="global.html#processERA5GRIB2Data">processERA5GRIB2Data</a></li><li><a href="global.html#processFileInChunks">processFileInChunks</a></li><li><a href="global.html#processGriddedSource">processGriddedSource</a></li><li><a href="global.html#processNWMBulkExtraction">processNWMBulkExtraction</a></li><li><a href="global.html#readGRIB2Chunked">readGRIB2Chunked</a></li><li><a href="global.html#readNetCDFChunked">readNetCDFChunked</a></li><li><a href="global.html#recenter">recenter</a></li><li><a href="global.html#reproject">reproject</a></li><li><a href="global.html#saveFile">saveFile</a></li><li><a href="global.html#seriesToTensor">seriesToTensor</a></li><li><a href="global.html#slope">slope</a></li><li><a href="global.html#sourceType">sourceType</a></li><li><a href="global.html#streamExtract">streamExtract</a></li><li><a href="global.html#testMRMSUrlGeneration">testMRMSUrlGeneration</a></li><li><a href="global.html#tile">tile</a></li><li><a href="global.html#transformVariable">transformVariable</a></li><li><a href="global.html#validate3DEPParams">validate3DEPParams</a></li><li><a href="global.html#validateERA5Config">validateERA5Config</a></li><li><a href="global.html#validateHRRRConfig">validateHRRRConfig</a></li><li><a href="global.html#validateMRMSConfig">validateMRMSConfig</a></li><li><a href="global.html#validateNLDASConfig">validateNLDASConfig</a></li><li><a href="global.html#validatePRISMConfig">validatePRISMConfig</a></li><li><a href="global.html#validatePRISMVariable">validatePRISMVariable</a></li><li><a href="global.html#vectorize">vectorize</a></li><li><a href="global.html#whitesTest">whitesTest</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">modules/data/utils/gridded-data-utils.js</h1>
    
    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * Gridded data format utilities
 * Handles lazy loading and management of gridded data libraries (Zarr, NetCDF, HDF5, GeoTIFF)
 * Provides base class for all gridded data sources with common patterns
 */

// Import centralized gridded data loader
import * as griddedData from '../../../external/gridded-data/gridded-data.js';

/**
 * Base class for gridded data sources (AORC, NWM, MRMS, HRRR, NLDAS, PRISM, ECMWF, 3DEP)
 * Consolidates all common patterns to eliminate repetition across utils files
 */
export class GriddedDataSource {
  /**
   * @param {Object} config - Configuration object
   * @param {string} config.sourceName - Source identifier (e.g., 'aorc', 'mrms', 'hrrr')
   * @param {string} config.libraryType - Library type needed ('zarr', 'grib2', 'netcdf', 'geospatial')
   * @param {string} config.defaultFormat - Default data format ('zarr', 'grib2', 'netcdf', 'tiff')
   * @param {Object} config.datasourceConfig - Reference to datasources configuration
   * @param {Object} config.variables - Variables configuration for this source
   */
  constructor(config) {
    this.sourceName = config.sourceName;
    this.libraryType = config.libraryType;
    this.defaultFormat = config.defaultFormat || config.libraryType;
    this.datasourceConfig = config.datasourceConfig;
    this.variables = config.variables;
    this.library = null;
  }

  /**
   * Unified fetch with automatic caching context setup
   * Eliminates duplicate fetch functions across all utils files
   */
  async fetch(url, options = {}) {
    console.log(`[${this.sourceName}] Fetching: ${url}`);

    // Set global cache context ONLY if caching is explicitly requested
    if (options.useCache === true || options.params?.cache === true) {
      globalThis._hydroCacheContext = globalThis._hydroCacheContext || {};
      globalThis._hydroCacheContext.source = this.sourceName;
      globalThis._hydroCacheContext.params = options.params || {};
      globalThis._hydroCacheContext.cacheId = options.cacheId || options.params?.cacheId;
    }

    // Handle Proxy
    let fetchUrl = url;
    if (options.proxy || (options.params &amp;&amp; options.params.proxy)) {
      // Default to local-proxy if true, or use specified proxy
      const proxyName = (options.proxy === true || options.params.proxy === true) ? 'local-proxy' : (options.proxy || options.params.proxy);

      // Hardcoded generic proxy map for internal use if module import is difficult here
      // ideally we would import proxies from ../datasources/proxy.js but circular deps can be tricky
      const proxies = {
        "local-proxy": "https://hydroinformatics.uiowa.edu/lab/cors/?url=",
        "researchverse": "https://researchverse.ai/backend/api/simple-proxy/?url=",
        "corsproxy": "https://corsproxy.io/?"
      };

      const proxyEndpoint = proxies[proxyName] || proxies['local-proxy'];

      // Handle CORS proxy format (some append ?url=, some just append URL)
      // For simplicity, assuming the ones with ?url= need encoding, others might just append
      if (proxyEndpoint.includes('?url=')) {
        fetchUrl = `${proxyEndpoint}${encodeURIComponent(url)}`;
      } else {
        fetchUrl = `${proxyEndpoint}${url}`;
      }

      console.log(`[${this.sourceName}] Using proxy: ${fetchUrl}`);
    }

    try {
      const response = await fetch(fetchUrl, {
        method: 'GET',
        headers: {
          'Accept': options.accept || 'application/octet-stream, application/json, */*',
          ...options.headers
        }
      });

      // Handle case where cachedFetch returns ArrayBuffer directly
      if (response instanceof ArrayBuffer || (typeof Buffer !== 'undefined' &amp;&amp; response instanceof Buffer)) {
        console.log(`[${this.sourceName}] Successfully fetched ${(response.byteLength / 1024 / 1024).toFixed(1)} MB (cached)`);
        return response;
      }

      if (!response.ok) {
        // Standardized HTTP error handling
        if (response.status === 404) {
          throw new Error(`${this.sourceName.toUpperCase()} file not found: ${url}. The requested data may not be available.`);
        } else if (response.status === 403) {
          throw new Error(`Access denied to ${this.sourceName.toUpperCase()} file: ${url}.`);
        } else if (response.status === 429) {
          throw new Error(`Rate limited by ${this.sourceName.toUpperCase()} server: ${url}. Please wait before retrying.`);
        }
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      const buffer = await response.arrayBuffer();
      console.log(`[${this.sourceName}] Successfully fetched ${(buffer.byteLength / 1024 / 1024).toFixed(1)} MB`);

      return buffer;

    } catch (error) {
      console.error(`[${this.sourceName}] Fetch failed:`, error.message);
      throw this.handleError(error, { context: 'fetch', url });
    }
  }

  /**
   * Unified JSON fetch
   */
  async fetchJSON(url, options = {}) {
    return this.fetch(url, { ...options, accept: 'application/json' })
      .then(buffer => {
        const dec = new TextDecoder("utf-8");
        return JSON.parse(dec.decode(buffer));
      });
  }

  /**
   * Universal data scaling - works for all sources
   */
  applyScaling(value, variableMeta) {
    if (value === null || value === undefined) {
      return null;
    }

    // Check for fill/missing values
    if (variableMeta.fillValue !== undefined &amp;&amp; value === variableMeta.fillValue) {
      return null;
    }
    if (variableMeta.missingValue !== undefined &amp;&amp; value === variableMeta.missingValue) {
      return null;
    }

    // Apply scale factor and offset
    const scaleFactor = variableMeta.scaleFactor || 1.0;
    const addOffset = variableMeta.addOffset || 0.0;

    return (value * scaleFactor) + addOffset;
  }

  /**
   * Universal decompression handler
   */
  async decompress(compressedData, format = null, options = {}) {
    // Default to raw mode unless process is explicitly true
    // Also support legacy raw=true behavior (though strictly process=true is now the 'active' flag)
    if (options.process !== true) {
      console.log(`[${this.sourceName}] Skipping decompression (raw mode default)`);
      return compressedData;
    }

    const dataView = new Uint8Array(compressedData);

    // Check for gzip magic bytes (0x1f 0x8b)
    const isGzipped = dataView.length >= 2 &amp;&amp; dataView[0] === 0x1f &amp;&amp; dataView[1] === 0x8b;

    if (!isGzipped &amp;&amp; !format) {
      // Already decompressed
      return dataView;
    }

    console.log(`[${this.sourceName}] Decompressing data (${(compressedData.byteLength / 1024 / 1024).toFixed(1)} MB)...`);

    // Try Pako first (for gzip)
    if (isGzipped) {
      let pakoLib = (typeof window !== 'undefined' &amp;&amp; window.pako);

      // Try loading from geospatial library if not available
      if (!pakoLib) {
        // Only try to load if in browser environment
        if (typeof document !== 'undefined') {
          const geospatialLib = await loadGridDataLibrary('geospatial');
          pakoLib = geospatialLib?.pako;
        }
        // Fallback to global pako if still not found
        pakoLib = pakoLib || globalThis.pako || (typeof window !== 'undefined' &amp;&amp; window.pako);
      }

      if (pakoLib &amp;&amp; typeof pakoLib.ungzip === 'function') {
        try {
          const decompressed = pakoLib.ungzip(dataView);
          console.log(`[${this.sourceName}] Decompressed with Pako: ${(decompressed.length / 1024 / 1024).toFixed(1)} MB`);
          return decompressed;
        } catch (pakoError) {
          console.warn(`[${this.sourceName}] Pako decompression failed:`, pakoError.message);
        }
      }

      // Fallback to browser DecompressionStream
      if (typeof DecompressionStream !== 'undefined') {
        try {
          const response = new Response(compressedData);
          const decompressedStream = response.body.pipeThrough(new DecompressionStream('gzip'));
          const decompressedResponse = await new Response(decompressedStream).arrayBuffer();
          console.log(`[${this.sourceName}] Decompressed with browser API: ${(decompressedResponse.byteLength / 1024 / 1024).toFixed(1)} MB`);
          return new Uint8Array(decompressedResponse);
        } catch (browserError) {
          console.warn(`[${this.sourceName}] Browser decompression failed:`, browserError.message);
        }
      }
    }

    // Try format-specific decompression (blosc, zstd, etc.)
    if (this.library) {
      // Try fzstd for zstd-compressed data
      const fzstd = this.library.fzstd || globalThis.fzstd;
      if (fzstd &amp;&amp; typeof fzstd.decompress === 'function') {
        try {
          const decompressed = fzstd.decompress(dataView);
          console.log(`[${this.sourceName}] Decompressed with fzstd`);
          return decompressed;
        } catch (fzstdError) {
          console.warn(`[${this.sourceName}] fzstd decompression failed:`, fzstdError.message);
        }
      }

      // Try blosc decompression
      if (typeof globalThis.decompress === 'function') {
        try {
          const decompressed = globalThis.decompress(dataView);
          console.log(`[${this.sourceName}] Decompressed with blosc`);
          return decompressed;
        } catch (bloscError) {
          console.warn(`[${this.sourceName}] blosc decompression failed:`, bloscError.message);
        }
      }
    }

    throw new Error(`${this.sourceName.toUpperCase()} decompression failed: No compatible decompression method available`);
  }

  /**
   * Load required library for this data source
   */
  async loadLibrary() {
    if (!this.library) {
      this.library = await loadGridDataLibrary(this.libraryType);
    }

    // Fallback: if library failed to load (e.g. in worker), check global scope
    if (!this.library) {
      if (this.libraryType === 'geospatial') {
        this.library = {};
        if (typeof globalThis.GeoTIFF !== 'undefined') this.library.GeoTIFF = globalThis.GeoTIFF;
        if (typeof globalThis.Tiff !== 'undefined') this.library.Tiff = globalThis.Tiff;
        if (typeof globalThis.JSZip !== 'undefined') this.library.JSZip = globalThis.JSZip;
      } else if (this.libraryType === 'netcdf') {
        this.library = {};
        if (typeof globalThis.netcdfjs !== 'undefined') this.library.NetCDFReader = globalThis.netcdfjs;
        // Some might be exposed differently
      } else if (this.libraryType === 'grib2') {
        // handle grib2 globals if they exist
      }
    }

    // Final check - only throw if we absolutely cannot proceed and need the library for parsing
    // We defer the check to the actual usage methods (parseGeoTIFF, etc.)
    return this.library;
  }

  /**
   * Find nearest grid index - universal implementation
   * Used by AORC, NLDAS, and others with different coordinate systems
   */
  findNearestIndex(coordSystem, targetValue) {
    if (coordSystem.resolution) {
      // Resolution-based (AORC style)
      const { min, max, resolution } = coordSystem;
      const index = Math.round((targetValue - min) / resolution);
      return Math.max(0, Math.min(index, Math.floor((max - min) / resolution)));
    } else if (Array.isArray(coordSystem)) {
      // Array-based (find closest value in array)
      return coordSystem.reduce((closestIdx, value, idx) =>
        Math.abs(value - targetValue) &lt; Math.abs(coordSystem[closestIdx] - targetValue) ? idx : closestIdx,
        0
      );
    } else {
      throw new Error('Invalid coordinate system format');
    }
  }

  /**
   * Generic time series extraction
   * Eliminates duplicate time series loops from all utils files (~1000 lines total)
   */
  async extractTimeSeries(variable, latitude, longitude, startTime, endTime, options = {}) {
    console.log(`[${this.sourceName}] Extracting ${variable} time series at (${latitude}, ${longitude})`);

    const timeSeries = [];
    let currentTime = new Date(startTime);

    // Determine time increment (source-specific, passed in options)
    const timeIncrement = options.timeIncrement || (60 * 60 * 1000); // Default 1 hour

    while (currentTime &lt;= endTime) {
      try {
        // Call source-specific point data extraction
        const pointData = await this.extractPointData(variable, latitude, longitude, currentTime, options);

        timeSeries.push({
          timestamp: currentTime.toISOString(),
          value: pointData.value,
          ...options.includeMetadata &amp;&amp; { metadata: pointData.metadata }
        });

      } catch (timeError) {
        console.warn(`[${this.sourceName}] Failed to get data for ${currentTime.toISOString()}: ${timeError.message}`);
        timeSeries.push({
          timestamp: currentTime.toISOString(),
          value: null,
          error: timeError.message
        });
      }

      // Move to next time step
      if (typeof timeIncrement === 'function') {
        currentTime = timeIncrement(currentTime);
      } else {
        currentTime = new Date(currentTime.getTime() + timeIncrement);
      }
    }

    return {
      variable: variable,
      location: { latitude, longitude },
      timeRange: {
        start: startTime.toISOString(),
        end: endTime.toISOString()
      },
      data: timeSeries,
      metadata: {
        source: this.sourceName.toUpperCase(),
        temporalResolution: options.temporalResolution || 'variable',
        count: timeSeries.length,
        validCount: timeSeries.filter(d => d.value !== null).length
      }
    };
  }

  /**
   * Convert to CSV format - universal implementation
   * Eliminates duplicate CSV converters from aorc, nwm, data-transformers (~300 lines)
   */
  toCSV(data, options = {}) {
    const includeLocation = options.includeLocation !== false;
    const includeMetadata = options.includeMetadata !== false;

    // Build header
    let header = 'timestamp,value,variable';
    if (includeMetadata) header += ',units';
    if (includeLocation) header += ',latitude,longitude';
    header += '\n';

    let csv = header;

    // Handle different data structures
    const dataArray = Array.isArray(data.data) ? data.data : [data];

    dataArray.forEach(item => {
      const timestamp = item.timestamp || data.timestamp || '';
      const value = item.value !== null &amp;&amp; item.value !== undefined ? Number(item.value).toFixed(6) : '';
      const variable = data.variable || item.variable || '';

      let row = `${timestamp},${value},${variable}`;

      if (includeMetadata) {
        const units = data.metadata?.units || item.metadata?.units || '';
        row += `,${units}`;
      }

      if (includeLocation) {
        const lat = data.location?.latitude || item.location?.latitude || '';
        const lon = data.location?.longitude || item.location?.longitude || '';
        row += `,${lat},${lon}`;
      }

      csv += row + '\n';
    });

    return csv;
  }

  /**
   * Convert to NetCDF-compatible structure
   * Eliminates duplicate NetCDF converters (~200 lines)
   */
  toNetCDF(data, options = {}) {
    const variableName = data.variable;
    const variableMeta = this.variables?.[variableName] || {};

    return {
      type: 'netcdf',
      dimensions: {
        time: data.data?.length || 0,
        latitude: data.location ? 1 : (data.data?.coordinates?.latitude?.length || 0),
        longitude: data.location ? 1 : (data.data?.coordinates?.longitude?.length || 0)
      },
      variables: {
        [variableName]: {
          dimensions: ['time', 'latitude', 'longitude'],
          data: data.data,
          attributes: {
            units: variableMeta.units || data.metadata?.units || '',
            long_name: variableMeta.longName || variableMeta.description || variableName,
            scale_factor: variableMeta.scaleFactor || 1.0,
            add_offset: variableMeta.addOffset || 0.0,
            source: this.sourceName.toUpperCase()
          }
        }
      },
      globalAttributes: {
        title: `${this.sourceName.toUpperCase()} ${variableName} data`,
        institution: options.institution || 'HydroLang',
        source: `${this.sourceName.toUpperCase()} Dataset`,
        history: `Generated on ${new Date().toISOString()}`,
        dataSource: this.sourceName
      }
    };
  }

  /**
   * Validation methods - universal implementations
   */
  validateCoordinates(latitude, longitude, spatialBounds = null) {
    const bounds = spatialBounds || this.datasourceConfig?.spatial;

    if (!bounds) return true; // No bounds to validate against

    const latMin = bounds.latitude?.min || -90;
    const latMax = bounds.latitude?.max || 90;
    const lonMin = bounds.longitude?.min || -180;
    const lonMax = bounds.longitude?.max || 180;

    if (latitude &lt; latMin || latitude > latMax) {
      throw new Error(`Latitude ${latitude} is outside ${this.sourceName.toUpperCase()} domain [${latMin}, ${latMax}]`);
    }

    if (longitude &lt; lonMin || longitude > lonMax) {
      throw new Error(`Longitude ${longitude} is outside ${this.sourceName.toUpperCase()} domain [${lonMin}, ${lonMax}]`);
    }

    return true;
  }

  validateBbox(bbox, spatialBounds = null) {
    const [west, south, east, north] = bbox;

    if (west >= east) {
      throw new Error('Invalid bbox: west must be less than east');
    }
    if (south >= north) {
      throw new Error('Invalid bbox: south must be less than north');
    }

    const bounds = spatialBounds || this.datasourceConfig?.spatial;

    if (bounds) {
      const latMin = bounds.latitude?.min || -90;
      const latMax = bounds.latitude?.max || 90;
      const lonMin = bounds.longitude?.min || -180;
      const lonMax = bounds.longitude?.max || 180;

      if (west &lt; lonMin || east > lonMax || south &lt; latMin || north > latMax) {
        console.warn(`[${this.sourceName}] Requested bbox partially outside domain, clipping may occur`);
      }
    }

    return true;
  }

  validateDateRange(startDate, endDate, temporalBounds = null) {
    const start = new Date(startDate);
    const end = new Date(endDate);

    if (isNaN(start.getTime()) || isNaN(end.getTime())) {
      throw new Error('Invalid date format');
    }

    if (start > end) {
      throw new Error('Start date must be before end date');
    }

    const bounds = temporalBounds || this.datasourceConfig?.temporal;

    if (bounds) {
      const datasetStart = new Date(bounds.start);
      const datasetEnd = new Date(bounds.end);

      if (start &lt; datasetStart || end > datasetEnd) {
        throw new Error(
          `Requested date range (${startDate} to ${endDate}) is outside ${this.sourceName.toUpperCase()} ` +
          `dataset range (${bounds.start} to ${bounds.end})`
        );
      }
    }

    return true;
  }

  /**
   * Standardized error handling
   */
  handleError(error, context = {}) {
    const errorMessage = error.message || 'Unknown error';
    const contextStr = context.context ? `[${context.context}]` : '';

    console.error(`[${this.sourceName}] ${contextStr} Error:`, errorMessage);

    // Return a standardized error
    return new Error(
      `${this.sourceName.toUpperCase()} ${context.context || 'operation'} failed: ${errorMessage}`
    );
  }

  /**
   * Generic bulk extraction for multiple points
   * Eliminates duplicate multipoint extraction from nldas, aorc, etc.
   */
  async extractMultiplePoints(variable, points, timestamp, options = {}) {
    console.log(`[${this.sourceName}] Extracting ${variable} for ${points.length} points`);

    const results = [];

    for (const point of points) {
      const { latitude, longitude, id } = point;

      try {
        const pointData = await this.extractPointData(variable, latitude, longitude, timestamp, options);

        results.push({
          id: id || `${latitude},${longitude}`,
          latitude,
          longitude,
          value: pointData.value,
          timestamp: timestamp.toISOString(),
          ...options.includeMetadata &amp;&amp; { metadata: pointData.metadata }
        });

      } catch (pointError) {
        console.warn(`[${this.sourceName}] Failed to extract point ${latitude}, ${longitude}:`, pointError.message);
        results.push({
          id: id || `${latitude},${longitude}`,
          latitude,
          longitude,
          value: null,
          timestamp: timestamp.toISOString(),
          error: pointError.message
        });
      }
    }

    return {
      variable,
      timestamp: timestamp.toISOString(),
      points: results,
      metadata: {
        source: this.sourceName.toUpperCase(),
        count: results.length,
        validCount: results.filter(r => r.value !== null).length
      }
    };
  }

  /**
   * Generic grid aggregation over time
   * Used by bulk extraction in AORC, MRMS, HRRR, etc.
   */
  async extractGridTimeSeries(variable, bbox, startTime, endTime, options = {}) {
    console.log(`[${this.sourceName}] Extracting ${variable} grid time series`);

    const gridData = [];
    let currentTime = new Date(startTime);
    const timeIncrement = options.timeIncrement || (60 * 60 * 1000); // Default 1 hour

    while (currentTime &lt;= endTime) {
      try {
        const grid = await this.extractGridData(variable, bbox, currentTime, options);
        gridData.push({
          timestamp: currentTime.toISOString(),
          grid: grid
        });

      } catch (timeError) {
        console.warn(`[${this.sourceName}] Failed to get grid for ${currentTime.toISOString()}:`, timeError.message);
        gridData.push({
          timestamp: currentTime.toISOString(),
          grid: null,
          error: timeError.message
        });
      }

      // Move to next time step
      if (typeof timeIncrement === 'function') {
        currentTime = timeIncrement(currentTime);
      } else {
        currentTime = new Date(currentTime.getTime() + timeIncrement);
      }
    }

    return {
      variable,
      bbox,
      timeRange: {
        start: startTime.toISOString(),
        end: endTime.toISOString()
      },
      data: gridData,
      metadata: {
        source: this.sourceName.toUpperCase(),
        count: gridData.length,
        validCount: gridData.filter(d => d.grid !== null).length
      }
    };
  }

  /**
   * Apply temporal aggregation (used in bulk operations)
   * Consolidates aggregateTime from gridded-data-utils and various source utils
   */
  aggregateTemporally(data, aggregationType = 'mean') {
    if (!data || data.length === 0) return null;

    const validValues = data.filter(v => v !== null &amp;&amp; v !== undefined &amp;&amp; !isNaN(v));

    if (validValues.length === 0) return null;

    switch (aggregationType.toLowerCase()) {
      case 'mean':
      case 'average':
        return validValues.reduce((sum, v) => sum + v, 0) / validValues.length;

      case 'sum':
      case 'total':
        return validValues.reduce((sum, v) => sum + v, 0);

      case 'min':
      case 'minimum':
        return Math.min(...validValues);

      case 'max':
      case 'maximum':
        return Math.max(...validValues);

      case 'median':
        const sorted = [...validValues].sort((a, b) => a - b);
        const mid = Math.floor(sorted.length / 2);
        return sorted.length % 2 === 0
          ? (sorted[mid - 1] + sorted[mid]) / 2
          : sorted[mid];

      default:
        console.warn(`Unknown aggregation type: ${aggregationType}, using mean`);
        return validValues.reduce((sum, v) => sum + v, 0) / validValues.length;
    }
  }

  /**
   * Apply spatial aggregation (used in grid operations)
   */
  aggregateSpatially(gridValues, aggregationType = 'mean') {
    // Flatten grid if it's 2D array
    const flatValues = Array.isArray(gridValues[0])
      ? gridValues.flat()
      : gridValues;

    return this.aggregateTemporally(flatValues, aggregationType);
  }

  /**
   * Format timestamp for URL construction (source-specific format passed as option)
   */
  formatTimestamp(date, format = 'iso') {
    const d = new Date(date);

    switch (format) {
      case 'iso':
        return d.toISOString();

      case 'yyyymmdd':
        const year = d.getUTCFullYear();
        const month = String(d.getUTCMonth() + 1).padStart(2, '0');
        const day = String(d.getUTCDate()).padStart(2, '0');
        return `${year}${month}${day}`;

      case 'yyyymmddhh':
        const hh = String(d.getUTCHours()).padStart(2, '0');
        return `${this.formatTimestamp(d, 'yyyymmdd')}${hh}`;

      case 'yyyy-mm-dd':
        const yr = d.getUTCFullYear();
        const mo = String(d.getUTCMonth() + 1).padStart(2, '0');
        const dy = String(d.getUTCDate()).padStart(2, '0');
        return `${yr}-${mo}-${dy}`;

      case 'yyyy/mm/dd':
        return this.formatTimestamp(d, 'yyyy-mm-dd').replace(/-/g, '/');

      default:
        // Custom format function passed
        if (typeof format === 'function') {
          return format(d);
        }
        return d.toISOString();
    }
  }

  /**
   * Build URL from template and parameters
   * Reduces repetitive URL construction in all source utils
   */
  buildURL(template, params = {}) {
    let url = template;

    // Replace template variables like {variable}, {date}, etc.
    for (const [key, value] of Object.entries(params)) {
      const placeholder = `{${key}}`;
      if (url.includes(placeholder)) {
        url = url.replace(new RegExp(placeholder, 'g'), value);
      }
    }

    return url;
  }

  /**
   * Abstract methods - to be implemented by specific sources
   * (or use default implementations provided above)
   */
  async extractPointData(variable, latitude, longitude, timestamp, options = {}) {
    throw new Error(`extractPointData not implemented for ${this.sourceName}`);
  }

  async extractGridData(variable, bbox, timestamp, options = {}) {
    throw new Error(`extractGridData not implemented for ${this.sourceName}`);
  }
}

/**
 * Zarr-specific data source base class
 * Used by: AORC, NWM (Zarr format)
 * Consolidates Zarr array extraction patterns (~500 lines)
 */
export class ZarrDataSource extends GriddedDataSource {
  constructor(config) {
    super({ ...config, libraryType: 'zarr' });
  }

  /**
   * Extract value from Zarr array at specific indices
   */
  async getZarrValue(zarrArray, indices, variableMeta) {
    const rawValue = await zarrArray.get(indices);
    return this.applyScaling(rawValue, variableMeta);
  }

  /**
   * Extract slice from Zarr array
   */
  async getZarrSlice(zarrArray, sliceParams, variableMeta) {
    const slice = await zarrArray.get(sliceParams);

    // Apply scaling to all values
    if (Array.isArray(slice)) {
      return slice.map(row =>
        Array.isArray(row)
          ? row.map(val => this.applyScaling(val, variableMeta))
          : this.applyScaling(row, variableMeta)
      );
    }

    return this.applyScaling(slice, variableMeta);
  }

  /**
   * Open Zarr array from URL using zarrita
   */
  async openZarrArray(url, options = {}) {
    await this.loadLibrary();

    if (!this.library || !this.library.zarr) {
      throw new Error('Zarrita library not available');
    }

    try {
      const store = new this.library.zarr.FetchStore(url);
      const zarrArray = await this.library.zarr.open(store, { kind: 'array', ...options });
      return zarrArray;
    } catch (error) {
      throw new Error(`Failed to open Zarr array at ${url}: ${error.message}`);
    }
  }

  /**
   * Get full array data
   */
  async getZarrArrayData(zarrArray) {
    await this.loadLibrary();

    if (!this.library || !this.library.zarr) {
      throw new Error('Zarrita library not available');
    }

    return await this.library.zarr.get(zarrArray);
  }

  /**
   * Get array chunk
   */
  async getZarrChunk(zarrArray, indices) {
    return await zarrArray.getChunk(indices);
  }

  /**
   * Get array region
   */
  async getZarrRegion(zarrArray, region) {
    await this.loadLibrary();

    if (!this.library || !this.library.zarr) {
      throw new Error('Zarrita library not available');
    }

    return await this.library.zarr.get(zarrArray, region);
  }
}

/**
 * GRIB2-specific data source base class
 * Used by: MRMS, HRRR, ECMWF
 * Consolidates GRIB2 parsing patterns (~800 lines)
 */
export class GRIB2DataSource extends GriddedDataSource {
  constructor(config) {
    super({ ...config, libraryType: 'grib2' });
  }

  /**
   * Parse GRIB2 file from buffer
   */
  async parseGRIB2(buffer, options = {}) {
    await this.loadLibrary();

    const grib2Parser = this.library?.parseGRIB2 || this.library?.GRIB2Parser || globalThis.GRIB2Parser;

    if (!grib2Parser) {
      throw new Error('GRIB2 parser not available');
    }

    console.log(`[${this.sourceName}] Parsing GRIB2 data...`);

    // Ensure we pass an ArrayBuffer, not a Uint8Array
    let dataToParse = buffer;
    if (buffer instanceof Uint8Array || (typeof Buffer !== 'undefined' &amp;&amp; buffer instanceof Buffer)) {
      if (buffer.byteOffset === 0 &amp;&amp; buffer.byteLength === buffer.buffer.byteLength) {
        dataToParse = buffer.buffer;
      } else {
        // Create a copy if it's a view or offset
        dataToParse = buffer.slice(0).buffer;
        // Note: slice(0) on TypedArray returns a new TypedArray, .buffer gets its ArrayBuffer
        // If it was already a fresh Uint8Array from pako, .buffer is fine, but safety first.
        // Actually, pako.ungzip returns a Uint8Array. If it's the whole buffer, .buffer is enough.
        // But let's be safe.
        if (dataToParse instanceof Uint8Array) {
          dataToParse = dataToParse.buffer;
        }
      }
    }

    // Double check it is an ArrayBuffer
    if (dataToParse &amp;&amp; dataToParse.buffer instanceof ArrayBuffer &amp;&amp; !(dataToParse instanceof ArrayBuffer)) {
      dataToParse = dataToParse.buffer;
    }

    // Pass pako library for PNG decompression
    const pakoLib = (typeof window !== 'undefined' &amp;&amp; window.pako) || globalThis.pako;
    let messages = await grib2Parser(dataToParse, { pako: pakoLib });

    // Handle case where parser returns an object with messages property
    if (messages &amp;&amp; !Array.isArray(messages) &amp;&amp; messages.messages &amp;&amp; Array.isArray(messages.messages)) {
      messages = messages.messages;
    }

    console.log(`[${this.sourceName}] Found ${messages?.length} GRIB2 messages`);

    if (!messages || !Array.isArray(messages)) {
      throw new Error('GRIB2 parser returned invalid data format (expected array of messages)');
    }

    return messages;
  }

  /**
   * Find specific message in GRIB2 file by variable
   */
  findGRIB2Message(messages, variable, options = {}) {
    const variableMeta = this.variables?.[variable] || {};
    const gribName = variableMeta.gribName || variableMeta.name || variable;

    for (const message of messages) {
      // Handle GRIB2 object structure (message.data) or flat object
      const msgData = message.data || message;
      const messageVar = msgData.discipline || msgData.parameterName || msgData.shortName;

      console.log(`[findGRIB2Message] Checking message: shortName=${msgData.shortName}, parameterName=${msgData.parameterName}, gribName=${gribName}`);

      if (messageVar === gribName ||
        msgData.parameterName === gribName ||
        msgData.shortName === gribName) {
        return message;
      }
    }

    // If no exact match, try partial matching
    for (const message of messages) {
      const messageVarStr = JSON.stringify(message).toLowerCase();
      if (messageVarStr.includes(gribName.toLowerCase())) {
        console.warn(`[${this.sourceName}] Using partial match for ${gribName}`);
        return message;
      }
    }

    throw new Error(`Variable ${variable} (${gribName}) not found in GRIB2 file`);
  }

  /**
   * Extract value from GRIB2 grid at lat/lon
   */
  getGRIB2ValueAtPoint(message, latitude, longitude) {
    const msgData = message.data || message;
    const gridData = msgData.values || msgData.data; // handle both naming conventions

    // Debug optimization logic
    if (msgData.grid) {
      console.log(`[getGRIB2ValueAtPoint] Grid info: template=${msgData.grid.template}, latStart=${msgData.grid.latStart}, latEnd=${msgData.grid.latEnd}, incI=${msgData.grid.incI}, incJ=${msgData.grid.incJ}`);
      console.log(`[getGRIB2ValueAtPoint] Latitudes array present: ${!!(msgData.grid.latitudes &amp;&amp; msgData.grid.latitudes.length)}`);
    } else {
      console.log(`[getGRIB2ValueAtPoint] msgData.grid is undefined`);
    }

    // Optimization for regular grids (Template 3.0)
    if (msgData.grid &amp;&amp; msgData.grid.template === 0 &amp;&amp; msgData.grid.latStart !== undefined) {
      const grid = msgData.grid;
      const lat = latitude;
      let lon = longitude;
      if (lon &lt; 0) lon += 360; // Normalize to 0-360 for GRIB2 if needed

      // Calculate indices
      // Lat: usually decreases from latStart
      let latIdx;
      if (grid.latStart > grid.latEnd) {
        latIdx = Math.round((grid.latStart - lat) / grid.incJ);
      } else {
        latIdx = Math.round((lat - grid.latStart) / grid.incJ);
      }

      // Lon: usually increases from lonStart
      let lonIdx = Math.round((lon - grid.lonStart) / grid.incI);

      console.log(`[getGRIB2ValueAtPoint] Calculated indices: latIdx=${latIdx}, lonIdx=${lonIdx} for lat=${lat}, lon=${lon}`);

      // Check bounds
      if (latIdx >= 0 &amp;&amp; latIdx &lt; grid.numLatPoints &amp;&amp;
        lonIdx >= 0 &amp;&amp; lonIdx &lt; grid.numLongPoints) {

        // Calculate linear index
        // GRIB2 usually scans row by row (check scanning mode if needed)
        const idx = (latIdx * grid.numLongPoints) + lonIdx;

        console.log(`[getGRIB2ValueAtPoint] Linear index: ${idx}, Grid data length: ${gridData ? gridData.length : 'undefined'}`);

        if (idx >= 0 &amp;&amp; idx &lt; gridData.length) {
          return gridData[idx];
        }
      } else {
        console.warn(`[getGRIB2ValueAtPoint] Indices out of bounds: latIdx=${latIdx}/${grid.numLatPoints}, lonIdx=${lonIdx}/${grid.numLongPoints}`);
      }
      // If out of bounds, return null or throw?
      // Fallback to array search if indices fail (unlikely for regular grid)
    } else {
      console.log(`[getGRIB2ValueAtPoint] Optimization skipped. Conditions: grid=${!!msgData.grid}, template=${msgData.grid?.template}, latStart=${msgData.grid?.latStart !== undefined}`);
    }

    const latitudes = msgData.latitudes || msgData.grid?.latitudes;
    const longitudes = msgData.longitudes || msgData.grid?.longitudes;

    if (!gridData || !latitudes || !longitudes) {
      throw new Error('GRIB2 message missing required grid data (latitudes/longitudes arrays)');
    }

    // Find nearest point (Brute Force - Fallback)
    let minDist = Infinity;
    let nearestIdx = 0;

    for (let i = 0; i &lt; latitudes.length; i++) {
      const dist = Math.sqrt(
        Math.pow(latitudes[i] - latitude, 2) +
        Math.pow(longitudes[i] - longitude, 2)
      );

      if (dist &lt; minDist) {
        minDist = dist;
        nearestIdx = i;
      }
    }

    return gridData[nearestIdx];
  }

  /**
   * Extract grid from GRIB2 within bbox
   */
  getGRIB2Grid(message, bbox) {
    const [west, south, east, north] = bbox;
    const gridData = message.data || message.values;
    const latitudes = message.latitudes || message.grid?.latitudes;
    const longitudes = message.longitudes || message.grid?.longitudes;

    if (!gridData || !latitudes || !longitudes) {
      throw new Error('GRIB2 message missing required grid data');
    }

    const extractedPoints = [];
    const extractedLats = [];
    const extractedLons = [];

    for (let i = 0; i &lt; latitudes.length; i++) {
      const lat = latitudes[i];
      const lon = longitudes[i];

      if (lat >= south &amp;&amp; lat &lt;= north &amp;&amp; lon >= west &amp;&amp; lon &lt;= east) {
        extractedPoints.push(gridData[i]);
        extractedLats.push(lat);
        extractedLons.push(lon);
      }
    }

    return {
      data: extractedPoints,
      latitudes: extractedLats,
      longitudes: extractedLons,
      count: extractedPoints.length
    };
  }
}

/**
 * NetCDF-specific data source base class
 * Used by: NLDAS, NWM (NetCDF format), others
 * Consolidates NetCDF reading patterns (~400 lines)
 */
export class NetCDFDataSource extends GriddedDataSource {
  constructor(config) {
    super({ ...config, libraryType: 'netcdf' });
  }

  /**
   * Open and parse NetCDF file
   */
  async openNetCDF(source, options = {}) {
    await this.loadLibrary();

    let buffer;

    if (typeof source === 'string') {
      // URL - fetch first
      buffer = await this.fetch(source, options);
    } else {
      buffer = source;
    }

    console.log(`[${this.sourceName}] Parsing NetCDF data...`);

    const NetCDFReader = this.library?.NetCDFReader || this.library || globalThis.netcdfjs || globalThis.NetCDFReader;

    if (!NetCDFReader) {
      throw new Error('NetCDF parser not available');
    }

    const ncFile = new NetCDFReader(buffer);

    console.log(`[${this.sourceName}] NetCDF variables: ${ncFile.variables?.map(v => v.name).join(', ')}`);

    return ncFile;
  }

  /**
   * Get variable data from NetCDF
   */
  getNetCDFVariable(ncFile, variableName) {
    const variable = ncFile.getDataVariable(variableName);

    if (!variable) {
      const availableVars = ncFile.variables?.map(v => v.name).join(', ') || 'none';
      throw new Error(`Variable ${variableName} not found. Available: ${availableVars}`);
    }

    return variable;
  }

  /**
   * Extract value from NetCDF at specific indices
   */
  getNetCDFValue(ncFile, variableName, indices, variableMeta) {
    const data = ncFile.getDataVariable(variableName);

    if (!data) {
      throw new Error(`Variable ${variableName} not found in NetCDF`);
    }

    // Get value at indices (format depends on netcdf library)
    let value;
    if (typeof data.get === 'function') {
      value = data.get(indices);
    } else if (Array.isArray(data)) {
      // Navigate nested array structure
      value = indices.reduce((arr, idx) => arr[idx], data);
    } else {
      throw new Error('Unsupported NetCDF data structure');
    }

    return this.applyScaling(value, variableMeta);
  }

  /**
   * Extract slice from NetCDF
   */
  getNetCDFSlice(ncFile, variableName, sliceParams, variableMeta) {
    const variable = this.getNetCDFVariable(ncFile, variableName);

    // Extract slice (implementation depends on library)
    const slice = variable.readSlice(sliceParams);

    // Apply scaling
    return slice.map(row =>
      Array.isArray(row)
        ? row.map(val => this.applyScaling(val, variableMeta))
        : this.applyScaling(row, variableMeta)
    );
  }
}

/**
 * GeoTIFF-specific data source base class
 * Used by: PRISM, 3DEP
 * Consolidates GeoTIFF reading patterns (~600 lines)
 */
export class GeoTIFFDataSource extends GriddedDataSource {
  constructor(config) {
    super({ ...config, libraryType: 'geospatial' });
  }

  /**
   * Parse GeoTIFF from buffer
   */
  async parseGeoTIFF(buffer, options = {}) {
    await this.loadLibrary();

    const GeoTIFF = this.library?.GeoTIFF || globalThis.GeoTIFF;

    if (!GeoTIFF || !GeoTIFF.fromArrayBuffer) {
      throw new Error('GeoTIFF library not available');
    }

    console.log(`[${this.sourceName}] Parsing GeoTIFF...`);

    const tiff = await GeoTIFF.fromArrayBuffer(buffer);
    const image = await tiff.getImage();

    const width = image.getWidth();
    const height = image.getHeight();
    const bbox = image.getBoundingBox();

    console.log(`[${this.sourceName}] GeoTIFF: ${width}x${height}, bbox:`, bbox);

    return { tiff, image };
  }

  /**
   * Extract value from GeoTIFF at lat/lon
   */
  async getGeoTIFFValueAtPoint(image, latitude, longitude, variableMeta) {
    const bbox = image.getBoundingBox();
    const width = image.getWidth();
    const height = image.getHeight();

    // Convert lat/lon to pixel coordinates
    const pixelX = Math.floor(((longitude - bbox[0]) / (bbox[2] - bbox[0])) * width);
    const pixelY = Math.floor(((bbox[3] - latitude) / (bbox[3] - bbox[1])) * height);

    if (pixelX &lt; 0 || pixelX >= width || pixelY &lt; 0 || pixelY >= height) {
      throw new Error(`Point (${latitude}, ${longitude}) is outside GeoTIFF bounds`);
    }

    // Read window around point
    const window = [pixelX, pixelY, pixelX + 1, pixelY + 1];
    const rasters = await image.readRasters({ window });

    const rawValue = rasters[0][0]; // First band, first pixel

    return this.applyScaling(rawValue, variableMeta);
  }

  /**
   * Extract grid from GeoTIFF within bbox
   */
  async getGeoTIFFGrid(image, bbox, variableMeta) {
    const [west, south, east, north] = bbox;
    const imageBbox = image.getBoundingBox();
    const width = image.getWidth();
    const height = image.getHeight();

    // Convert bbox to pixel window
    const x1 = Math.max(0, Math.floor(((west - imageBbox[0]) / (imageBbox[2] - imageBbox[0])) * width));
    const y1 = Math.max(0, Math.floor(((imageBbox[3] - north) / (imageBbox[3] - imageBbox[1])) * height));
    const x2 = Math.min(width, Math.ceil(((east - imageBbox[0]) / (imageBbox[2] - imageBbox[0])) * width));
    const y2 = Math.min(height, Math.ceil(((imageBbox[3] - south) / (imageBbox[3] - imageBbox[1])) * height));

    const window = [x1, y1, x2, y2];
    const rasters = await image.readRasters({ window });

    // Apply scaling to all values
    const scaledData = Array.from(rasters[0]).map(val => this.applyScaling(val, variableMeta));

    return {
      data: scaledData,
      width: x2 - x1,
      height: y2 - y1,
      bbox: bbox
    };
  }

  /**
   * Handle ZIP extraction for PRISM and similar sources
   */
  async extractFromZip(zipBuffer, filePattern = null) {
    const JSZip = this.library?.JSZip || globalThis.JSZip;

    if (!JSZip) {
      throw new Error('JSZip library not available');
    }

    console.log(`[${this.sourceName}] Extracting ZIP file...`);

    const zip = await JSZip.loadAsync(zipBuffer);
    const files = Object.keys(zip.files);

    console.log(`[${this.sourceName}] ZIP contains ${files.length} files`);

    // Find matching file
    let targetFile = null;

    if (filePattern) {
      const pattern = typeof filePattern === 'string'
        ? new RegExp(filePattern)
        : filePattern;

      targetFile = files.find(f => pattern.test(f));
    } else {
      // Default: find first .tif or .bil file
      targetFile = files.find(f => f.endsWith('.tif') || f.endsWith('.bil'));
    }

    if (!targetFile) {
      throw new Error(`No matching file found in ZIP. Files: ${files.join(', ')}`);
    }

    console.log(`[${this.sourceName}] Extracting: ${targetFile}`);

    const fileData = await zip.files[targetFile].async('arraybuffer');

    return {
      fileName: targetFile,
      data: fileData,
      allFiles: files
    };
  }
}

/**
 * Load gridded data libraries dynamically
 * @private
 */
export async function loadGridDataLibrary(format) {
  try {
    // Check environment
    const isWorker = typeof document === 'undefined';

    // Prepare options to disable dynamic loading in workers
    const options = isWorker ? {
      includeJS: false,
      includeGeo: false,
      includeProj4: false,
      includeGeoTIFF: false,
      includeTurf: false,
      includeGeolib: false
    } : {};

    // Use centralized loader from external/gridded-data
    const { loadLibrary } = await import('../../../external/gridded-data/gridded-data.js');
    return await loadLibrary({ params: { format, options } }); // Pass options correctly
  } catch (error) {
    throw new Error(`Failed to load ${format} library: ${error.message}`);
  }
}


/**
 * Check if a gridded data library is loaded
 */
/**
 * Check if a gridded data library is loaded
 * @private
 */
export function isGridDataLibraryLoaded(format) {
  // We can't easily check synchronously without importing the module
  // But since we are moving to centralized loader, we should rely on it.
  // However, we can't import it synchronously here if we want to keep this function synchronous
  // and avoid top-level side effects if possible.

  // BUT, we can try to import it dynamically if we accept it returning a promise?
  // Or we can just return false if we haven't loaded the module yet?

  // Actually, the best approach is to import the centralized loader at the top level
  // because the sub-loaders are lazy anyway.
  // Let's assume we will add the import at the top.

  return griddedData.isLoaded({ params: { format } });
}

/**
 * Get loaded library instance
 * @private
 */
export function getGridDataLibrary(format) {
  switch (format) {
    case 'zarr':
      return zarrLoadedLibraries;
    case 'netcdf':
      return netcdfLibrary;
    case 'hdf5':
      return hdf5Library;
    case 'geospatial':
      return geospatialLibrary;
    case 'grib2':
      return grib2Library;
    default:
      return null;
  }
}

/**
 * Aggregate time periods
 * @private
 */
export function aggregateTime(date, timeStep, direction) {
  const dateObj = new Date(date);
  const hours = timeStep === '1D' ? 24 : parseInt(timeStep) || 1;

  if (direction === 'start') {
    const startOfPeriod = new Date(dateObj);
    startOfPeriod.setHours(Math.floor(dateObj.getHours() / hours) * hours, 0, 0, 0);
    return startOfPeriod.toISOString();
  } else {
    const endOfPeriod = new Date(dateObj);
    endOfPeriod.setHours(Math.ceil((dateObj.getHours() + 1) / hours) * hours, 0, 0, 0);
    return endOfPeriod.toISOString();
  }
}

/**
 * Expand spatial bounding box by step factor
 * @private
 */
export function expandSpatialBounds(bbox, spatialStep) {
  const [west, south, east, north] = bbox;
  const expansionFactor = spatialStep / 10;
  return [
    Math.max(-180, west - expansionFactor),
    Math.max(-90, south - expansionFactor),
    Math.min(180, east + expansionFactor),
    Math.min(90, north + expansionFactor)
  ];
}

/**
 * Validate coordinate bounds
 * @private
 */
export function isValidCoordinate(latitude, longitude, spatialBounds) {
  return latitude >= spatialBounds.latitude.min &amp;&amp;
    latitude &lt;= spatialBounds.latitude.max &amp;&amp;
    longitude >= spatialBounds.longitude.min &amp;&amp;
    longitude &lt;= spatialBounds.longitude.max;
}

/**
 * Validate bounding box
 * @private
 */
export function isValidBoundingBox(bbox, spatialBounds) {
  const [west, south, east, north] = bbox;
  return west >= spatialBounds.longitude.min &amp;&amp;
    east &lt;= spatialBounds.longitude.max &amp;&amp;
    south >= spatialBounds.latitude.min &amp;&amp;
    north &lt;= spatialBounds.latitude.max;
}
</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.7</a> on Mon Jan 12 2026 20:44:04 GMT+0000 (Coordinated Universal Time) using the Toast theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
