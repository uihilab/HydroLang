<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>modules/data/data.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="https://code.ionicframework.com/ionicons/2.0.1/css/ionicons.min.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="data.html">data</a><ul class='methods'><li data-type='method'><a href="data.html#.download">download</a></li><li data-type='method'><a href="data.html#.generateDateString">generateDateString</a></li><li data-type='method'><a href="data.html#.lowercasing">lowercasing</a></li><li data-type='method'><a href="data.html#.recursiveSearch">recursiveSearch</a></li><li data-type='method'><a href="data.html#.retrieve">retrieve</a></li><li data-type='method'><a href="data.html#.transform">transform</a></li><li data-type='method'><a href="data.html#.upload">upload</a></li><li data-type='method'><a href="data.html#.xml2json">xml2json</a></li></ul></li><li><a href="divisors.html">divisors</a><ul class='methods'><li data-type='method'><a href="divisors.html#.createDiv">createDiv</a></li><li data-type='method'><a href="divisors.html#.createScript">createScript</a></li><li data-type='method'><a href="divisors.html#.isdivAdded">isdivAdded</a></li><li data-type='method'><a href="divisors.html#.isScriptAdded">isScriptAdded</a></li></ul></li><li><a href="floodDM.html">floodDM</a><ul class='methods'><li data-type='method'><a href="floodDM.html#.buildPropertyDMScenario">buildPropertyDMScenario</a></li><li data-type='method'><a href="floodDM.html#.createTableFromObject">createTableFromObject</a></li><li data-type='method'><a href="floodDM.html#.getBridgeDamage">getBridgeDamage</a></li><li data-type='method'><a href="floodDM.html#.getCityFloodDamage">getCityFloodDamage</a></li><li data-type='method'><a href="floodDM.html#.getFloodInundation">getFloodInundation</a></li><li data-type='method'><a href="floodDM.html#.getLifeLoss">getLifeLoss</a></li><li data-type='method'><a href="floodDM.html#.getPropertyLoss">getPropertyLoss</a></li><li data-type='method'><a href="floodDM.html#.getUtilityDamage">getUtilityDamage</a></li><li data-type='method'><a href="floodDM.html#.getVehicleDamage">getVehicleDamage</a></li><li data-type='method'><a href="floodDM.html#initDamageScenario">initDamageScenario</a></li><li data-type='method'><a href="floodDM.html#initMitigationScenario">initMitigationScenario</a></li><li data-type='method'><a href="floodDM.html#runMitigationScenario">runMitigationScenario</a></li></ul></li><li><a href="HLclearCreek.html">HLclearCreek</a><ul class='methods'><li data-type='method'><a href="HLclearCreek.html#.additionalData">additionalData</a></li><li data-type='method'><a href="HLclearCreek.html#.dataStep">dataStep</a></li><li data-type='method'><a href="HLclearCreek.html#.get_time_step">get_time_step</a></li><li data-type='method'><a href="HLclearCreek.html#.get_value_at_indices">get_value_at_indices</a></li><li data-type='method'><a href="HLclearCreek.html#.retrieveData">retrieveData</a></li><li data-type='method'><a href="HLclearCreek.html#.retrieveGauge">retrieveGauge</a></li><li data-type='method'><a href="HLclearCreek.html#.spreadGauge">spreadGauge</a></li><li data-type='method'><a href="HLclearCreek.html#.spreadResults">spreadResults</a></li><li data-type='method'><a href="HLclearCreek.html#.update">update</a></li><li data-type='method'><a href="HLclearCreek.html#.update_until">update_until</a></li><li data-type='method'><a href="HLclearCreek.html#rainID">rainID</a></li></ul></li><li><a href="hydro.html">hydro</a><ul class='methods'><li data-type='method'><a href="hydro.html#.analyzeCollectionofEvents">analyzeCollectionofEvents</a></li><li data-type='method'><a href="hydro.html#.analyzeEvent">analyzeEvent</a></li><li data-type='method'><a href="hydro.html#.arithmetic">arithmetic</a></li><li data-type='method'><a href="hydro.html#.bucketmodel">bucketmodel</a></li><li data-type='method'><a href="hydro.html#.calculate_tds">calculate_tds</a></li><li data-type='method'><a href="hydro.html#.calculate_tss">calculate_tss</a></li><li data-type='method'><a href="hydro.html#.calculateDOSaturation">calculateDOSaturation</a></li><li data-type='method'><a href="hydro.html#.calculatepH">calculatepH</a></li><li data-type='method'><a href="hydro.html#.calculatePrecipitationMinMax">calculatePrecipitationMinMax</a></li><li data-type='method'><a href="hydro.html#.calibratePH">calibratePH</a></li><li data-type='method'><a href="hydro.html#.compensateORP">compensateORP</a></li><li data-type='method'><a href="hydro.html#.convertTemperature">convertTemperature</a></li><li data-type='method'><a href="hydro.html#.convertTurbidity">convertTurbidity</a></li><li data-type='method'><a href="hydro.html#.darcysLaw">darcysLaw</a></li><li data-type='method'><a href="hydro.html#.detectPrecipEvents">detectPrecipEvents</a></li><li data-type='method'><a href="hydro.html#.dissolvedOxygenDemand">dissolvedOxygenDemand</a></li><li data-type='method'><a href="hydro.html#.dynamicGround1D">dynamicGround1D</a></li><li data-type='method'><a href="hydro.html#.equationsystemsolver">equationsystemsolver</a></li><li data-type='method'><a href="hydro.html#.ETBlaneyCriddle">ETBlaneyCriddle</a></li><li data-type='method'><a href="hydro.html#.ETHargreaves">ETHargreaves</a></li><li data-type='method'><a href="hydro.html#.ETPenmanMontheith">ETPenmanMontheith</a></li><li data-type='method'><a href="hydro.html#.ETPriestelyTaylor">ETPriestelyTaylor</a></li><li data-type='method'><a href="hydro.html#.ETThornthwaite">ETThornthwaite</a></li><li data-type='method'><a href="hydro.html#.floodhydro">floodhydro</a></li><li data-type='method'><a href="hydro.html#.generateSyntheticValue">generateSyntheticValue</a></li><li data-type='method'><a href="hydro.html#.getJulianDay">getJulianDay</a></li><li data-type='method'><a href="hydro.html#.ground1d">ground1d</a></li><li data-type='method'><a href="hydro.html#.hyetogen">hyetogen</a></li><li data-type='method'><a href="hydro.html#.InfGreenAmpt">InfGreenAmpt</a></li><li data-type='method'><a href="hydro.html#.InfHorton">InfHorton</a></li><li data-type='method'><a href="hydro.html#.InfKostiakov">InfKostiakov</a></li><li data-type='method'><a href="hydro.html#.InfPhilip">InfPhilip</a></li><li data-type='method'><a href="hydro.html#.InfSmithParlange">InfSmithParlange</a></li><li data-type='method'><a href="hydro.html#.inverseDistanceWeighting">inverseDistanceWeighting</a></li><li data-type='method'><a href="hydro.html#.kinematicWaveRouting">kinematicWaveRouting</a></li><li data-type='method'><a href="hydro.html#.lagAndRoute">lagAndRoute</a></li><li data-type='method'><a href="hydro.html#.matrix">matrix</a></li><li data-type='method'><a href="hydro.html#.move">move</a></li><li data-type='method'><a href="hydro.html#.muskingumCunge">muskingumCunge</a></li><li data-type='method'><a href="hydro.html#.precipitationFrequencyAnalysis">precipitationFrequencyAnalysis</a></li><li data-type='method'><a href="hydro.html#.rainaggr">rainaggr</a></li><li data-type='method'><a href="hydro.html#.rainfallErosivityIndex">rainfallErosivityIndex</a></li><li data-type='method'><a href="hydro.html#.rainfallIntensityDurationFrequency">rainfallIntensityDurationFrequency</a></li><li data-type='method'><a href="hydro.html#.rainfallInterceptionModel">rainfallInterceptionModel</a></li><li data-type='method'><a href="hydro.html#.rainfallThresholdAnalysis">rainfallThresholdAnalysis</a></li><li data-type='method'><a href="hydro.html#.stochasticRainfallGeneration">stochasticRainfallGeneration</a></li><li data-type='method'><a href="hydro.html#.syntheticalc">syntheticalc</a></li><li data-type='method'><a href="hydro.html#.thiessen">thiessen</a></li><li data-type='method'><a href="hydro.html#.timeAreaMethod">timeAreaMethod</a></li><li data-type='method'><a href="hydro.html#.totalprec">totalprec</a></li><li data-type='method'><a href="hydro.html#.unithydrocons">unithydrocons</a></li></ul></li><li><a href="HydroBMI.BMI.html">BMI</a></li><li><a href="HydroLangBMI.html">HydroLangBMI</a><ul class='methods'><li data-type='method'><a href="HydroLangBMI.html#.dataTypes">dataTypes</a></li><li data-type='method'><a href="HydroLangBMI.html#.finalize">finalize</a></li><li data-type='method'><a href="HydroLangBMI.html#.generateOutputs">generateOutputs</a></li><li data-type='method'><a href="HydroLangBMI.html#.get_component_name">get_component_name</a></li><li data-type='method'><a href="HydroLangBMI.html#.get_current_time">get_current_time</a></li><li data-type='method'><a href="HydroLangBMI.html#.get_end_time">get_end_time</a></li><li data-type='method'><a href="HydroLangBMI.html#.get_grid_edge_count">get_grid_edge_count</a></li><li data-type='method'><a href="HydroLangBMI.html#.get_grid_edge_nodes">get_grid_edge_nodes</a></li><li data-type='method'><a href="HydroLangBMI.html#.get_grid_face_count">get_grid_face_count</a></li><li data-type='method'><a href="HydroLangBMI.html#.get_grid_face_nodes">get_grid_face_nodes</a></li><li data-type='method'><a href="HydroLangBMI.html#.get_grid_face_nodes">get_grid_face_nodes</a></li><li data-type='method'><a href="HydroLangBMI.html#.get_grid_node_count">get_grid_node_count</a></li><li data-type='method'><a href="HydroLangBMI.html#.get_grid_nodes_per_face">get_grid_nodes_per_face</a></li><li data-type='method'><a href="HydroLangBMI.html#.get_grid_origin">get_grid_origin</a></li><li data-type='method'><a href="HydroLangBMI.html#.get_grid_shape">get_grid_shape</a></li><li data-type='method'><a href="HydroLangBMI.html#.get_grid_size">get_grid_size</a></li><li data-type='method'><a href="HydroLangBMI.html#.get_grid_size">get_grid_size</a></li><li data-type='method'><a href="HydroLangBMI.html#.get_grid_spacing">get_grid_spacing</a></li><li data-type='method'><a href="HydroLangBMI.html#.get_grid_type">get_grid_type</a></li><li data-type='method'><a href="HydroLangBMI.html#.get_grid_x">get_grid_x</a></li><li data-type='method'><a href="HydroLangBMI.html#.get_grid_y">get_grid_y</a></li><li data-type='method'><a href="HydroLangBMI.html#.get_grid_z">get_grid_z</a></li><li data-type='method'><a href="HydroLangBMI.html#.get_input_item_count">get_input_item_count</a></li><li data-type='method'><a href="HydroLangBMI.html#.get_time_step">get_time_step</a></li><li data-type='method'><a href="HydroLangBMI.html#.get_time_units">get_time_units</a></li><li data-type='method'><a href="HydroLangBMI.html#.get_value_at_indices">get_value_at_indices</a></li><li data-type='method'><a href="HydroLangBMI.html#.get_value_ptr">get_value_ptr</a></li><li data-type='method'><a href="HydroLangBMI.html#.get_var_type">get_var_type</a></li><li data-type='method'><a href="HydroLangBMI.html#.handleConfig">handleConfig</a></li><li data-type='method'><a href="HydroLangBMI.html#.initialize">initialize</a></li><li data-type='method'><a href="HydroLangBMI.html#.set_value">set_value</a></li><li data-type='method'><a href="HydroLangBMI.html#.set_value_at_indices">set_value_at_indices</a></li><li data-type='method'><a href="HydroLangBMI.html#.update">update</a></li><li data-type='method'><a href="HydroLangBMI.html#.update_until">update_until</a></li><li data-type='method'><a href="HydroLangBMI.html#.visualizer">visualizer</a></li></ul></li><li><a href="map.html">map</a><ul class='methods'><li data-type='method'><a href="map.html#.addMarker">addMarker</a></li><li data-type='method'><a href="map.html#.draw">draw</a></li><li data-type='method'><a href="map.html#.generateColors">generateColors</a></li><li data-type='method'><a href="map.html#.geoJSON">geoJSON</a></li><li data-type='method'><a href="map.html#.kml">kml</a></li><li data-type='method'><a href="map.html#.Layers">Layers</a></li><li data-type='method'><a href="map.html#.loader">loader</a></li><li data-type='method'><a href="map.html#.markerStyles">markerStyles</a></li><li data-type='method'><a href="map.html#.renderMap">renderMap</a></li></ul></li><li><a href="nn.html">nn</a><ul class='methods'><li data-type='method'><a href="nn.html#.convertToTensor">convertToTensor</a></li><li data-type='method'><a href="nn.html#.createModel">createModel</a></li><li data-type='method'><a href="nn.html#.prediction">prediction</a></li><li data-type='method'><a href="nn.html#.saveModel">saveModel</a></li><li data-type='method'><a href="nn.html#.trainModel">trainModel</a></li></ul></li><li><a href="stats.html">stats</a><ul class='methods'><li data-type='method'><a href="stats.html#.arrchange">arrchange</a></li><li data-type='method'><a href="stats.html#.autocovarianceMatrix">autocovarianceMatrix</a></li><li data-type='method'><a href="stats.html#.basicstats">basicstats</a></li><li data-type='method'><a href="stats.html#.bernoulliDist">bernoulliDist</a></li><li data-type='method'><a href="stats.html#.binomialCoefficient">binomialCoefficient</a></li><li data-type='method'><a href="stats.html#.binomialDist">binomialDist</a></li><li data-type='method'><a href="stats.html#.breuschPaganTest">breuschPaganTest</a></li><li data-type='method'><a href="stats.html#.chisqCDF">chisqCDF</a></li><li data-type='method'><a href="stats.html#.cleaner">cleaner</a></li><li data-type='method'><a href="stats.html#.computeD">computeD</a></li><li data-type='method'><a href="stats.html#.copydata">copydata</a></li><li data-type='method'><a href="stats.html#.correlation">correlation</a></li><li data-type='method'><a href="stats.html#.datagaps">datagaps</a></li><li data-type='method'><a href="stats.html#.dateparser">dateparser</a></li><li data-type='method'><a href="stats.html#.differencing">differencing</a></li><li data-type='method'><a href="stats.html#.efficiencies">efficiencies</a></li><li data-type='method'><a href="stats.html#.exponentialMovingAverage">exponentialMovingAverage</a></li><li data-type='method'><a href="stats.html#.fastfourier">fastfourier</a></li><li data-type='method'><a href="stats.html#.flatenise">flatenise</a></li><li data-type='method'><a href="stats.html#.frequency">frequency</a></li><li data-type='method'><a href="stats.html#.gammaCDFApprox">gammaCDFApprox</a></li><li data-type='method'><a href="stats.html#.gapfiller">gapfiller</a></li><li data-type='method'><a href="stats.html#.gapremoval">gapremoval</a></li><li data-type='method'><a href="stats.html#.gaussianDist">gaussianDist</a></li><li data-type='method'><a href="stats.html#.generateRandomData">generateRandomData</a></li><li data-type='method'><a href="stats.html#.geometricDist">geometricDist</a></li><li data-type='method'><a href="stats.html#.getNextState">getNextState</a></li><li data-type='method'><a href="stats.html#.gevDistribution">gevDistribution</a></li><li data-type='method'><a href="stats.html#.gumbelDist">gumbelDist</a></li><li data-type='method'><a href="stats.html#.interoutliers">interoutliers</a></li><li data-type='method'><a href="stats.html#.itemfilter">itemfilter</a></li><li data-type='method'><a href="stats.html#.joinarray">joinarray</a></li><li data-type='method'><a href="stats.html#.KS_computePValue">KS_computePValue</a></li><li data-type='method'><a href="stats.html#.KS_rejectAtAlpha">KS_rejectAtAlpha</a></li><li data-type='method'><a href="stats.html#.linearMovingAverage">linearMovingAverage</a></li><li data-type='method'><a href="stats.html#.lognormalDist">lognormalDist</a></li><li data-type='method'><a href="stats.html#.LogSeriesDistribution">LogSeriesDistribution</a></li><li data-type='method'><a href="stats.html#.matrixInverse">matrixInverse</a></li><li data-type='method'><a href="stats.html#.max">max</a></li><li data-type='method'><a href="stats.html#.mean">mean</a></li><li data-type='method'><a href="stats.html#.median">median</a></li><li data-type='method'><a href="stats.html#.min">min</a></li><li data-type='method'><a href="stats.html#.MK">MK</a></li><li data-type='method'><a href="stats.html#.multinomialDistribution">multinomialDistribution</a></li><li data-type='method'><a href="stats.html#.multipleMatrix">multipleMatrix</a></li><li data-type='method'><a href="stats.html#.multiregression">multiregression</a></li><li data-type='method'><a href="stats.html#.normalcdf">normalcdf</a></li><li data-type='method'><a href="stats.html#.normalDistribution">normalDistribution</a></li><li data-type='method'><a href="stats.html#.normoutliers">normoutliers</a></li><li data-type='method'><a href="stats.html#.numerise">numerise</a></li><li data-type='method'><a href="stats.html#.onearray">onearray</a></li><li data-type='method'><a href="stats.html#.outremove">outremove</a></li><li data-type='method'><a href="stats.html#.poissonProcess">poissonProcess</a></li><li data-type='method'><a href="stats.html#.push">push</a></li><li data-type='method'><a href="stats.html#.quantile">quantile</a></li><li data-type='method'><a href="stats.html#.range">range</a></li><li data-type='method'><a href="stats.html#.regression">regression</a></li><li data-type='method'><a href="stats.html#.residualVariance">residualVariance</a></li><li data-type='method'><a href="stats.html#.returnPeriod">returnPeriod</a></li><li data-type='method'><a href="stats.html#.runMarkovChainMonteCarlo">runMarkovChainMonteCarlo</a></li><li data-type='method'><a href="stats.html#.runMonteCarlo">runMonteCarlo</a></li><li data-type='method'><a href="stats.html#.runSimulation">runSimulation</a></li><li data-type='method'><a href="stats.html#.runVegas">runVegas</a></li><li data-type='method'><a href="stats.html#.simpleMovingAverage">simpleMovingAverage</a></li><li data-type='method'><a href="stats.html#.spiCompute">spiCompute</a></li><li data-type='method'><a href="stats.html#.standardize">standardize</a></li><li data-type='method'><a href="stats.html#.stddev">stddev</a></li><li data-type='method'><a href="stats.html#.sum">sum</a></li><li data-type='method'><a href="stats.html#.sumsqrd">sumsqrd</a></li><li data-type='method'><a href="stats.html#.timegaps">timegaps</a></li><li data-type='method'><a href="stats.html#.transposeMatrix">transposeMatrix</a></li><li data-type='method'><a href="stats.html#.uniformDist">uniformDist</a></li><li data-type='method'><a href="stats.html#.unique">unique</a></li><li data-type='method'><a href="stats.html#.variance">variance</a></li></ul></li><li><a href="visualize.html">visualize</a><ul class='methods'><li data-type='method'><a href="visualize.html#.chart">chart</a></li><li data-type='method'><a href="visualize.html#.draw">draw</a></li><li data-type='method'><a href="visualize.html#.drawHtmlTable">drawHtmlTable</a></li><li data-type='method'><a href="visualize.html#.generateReport">generateReport</a></li><li data-type='method'><a href="visualize.html#.prettyPrint">prettyPrint</a></li><li data-type='method'><a href="visualize.html#.table">table</a></li></ul></li></ul><h3>Modules</h3><ul><li><a href="module-analyze.html">analyze</a></li><li><a href="module-mapsources.html">mapsources</a></li></ul><h3>Externals</h3><ul><li><a href="external-D3.html">D3</a></li><li><a href="external-GoogleCharts.html">GoogleCharts</a></li><li><a href="external-googlemapsapi.html">googlemapsapi</a></li><li><a href="external-leafletosmapi.html">leafletosmapi</a></li><li><a href="external-tensorflow.html">tensorflow</a></li><li><a href="external-tileprov.html">tileprov</a></li></ul><h3>Namespaces</h3><ul><li><a href="datasources.html">datasources</a><ul class='members'><li data-type='method'><a href="datasources.html#.AEMET">AEMET</a></li><li data-type='method'><a href="datasources.html#.ClearCreek">ClearCreek</a></li><li data-type='method'><a href="datasources.html#.EAUK">EAUK</a></li><li data-type='method'><a href="datasources.html#.ECMWF">ECMWF</a></li><li data-type='method'><a href="datasources.html#.EPA">EPA</a></li><li data-type='method'><a href="datasources.html#.FEMA">FEMA</a></li><li data-type='method'><a href="datasources.html#.flooddamage_dt">flooddamage_dt</a></li><li data-type='method'><a href="datasources.html#.IFIS">IFIS</a></li><li data-type='method'><a href="datasources.html#.MeteoIT">MeteoIT</a></li><li data-type='method'><a href="datasources.html#.MeteoIT">MeteoIT</a></li><li data-type='method'><a href="datasources.html#.MeteoSTAT">MeteoSTAT</a></li><li data-type='method'><a href="datasources.html#.mitigation_dt">mitigation_dt</a></li><li data-type='method'><a href="datasources.html#.NASAPOWER">NASAPOWER</a></li><li data-type='method'><a href="datasources.html#.NLDI">NLDI</a></li><li data-type='method'><a href="datasources.html#.NOAA">NOAA</a></li><li data-type='method'><a href="datasources.html#.NWPS">NWPS</a></li><li data-type='method'><a href="datasources.html#.NWS">NWS</a></li><li data-type='method'><a href="datasources.html#.ProxyServers">ProxyServers</a></li><li data-type='method'><a href="datasources.html#.soapEnv">soapEnv</a></li><li data-type='method'><a href="datasources.html#.USGS">USGS</a></li><li data-type='method'><a href="datasources.html#.USGS">USGS</a></li><li data-type='method'><a href="datasources.html#.Worldbank">Worldbank</a></li><li data-type='method'><a href="datasources.html#.WQP">WQP</a></li></ul></li><li><a href="datasources.CUAHSI.html">CUAHSI</a><ul class='members'><li data-type='method'><a href="datasources.CUAHSI.html#.hisCentral">hisCentral</a></li><li data-type='method'><a href="datasources.CUAHSI.html#.hydroShare">hydroShare</a></li><li data-type='method'><a href="datasources.CUAHSI.html#.waterOneFlow">waterOneFlow</a></li></ul></li><li><a href="HydroBMI.html">HydroBMI</a><ul class='members'><li data-type='method'><a href="HydroBMI.html#.BMIConfig">BMIConfig</a></li></ul></li><li><a href="HydroBMI.Hydro.html">Hydro</a></li><li><a href="Hydrolang.html">Hydrolang</a></li></ul><h3>Global</h3><ul><li><a href="global.html#addCustomLegend">addCustomLegend</a></li><li><a href="global.html#dotProduct">dotProduct</a></li><li><a href="global.html#goldfeldQuandtTest">goldfeldQuandtTest</a></li><li><a href="global.html#recenter">recenter</a></li><li><a href="global.html#whitesTest">whitesTest</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">modules/data/data.js</h1>
    
    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import * as datasources from "./datasources.js";
import stats from "../analyze/components/stats.js";
//import fxparserMin from "./fxparser.min.js";

//import XMLParser from './fxparser.min.js'
//import  {XMLParser} from "./fxparser.min.js";

//Workaround for DOM manipulation using a web worker environment


// 'https://cdnjs.cloudflare.com/ajax/libs/fast-xml-parser/4.5.1/fxparser.min.js'

/**
 * Module for dealing with data retrieval, transformation, upload, and download operations.
 * Provides functions to interact with various hydrological data sources and perform data operations.
 * @class 
 * @name data
 */

/**
 * Main function to retrieve data from various hydrological data sources.
 * Supports multiple data sources including USGS, NLDI, NWS, and others.
 * 
 * @function retrieve
 * @memberof data
 * @async
 * @param {Object} options - Configuration object for data retrieval
 * @param {Object} options.params - Parameters for the request
 * @param {string} options.params.source - Data source identifier (e.g., 'usgs', 'nldi', 'nws')
 * @param {string} options.params.datatype - Type of data to retrieve (varies by source)
 * @param {string} [options.params.type] - Response format ('json', 'xml', 'csv', 'soap') - defaults to source's default
 * @param {boolean} [options.params.transform] - Whether to apply data transformation
 * @param {boolean} [options.params.placeHolder] - Whether to use placeholder data
 * @param {string} [options.params.keyname] - API key parameter name for authenticated sources
 * @param {Object} options.args - Arguments specific to the data source endpoint
 * @param {Object} [options.data] - Additional data payload (for POST requests)
 * @returns {Promise&lt;Object|string>} Promise resolving to retrieved data in specified format
 * 
 * @example
 * // Retrieve USGS instantaneous streamflow data
 * const streamflowData = await hydro.data.retrieve({
 *   params: {
 *     source: 'usgs',
 *     datatype: 'instant-values',
 *     transform: true
 *   },
 *   args: {
 *     format: 'json',
 *     sites: '05454500',
 *     startDT: '2020-01-01',
 *     endDT: '2020-01-07'
 *   }
 * });
 * 
 * @example
 * // Retrieve NLDI basin boundary data
 * const basinData = await hydro.data.retrieve({
 *   params: {
 *     source: 'nldi',
 *     datatype: 'getBasin'
 *   },
 *   args: {
 *     featureSource: 'comid',
 *     featureId: '13297246'
 *   }
 * });
 * 
 * @example
 * // Retrieve NASA POWER meteorological data
 * const powerData = await hydro.data.retrieve({
 *   params: {
 *     source: 'nasapower',
 *     datatype: 'point-data'
 *   },
 *   args: {
 *     parameters: 'T2M,PRECTOTCORR,RH2M',
 *     community: 're',
 *     longitude: -76.3,
 *     latitude: 38.5,
 *     start: '20200101',
 *     end: '20200131',
 *     format: 'JSON'
 *   }
 * });
 * 
 * @example
 * // Retrieve NOAA climate data with API key
 * const climateData = await hydro.data.retrieve({
 *   params: {
 *     source: 'noaa',
 *     datatype: 'prec-15min',
 *     token: 'YOUR_NOAA_TOKEN'
 *   },
 *   args: {
 *     datasetid: 'PRECIP_15',
 *     stationid: 'GHCND:USW00014895',
 *     startdate: '2020-01-01',
 *     enddate: '2020-01-07',
 *     limit: 100
 *   }
 * });
 * 
 * @example
 * // Retrieve Meteostat weather station data
 * const meteoData = await hydro.data.retrieve({
 *   params: {
 *     source: 'meteostat',
 *     datatype: 'dailydata-station',
 *     'x-rapidapi-key': 'YOUR_RAPIDAPI_KEY'
 *   },
 *   args: {
 *     station: '10382',
 *     start: '2020-01-01',
 *     end: '2020-01-31'
 *   }
 * });
 * 
 * @example
 * // Retrieve EPA precipitation data (POST request)
 * const epaData = await hydro.data.retrieve({
 *   params: {
 *     source: 'epa',
 *     datatype: 'precipitation',
 *     type: 'json'
 *   },
 *   args: {
 *     source: 'nldas',
 *     dateTimeSpan: {
 *       startDate: '2020-01-01 00',
 *       endDate: '2020-01-07 00',
 *       dateTimeFormat: 'yyyy-MM-dd HH'
 *     },
 *     geometry: {
 *       point: {
 *         latitude: 33.925,
 *         longitude: -83.356
 *       }
 *     },
 *     dataValueFormat: 'E3',
 *     temporalResolution: 'hourly',
 *     units: 'metric'
 *   }
 * });
 * 
 * @example
 * // Retrieve flood damage scenario data
 * const floodData = await hydro.data.retrieve({
 *   params: {
 *     source: 'flooddamage_dt',
 *     datatype: 'x500_year',
 *     transform: 'eval'
 *   },
 *   args: {
 *     sourceType: 'Cedar Rapids'
 *   }
 * });
 */
async function retrieve({ params, args, data } = {}) {

  let source = params.source;
  let dataType = params.datatype;
  let placeHolder = params.placeHolder || false;
  let trans = params.transform || false;
  let dataSource = datasources[source]?.[dataType];

  console.log(params)

  if (!dataSource) {
    return Promise.reject(new Error("No data source found for the given specifications."));
  }

  let endpoint =
    source === "waterOneFlow" || source === "hisCentral" || source === "mitigation_dt" || source === "flooddamage_dt"
      ? datasources[source].sourceType(args.sourceType, dataType)
      : dataSource.endpoint;

  let type = params.type || dataSource.methods.type;

  // let proxy = datasources[source]?.requirements?.needProxy
  //   ? datasources.proxies["local-proxy"].endpoint
  //   : "";
  
    let proxy = datasources.proxies["local-proxy"].endpoint
    ;

  let headers = {
    "content-type": (() => {
      if (type === "json") {
        return "application/json";
      } else if (type === "xml" || type === "soap") {
        return "text/xml; charset=utf-8";
      } else if (type === "csv" || type === "tab") {
        return "application/text"; 
      } else {
        return "application/json"; // Default
      }
    })(),
  };

  if (type === "soap") {
    headers["SOAPAction"] = datasources[source].action + dataType;
  }

  let keyname = datasources[source]?.requirements?.keyname;
  if (keyname &amp;&amp; params[keyname]) {
    headers[keyname] = params[keyname];
  } else if (keyname) {
    console.warn("info: please verify the keyname of the source."); 
  }

  endpoint = endpoint.replace(/{(\w+)}/g, (match, key) => {
    const value = args[key];
    delete args[key];
    return value;
  });


  let fetchOptions = {
    method: dataSource.methods.method,
    headers: headers,
  };

  if (fetchOptions.method === 'POST') {
    if (type === 'json') {
      fetchOptions.body = JSON.stringify(args);
    } else if (type === 'soap' || type === 'xml') {
      fetchOptions.body = Object.keys(args).length
        ? datasources.envelope(dataSource.body(args))
        : datasources.envelope(dataSource.body());
    }
  } else if (fetchOptions.method === 'GET' &amp;&amp; Object.keys(args).length > 0) {
    const queryString = new URLSearchParams(args).toString();
    endpoint += `?${queryString}`;
  }


  return fetch(proxy + endpoint, fetchOptions)
    .then(async (response) => {
      if (!response.ok) {
        const errorData = await response.text();
        throw new Error(`HTTP error ${response.status} fetching ${endpoint}: ${errorData}`);
      }

      if (type === "json") {
        return response.json();
      } else if (type === "xml" || type === "soap" || type === "csv" || type === "tab") {
        return response.text();
      } else {
        return response.json(); // Default to JSON
      }
    })
    .then((responseData) => {
      if (type === "soap") {
        try {
          //DOM Parser workaround
          // const parser = new DOMParser();
          // const xmlDoc = parser.parseFromString(responseData, "text/xml");

          // const parser = new XMLParser();
          // console.log(parser)
          // const xmlDoc = parser.parse(responseData);

          return responseData

          //let j = xml2json(xmlDoc);
          // return xmlDoc["soap:Envelope"]?.["soap:Body"] || j; // Handle cases where soap:Body might not exist
        } catch (xmlError) {
          throw new Error(`Error parsing SOAP response from ${endpoint}: ${xmlError.message}`);
        }
      } else if (type === "xml" || type === "tab" || type === "CSV") {
        return JSON.stringify(responseData);
      } else if (trans) {
        if (source === "usgs") {
          return transform({
            params: { save: 'value'}, 
            args: { keep: '["datetime", "value"]', type: 'ARR'}, 
            data: lowercasing(responseData)
          });
        } else if (trans === "eval") {
          return eval(responseData); // Use eval cautiously
        }
      } else {
        return lowercasing(responseData);
      }
    });
}


/**
 * Convert data types into various formats based on JavaScript objects as primary input.
 * Supports extraction of nested data, filtering, and format conversion.
 * 
 * @function transform
 * @memberof data
 * @param {Object} options - Configuration object for transformation
 * @param {Object} [options.params] - Parameters for data extraction and saving
 * @param {string} [options.params.save] - Key name to search for and extract from nested objects
 * @param {string} [options.params.output] - Output variable name (currently unused)
 * @param {Object} [options.args] - Arguments for transformation options
 * @param {string} [options.args.type] - Output format: 'ARR', 'ARR-col', 'CSV', 'JSON', 'XML2JSON'
 * @param {string[]|string} [options.args.keep] - Array of column headers to keep (JSON string or array)
 * @param {boolean} [options.args.parse] - Whether to parse strings to numbers/dates/booleans
 * @param {string} [options.args.mode] - Processing mode: 'flatten', 'flatten-objects'
 * @param {number} [options.args.pick] - Pick specific row index from 2D array
 * @param {boolean} [options.args.attachNames=true] - Whether to attach column names to arrays
 * @param {Object|Array} options.data - Input data object to be transformed
 * @returns {Object|Array|string} Transformed data in the specified format
 * 
 * @example
 * // Extract specific data from nested object and convert to array
 * const arrayData = hydro.data.transform({
 *   params: { save: 'timeSeries' },
 *   args: { 
 *     keep: ['dateTime', 'value'], 
 *     type: 'ARR',
 *     parse: true 
 *   },
 *   data: usgsResponseData
 * });
 * 
 * @example
 * // Convert object array to CSV format
 * const csvData = hydro.data.transform({
 *   args: { type: 'CSV' },
 *   data: [
 *     { date: '2023-01-01', flow: 100.5 },
 *     { date: '2023-01-02', flow: 95.3 }
 *   ]
 * });
 * 
 * @example
 * // Flatten nested object structure
 * const flattenedData = hydro.data.transform({
 *   args: { mode: 'flatten-objects' },
 *   data: {
 *     station: {
 *       info: { name: 'USGS Station', id: '01646500' },
 *       data: { flow: 100.5, stage: 2.1 }
 *     }
 *   }
 * });
 * // Result: { 'station.info.name': 'USGS Station', 'station.info.id': '01646500', ... }
 * 
 * @example
 * // Extract specific columns as separate arrays
 * const columnArrays = hydro.data.transform({
 *   args: { 
 *     type: 'ARR-col',
 *     keep: ['dateTime', 'value'],
 *     attachNames: false
 *   },
 *   data: [
 *     { dateTime: '2023-01-01', value: 100.5, quality: 'A' },
 *     { dateTime: '2023-01-02', value: 95.3, quality: 'A' }
 *   ]
 * });
 * // Result: [['2023-01-01', '2023-01-02'], [100.5, 95.3]]
 * 
 * @example
 * // Convert XML string to JSON
 * const jsonData = hydro.data.transform({
 *   args: { type: 'XML2JSON' },
 *   data: '&lt;root>&lt;item>value1&lt;/item>&lt;item>value2&lt;/item>&lt;/root>'
 * });
 * 
 * @example
 * // Pick specific row from 2D array and flatten
 * const singleRow = hydro.data.transform({
 *   args: { 
 *     pick: 0, 
 *     mode: 'flatten' 
 *   },
 *   data: [
 *     ['dates', '2023-01-01', '2023-01-02'],
 *     ['values', 100.5, 95.3]
 *   ]
 * });
 * // Result: [100.5, 95.3] (numeric values from first row, excluding header)
 */
function transform({ params, args, data } = {}) {
  function deepClone(value) {
    if (value === null || typeof value !== 'object') return value;
    if (value instanceof Date) return new Date(value.getTime());
    if (Array.isArray(value)) return value.map(deepClone);
    const result = {};
    for (const key in value) {
      if (Object.prototype.hasOwnProperty.call(value, key)) {
        result[key] = deepClone(value[key]);
      }
    }
    return result;
  }

  const convertToNumberIfPossible = (value) => {
    if (typeof value === 'string' &amp;&amp; !isNaN(value) &amp;&amp; value.trim() !== '') {
      return Number(value);
    }
    return value;
  };

  const cleanData = (data) => {
    if (Array.isArray(data)) {
      return data.map(item => cleanData(item));
    } else if (typeof data === 'object' &amp;&amp; data !== null) {
      const cleaned = {};
      for (const key in data) {
        cleaned[key] = cleanData(data[key]);
      }
      return cleaned;
    } else {
      return convertToNumberIfPossible(data);
    }
  };

  const parseSpecialTypes = (value) => {
    if (typeof value === 'string') {
      const date = new Date(value);
      if (!isNaN(date.getTime())) return date;
      if (value.toLowerCase() === 'true' || value.toLowerCase() === 'false') {
        return value.toLowerCase() === 'true';
      }
    }
    return value;
  };

  const extractNestedValue = (obj, path) => {
    return path.split('.').reduce((acc, key) => acc?.[key], obj);
  };

  const flattenObject = (obj, parentKey = '', result = {}) => {
    for (const key in obj) {
      const value = obj[key];
      const newKey = parentKey ? `${parentKey}.${key}` : key;
      if (typeof value === 'object' &amp;&amp; value !== null &amp;&amp; !Array.isArray(value)) {
        flattenObject(value, newKey, result);
      } else {
        result[newKey] = value;
      }
    }
    return result;
  };

  // Start transforming
  console.log('[transform] Original input data:', data);
  data = deepClone(data);

  // === PARAMS &amp; ARGS LOGIC ===
  if (!params) {
    data = args?.parse ? cleanData(data) : data;
  } else if (params.save !== undefined &amp;&amp; args === undefined) {
    const found = recursiveSearch({ obj: data, searchkey: params.save });
    data = found?.[0];
  } else if (params.save !== undefined &amp;&amp; args.keep !== undefined) {
    const found = recursiveSearch({ obj: data, searchkey: params.save });
    data = found?.[0];

    if (!data) return null;
    if (args.parse) {
      data = cleanData(data);
    }

    if (typeof args.keep === 'string') {
      args.keep = JSON.parse(args.keep);
    }

    const keepKeys = new RegExp(args.keep.join('|'));

    if (Array.isArray(data)) {
      data = data.map(obj => {
        if (typeof obj !== 'object') return obj;
        const filtered = {};
        for (const key in obj) {
          if (keepKeys.test(key)) {
            filtered[key] = obj[key];
          }
        }
        return filtered;
      });
    } else if (typeof data === 'object' &amp;&amp; data !== null) {
      const filtered = {};
      for (const key in data) {
        if (keepKeys.test(key)) {
          filtered[key] = data[key];
        }
      }
      data = filtered;
    }
  } else if (params.save !== undefined &amp;&amp; args.keep === undefined) {
    const found = recursiveSearch({ obj: data, searchkey: params.save });
    data = found?.[0];
    data = args?.parse ? cleanData(data) : data;
  }

    // === PICKING A SPECIFIC ROW FROM 2D ARRAY ===
    if (args?.pick !== undefined) {
      if (Array.isArray(data) &amp;&amp; Array.isArray(data[0])) {
        const idx = Number(args.pick);
        if (!isNaN(idx) &amp;&amp; data.length > idx) {
          data = data[idx];
        }
      }
    }

  // === MODE HANDLING ===
  if (args?.mode === 'flatten') {
    if (Array.isArray(data) &amp;&amp; Array.isArray(data[0])) {
      if (typeof data[0][0] === 'string' &amp;&amp; data[0].length > 1) {
        return data[0].slice(1).map(convertToNumberIfPossible);
      }
    }
    if (Array.isArray(data)) {
      return data
        .map(convertToNumberIfPossible)
        .filter(val => typeof val === 'number' &amp;&amp; !isNaN(val));
    }
  }

  if (args?.mode === 'flatten-objects') {
    if (Array.isArray(data) &amp;&amp; typeof data[0] === 'object') {
      data = data.map(flattenObject);
    } else if (typeof data === 'object') {
      data = flattenObject(data);
    }
  }

  // === KEEP NESTED KEYS AFTER FLATTEN ===
  if (Array.isArray(data) &amp;&amp; args?.keep) {
    const keepPaths = args.keep;
    data = data.map(item => {
      const extracted = {};
      for (const path of keepPaths) {
        const key = path.includes('.') ? path.split('.').pop() : path;
        extracted[key] = extractNestedValue(item, path);
      }
      return extracted;
    });
  }

  const type = args?.type;
  let arr;

  if (Array.isArray(data)) {
    arr = deepClone(data);

    if (args?.keep) {
      const keep = new RegExp(args.keep.join('|'));
      for (let i = 0; i &lt; arr.length; i++) {
        for (const k in arr[i]) {
          if (!keep.test(k)) {
            delete arr[i][k];
          }
        }
      }
    }
  }

  // === FORMAT TRANSFORMATIONS ===
  if (type === 'ARR') {
    if (!arr || !Array.isArray(arr)) {
      console.error('[transform] arr is undefined or not an array:', arr);
      return null;
    }
  
    const arrays = arr.map(obj =>
      Object.keys(obj)
        .sort()
        .map(key => args.parse ? parseSpecialTypes(obj[key]) : obj[key])
    );
  
    const final = Array(arrays[0]?.length || 0)
      .fill(0)
      .map(() => Array(arrays.length).fill(0));
  
    for (let j = 0; j &lt; arrays[0]?.length; j++) {
      for (let n = 0; n &lt; arrays.length; n++) {
        final[j][n] = arrays[n][j];
      }
    }
  
    // Attach names only if requested
    if (args.keep &amp;&amp; args.attachNames !== false) {
      for (let j = 0; j &lt; final.length; j++) {
        final[j].unshift(args.keep[j]);
      }
    }
  
    return final;
  }

  else if (type === 'ARR-col') {
    if (!arr || !Array.isArray(arr)) return null;

    const keysToUse = args.keep;
    const arrays = keysToUse.map(key => {
      const column = [];
      if (args.attachNames !== false) {
        column.push(key); // Only attach name if requested
      }
      for (let i = 0; i &lt; arr.length; i++) {
        const val = arr[i]?.[key];
        column.push(args.parse ? parseSpecialTypes(val) : val);
      }
      return column;
    });
  
    return arrays;
  }

  else if (type === 'CSV') {
    if (!arr || !Array.isArray(arr)) {
      console.error('[transform] CSV conversion failed: arr is invalid');
      return null;
    }

    let str = '';
    for (let i = 0; i &lt; arr.length; i++) {
      let line = '';
      for (const index in arr[i]) {
        if (line !== '') line += ',';
        line += `"${arr[i][index]}"`;
      }
      str += line + '\r\n';
    }
    return str;
  }

  else if (type === 'JSON') {
    return JSON.stringify(data);
  }

  else if (type === 'XML2JSON') {
    const XMLJSon = (data) => {
      const json = {};
      for (const res of data.matchAll(/(?:&lt;(\w*)(?:\s[^>]*)*>)((?:(?!&lt;\1).)*)(?:&lt;\/\1>)|&lt;(\w*)(?:\s*)*\/>/gm)) {
        const key = res[1] || res[3],
              value = res[2] &amp;&amp; XMLJSon(res[2]);
        json[key] = value &amp;&amp; Object.keys(value).length ? value : res[2] || null;
      }
      return json;
    };
    return XMLJSon(data);
  }

  else if (type) {
    throw new Error('Please select a supported data conversion type!');
  }

  return data;
}


/**
 * Upload data from the user's local file system for analysis.
 * Creates a file input dialog and processes the selected file based on its type.
 * 
 * @function upload
 * @memberof data
 * @async
 * @param {Object} options - Configuration object for file upload
 * @param {Object} options.params - Parameters for upload configuration
 * @param {string} options.params.type - File type to accept ('CSV', 'JSON', 'KML')
 * @param {Object} [options.args] - Additional arguments (currently unused)
 * @param {Object} [options.data] - Additional data (currently unused)
 * @returns {Promise&lt;Array|Object|string>} Promise resolving to parsed file content
 * 
 * @example
 * // Upload and parse CSV file
 * const csvData = await hydro.data.upload({
 *   params: { type: 'CSV' }
 * });
 * // Returns array of arrays with numeric conversion for numeric columns
 * // Example result: [['Date', 'Flow', 'Stage'], ['2023-01-01', 100.5, 2.1], ...]
 * 
 * @example
 * // Upload and parse JSON file
 * const jsonData = await hydro.data.upload({
 *   params: { type: 'JSON' }
 * });
 * // Returns parsed JSON object
 * 
 * @example
 * // Upload KML file as raw text
 * const kmlData = await hydro.data.upload({
 *   params: { type: 'KML' }
 * });
 * // Returns raw KML content as string
 */
async function upload({ params, args, data } = {}) {
  const fileInput = document.createElement("input");
  fileInput.type = "file";
  fileInput.accept = params.type;

  let ret = null;

  const getFileContent = (file) => {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = () => resolve(reader.result);
      reader.onerror = () => reject(reader.error);
      reader.readAsText(file);
    });
  };

  const isNumeric = (value) => {
    return /^-?\d+\.?\d*$/.test(value);
  };

  const handleFileSelect = async (event) => {
    const file = event.target.files[0];
    const content = await getFileContent(file);

    if (params.type === "CSV") {
      const rows = content.split(/\r\n|\n/).map((row) => {
        return row.split(",").map((value) => value.replace(/^"|"$/g, ""));
      });

      const columns = rows[0].map((_, i) => rows.map((row) => row[i]));
      ret = [];
      columns.forEach((column, i) => {
        if (column.every(isNumeric)) {
          ret.push(column.map((value) => parseFloat(value)));
        } else {
          ret.push(column);
        }
      });

    } else if (params.type === "JSON") {
      ret = JSON.parse(content);

    } else if (params.type === "KML") {
      ret = content
    }
  };

  fileInput.addEventListener("change", handleFileSelect);
  fileInput.click();

  return new Promise((resolve) => {
    const intervalId = setInterval(() => {
      if (ret !== null) {
        clearInterval(intervalId);
        resolve(ret);
      }
    }, 100);
  });
}


/**
 * Download data in various formats to the user's local file system.
 * Automatically transforms data using the transform function and creates a downloadable file.
 * 
 * @function download
 * @memberof data
 * @async
 * @param {Object} options - Configuration object for download
 * @param {Object} [options.params] - Parameters for download configuration
 * @param {string} [options.params.fileName] - Name for the downloaded file (without extension)
 * @param {Object} options.args - Arguments for download format and transformation
 * @param {string} options.args.type - Download format ('CSV', 'JSON')
 * @param {string[]} [options.args.keep] - Column headers to keep (for CSV)
 * @param {Object|Array|Promise} options.data - Data to download (can be a Promise)
 * @returns {Promise&lt;void>} Promise that resolves when download is initiated
 * 
 * @example
 * // Download data as CSV file
 * await hydro.data.download({
 *   params: { fileName: 'streamflow_data' },
 *   args: { 
 *     type: 'CSV',
 *     keep: ['dateTime', 'value']
 *   },
 *   data: transformedData
 * });
 * // Downloads file as 'streamflow_data.csv'
 * 
 * @example
 * // Download data as JSON file
 * await hydro.data.download({
 *   params: { fileName: 'station_info' },
 *   args: { type: 'JSON' },
 *   data: stationData
 * });
 * // Downloads file as 'station_info.json'
 * 
 * @example
 * // Download with auto-generated filename
 * await hydro.data.download({
 *   args: { type: 'CSV' },
 *   data: myData
 * });
 * // Downloads with timestamp-based filename like '23.12.15.14:30.csv'
 */
async function download({ params, args, data } = {}) {
  let { type } = args;
  let blob = null;
  let exportfilename = null;
  const { fileName } = params || generateDateString();

  //if CSV is required to be download, call the transform function.
  if (type === "CSV") {
    const csv = this.transform({ params, args, data: await data });
    blob = new Blob([csv], {
      type: "text/csv; charset=utf-8;",
    });
    exportfilename = `${fileName}.csv`;

  //if JSON file is required. Similar as before.
  } else if (type === "JSON") {
    let js;
    if (Array.isArray(data)) {
      js = this.transform({ params, args, data });
    } else {
      js = data;
    }
    blob = new Blob([JSON.stringify(await js)], {
      type: "text/json",
    });
    exportfilename = `${fileName}.json`;
  }

  //if XML file is required for loading. Needs improvement.
  /*else if (type === 'XML') {
    const xs = this.transform(data, config);
    blob = new Blob([xs], {type: 'text/xml'});
    exportfilename = 'export.xml';
  };*/

  //after the data has been transformed, create a new download file and link. No name is given but "export".
  if (navigator.msSaveOrOpenBlob) {
    navigator.msSaveOrOpenBlob(blob, exportfilename);
  } else {
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = exportfilename;
    a.click();
    a.remove();
  }
}

/**********************************/
/****** Helper functions **********/
/**********************************/

/**
 * Recursively searches for arrays with specific key names in nested objects.
 * Useful for extracting data from complex nested JSON structures returned by APIs.
 * 
 * @function recursiveSearch
 * @memberof data
 * @param {Object} options - Search configuration object
 * @param {Object} options.obj - Object to search within
 * @param {string} options.searchkey - Key name to search for
 * @param {Array} [options.results=[]] - Array to store found values (used internally for recursion)
 * @returns {Array} Array containing all found values for the specified key
 * 
 * @example
 * // Search for 'timeSeries' arrays in USGS response
 * const complexData = {
 *   value: {
 *     queryInfo: { ... },
 *     timeSeries: [
 *       { name: 'Streamflow', values: [{ value: 100 }, { value: 95 }] }
 *     ]
 *   }
 * };
 * 
 * const timeSeries = hydro.data.recursiveSearch({
 *   obj: complexData,
 *   searchkey: 'timeSeries'
 * });
 * // Returns: [[{ name: 'Streamflow', values: [...] }]]
 * 
 * @example
 * // Search for 'values' arrays in nested data
 * const found = hydro.data.recursiveSearch({
 *   obj: complexData,
 *   searchkey: 'values'
 * });
 * // Returns all arrays with key 'values'
 */
function recursiveSearch({ obj, searchkey, results = [] } = {}) {
  const r = results;
  Object.keys(obj).forEach((key) => {
      const value = obj[key];
      if (key === searchkey &amp;&amp; Array.isArray(value)) {
          r.push(value);
          return;
      } else if (typeof value === "object" &amp;&amp; value !== null) {
          recursiveSearch({ obj: value, searchkey: searchkey, results: r });
      }
  });
  return r;
}

/**
 * Converts all object keys to lowercase recursively, including nested objects and arrays.
 * Useful for normalizing API responses that may have inconsistent casing.
 * 
 * @function lowercasing
 * @memberof data
 * @param {Object|Array|*} obj - Object, array, or value to process
 * @returns {Object|Array|*} Copy of input with all object keys converted to lowercase
 * 
 * @example
 * // Normalize object keys
 * const normalized = hydro.data.lowercasing({
 *   StationName: "USGS Station",
 *   FlowData: {
 *     DateTime: "2023-01-01T12:00:00Z",
 *     Value: 100.5
 *   }
 * });
 * // Returns: { stationname: "USGS Station", flowdata: { datetime: "2023-01-01T12:00:00Z", value: 100.5 } }
 * 
 * @example
 * // Process array of objects
 * const normalizedArray = hydro.data.lowercasing([
 *   { StationID: "01646500", FlowRate: 100 },
 *   { StationID: "01647000", FlowRate: 85 }
 * ]);
 * // Returns: [{ stationid: "01646500", flowrate: 100 }, { stationid: "01647000", flowrate: 85 }]
 */
function lowercasing(obj) {
  if (typeof obj !== "object") return obj;
  if (Array.isArray(obj)) return obj.map(lowercasing);
  return Object.keys(obj).reduce((newObj, key) => {
    let val = obj[key],
      newVal = typeof val === "object" &amp;&amp; val !== null ? lowercasing(val) : val;
    newObj[key.toLowerCase()] = newVal;
    return newObj;
  }, {});
}

/**
 * Recursively converts XML document format to JSON format.
 * Handles XML attributes, text content, and nested elements.
 * 
 * @function xml2json
 * @memberof data
 * @param {Document|Element} xml - Parsed XML document or element from DOMParser
 * @returns {Object|string|null} Object representation of XML structure, or null if error occurs
 * 
 * @example
 * // Convert XML to JSON
 * const parser = new DOMParser();
 * const xmlDoc = parser.parseFromString(xmlString, "text/xml");
 * const jsonResult = hydro.data.xml2json(xmlDoc);
 * 
 * // For XML like: &lt;station id="01646500">&lt;name>Potomac River&lt;/name>&lt;flow>100.5&lt;/flow>&lt;/station>
 * // Returns: { station: { "@id": "01646500", name: "Potomac River", flow: "100.5" } }
 * 
 * @example
 * // Handle XML with multiple elements
 * // XML: &lt;stations>&lt;station>Station1&lt;/station>&lt;station>Station2&lt;/station>&lt;/stations>
 * // Returns: { stations: { station: ["Station1", "Station2"] } }
 */
function xml2json(xml) {
  try {
      let obj = {};

      // Handle attributes
      if (xml.attributes &amp;&amp; xml.attributes.length > 0) {
          for (let i = 0; i &lt; xml.attributes.length; i++) {
              const attr = xml.attributes.item(i);
              obj[`@${attr.nodeName}`] = attr.nodeValue;
          }
      }

      // Handle child nodes
      for (let i = 0; i &lt; xml.childNodes.length; i++) {
          const node = xml.childNodes[i];

          if (node.nodeType === Node.TEXT_NODE) {
              const text = node.textContent.trim();
              if (text.length > 0) {
                  obj["#text"] = text;
              }
          } else if (node.nodeType === Node.ELEMENT_NODE) {
              const nodeName = node.nodeName;
              const childObj = xml2json(node);

              if (obj[nodeName] === undefined) {
                  obj[nodeName] = childObj;
              } else {
                  if (!Array.isArray(obj[nodeName])) {
                      obj[nodeName] = [obj[nodeName]];
                  }
                  obj[nodeName].push(childObj);
              }
          }
      }

      // Edge case: If no children or attributes and there's textContent
      if (
          Object.keys(obj).length === 0 &amp;&amp;
          xml.textContent &amp;&amp;
          xml.textContent.trim().length > 0
      ) {
          return xml.textContent.trim();
      }

      return obj;
  } catch (e) {
      console.error('[xml2json] Error during conversion:', e.message);
      return null;
  }
}


/**
 * Generates a timestamp-based string for file naming.
 * Creates a formatted date string in YY.MM.DD.HH:MM format.
 * 
 * @function generateDateString
 * @memberof data
 * @returns {string} Formatted date string
 * 
 * @example
 * // Get current timestamp for filename
 * const timestamp = hydro.data.generateDateString();
 * // Returns something like: "23.12.15.14:30"
 * 
 * @example
 * // Use in file download
 * const filename = `data_${hydro.data.generateDateString()}.csv`;
 * // Results in: "data_23.12.15.14:30.csv"
 */
function generateDateString() {
  const now = new Date();
  const year = now.getFullYear().toString().slice(-2);
  const month = (now.getMonth() + 1).toString().padStart(2, '0');
  const day = now.getDate().toString().padStart(2, '0');
  const hours = now.getHours().toString().padStart(2, '0');
  const minutes = now.getMinutes().toString().padStart(2, '0');
  return `${year}.${month}.${day}.${hours}:${minutes}`;
}

/**********************************/
/*** End of Helper functions **/
/**********************************/

export { retrieve, transform, download, upload, recursiveSearch, xml2json };
</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.7</a> on Fri Sep 05 2025 21:26:06 GMT+0000 (Coordinated Universal Time) using the Toast theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
