<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>modules/data/data.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="https://code.ionicframework.com/ionicons/2.0.1/css/ionicons.min.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="AORCDataSource.html">AORCDataSource</a><ul class='methods'><li data-type='method'><a href="AORCDataSource.html#calculateIndices">calculateIndices</a></li><li data-type='method'><a href="AORCDataSource.html#extractGridData">extractGridData</a></li><li data-type='method'><a href="AORCDataSource.html#extractPointData">extractPointData</a></li><li data-type='method'><a href="AORCDataSource.html#fetchAndDecompressChunk">fetchAndDecompressChunk</a></li><li data-type='method'><a href="AORCDataSource.html#fetchMetadata">fetchMetadata</a></li><li data-type='method'><a href="AORCDataSource.html#getDatasetInfo">getDatasetInfo</a></li><li data-type='method'><a href="AORCDataSource.html#loadDatasource">loadDatasource</a></li></ul></li><li><a href="data.html">data</a><ul class='methods'><li data-type='method'><a href="data.html#.download">download</a></li><li data-type='method'><a href="data.html#.generateDateString">generateDateString</a></li><li data-type='method'><a href="data.html#.lowercasing">lowercasing</a></li><li data-type='method'><a href="data.html#.recursiveSearch">recursiveSearch</a></li><li data-type='method'><a href="data.html#.retrieve">retrieve</a></li><li data-type='method'><a href="data.html#.transform">transform</a></li><li data-type='method'><a href="data.html#.transformAORCData">transformAORCData</a></li><li data-type='method'><a href="data.html#.upload">upload</a></li><li data-type='method'><a href="data.html#.xml2json">xml2json</a></li></ul></li><li><a href="DEPDataSource.html">DEPDataSource</a><ul class='methods'><li data-type='method'><a href="DEPDataSource.html#calculateSize">calculateSize</a></li><li data-type='method'><a href="DEPDataSource.html#fetchDEMData">fetchDEMData</a></li><li data-type='method'><a href="DEPDataSource.html#fetchPointElevation">fetchPointElevation</a></li><li data-type='method'><a href="DEPDataSource.html#generateGeoTiffUrl">generateGeoTiffUrl</a></li><li data-type='method'><a href="DEPDataSource.html#getDatasetInfo">getDatasetInfo</a></li></ul></li><li><a href="divisors.html">divisors</a><ul class='methods'><li data-type='method'><a href="divisors.html#.createDiv">createDiv</a></li><li data-type='method'><a href="divisors.html#.createScript">createScript</a></li><li data-type='method'><a href="divisors.html#.isdivAdded">isdivAdded</a></li><li data-type='method'><a href="divisors.html#.isScriptAdded">isScriptAdded</a></li></ul></li><li><a href="ECMWFDataSource.html">ECMWFDataSource</a><ul class='methods'><li data-type='method'><a href="ECMWFDataSource.html#extractGridData">extractGridData</a></li><li data-type='method'><a href="ECMWFDataSource.html#extractPointData">extractPointData</a></li><li data-type='method'><a href="ECMWFDataSource.html#extractRawGRIB2">extractRawGRIB2</a></li><li data-type='method'><a href="ECMWFDataSource.html#fetch">fetch</a></li><li data-type='method'><a href="ECMWFDataSource.html#processGRIB2File">processGRIB2File</a></li></ul></li><li><a href="floodDM.html">floodDM</a><ul class='methods'><li data-type='method'><a href="floodDM.html#.buildPropertyDMScenario">buildPropertyDMScenario</a></li><li data-type='method'><a href="floodDM.html#.createTableFromObject">createTableFromObject</a></li><li data-type='method'><a href="floodDM.html#.getBridgeDamage">getBridgeDamage</a></li><li data-type='method'><a href="floodDM.html#.getCityFloodDamage">getCityFloodDamage</a></li><li data-type='method'><a href="floodDM.html#.getFloodInundation">getFloodInundation</a></li><li data-type='method'><a href="floodDM.html#.getLifeLoss">getLifeLoss</a></li><li data-type='method'><a href="floodDM.html#.getPropertyLoss">getPropertyLoss</a></li><li data-type='method'><a href="floodDM.html#.getUtilityDamage">getUtilityDamage</a></li><li data-type='method'><a href="floodDM.html#.getVehicleDamage">getVehicleDamage</a></li><li data-type='method'><a href="floodDM.html#initDamageScenario">initDamageScenario</a></li><li data-type='method'><a href="floodDM.html#initMitigationScenario">initMitigationScenario</a></li><li data-type='method'><a href="floodDM.html#runMitigationScenario">runMitigationScenario</a></li></ul></li><li><a href="geoprocessor.html">geoprocessor</a><ul class='methods'><li data-type='method'><a href="geoprocessor.html#.flowAccumulation">flowAccumulation</a></li><li data-type='method'><a href="geoprocessor.html#.flowDirection">flowDirection</a></li><li data-type='method'><a href="geoprocessor.html#.roughness">roughness</a></li><li data-type='method'><a href="geoprocessor.html#.tpi">tpi</a></li><li data-type='method'><a href="geoprocessor.html#.tri">tri</a></li><li data-type='method'><a href="geoprocessor.html#.watershed">watershed</a></li></ul></li><li><a href="GeoTIFFDataSource.html">GeoTIFFDataSource</a><ul class='methods'><li data-type='method'><a href="GeoTIFFDataSource.html#extractFromZip">extractFromZip</a></li><li data-type='method'><a href="GeoTIFFDataSource.html#getGeoTIFFGrid">getGeoTIFFGrid</a></li><li data-type='method'><a href="GeoTIFFDataSource.html#getGeoTIFFValueAtPoint">getGeoTIFFValueAtPoint</a></li><li data-type='method'><a href="GeoTIFFDataSource.html#parseGeoTIFF">parseGeoTIFF</a></li></ul></li><li><a href="GRIB2DataSource.html">GRIB2DataSource</a><ul class='methods'><li data-type='method'><a href="GRIB2DataSource.html#findGRIB2Message">findGRIB2Message</a></li><li data-type='method'><a href="GRIB2DataSource.html#getGRIB2Grid">getGRIB2Grid</a></li><li data-type='method'><a href="GRIB2DataSource.html#getGRIB2ValueAtPoint">getGRIB2ValueAtPoint</a></li><li data-type='method'><a href="GRIB2DataSource.html#parseGRIB2">parseGRIB2</a></li></ul></li><li><a href="GRIB2Integration.html">GRIB2Integration</a><ul class='methods'><li data-type='method'><a href="GRIB2Integration.html#applySpatialSubsetting">applySpatialSubsetting</a></li><li data-type='method'><a href="GRIB2Integration.html#extractGRIB2Data">extractGRIB2Data</a></li><li data-type='method'><a href="GRIB2Integration.html#parseGRIB2Buffer">parseGRIB2Buffer</a></li></ul></li><li><a href="GriddedDataSource.html">GriddedDataSource</a><ul class='methods'><li data-type='method'><a href="GriddedDataSource.html#aggregateSpatially">aggregateSpatially</a></li><li data-type='method'><a href="GriddedDataSource.html#aggregateTemporally">aggregateTemporally</a></li><li data-type='method'><a href="GriddedDataSource.html#applyScaling">applyScaling</a></li><li data-type='method'><a href="GriddedDataSource.html#buildURL">buildURL</a></li><li data-type='method'><a href="GriddedDataSource.html#decompress">decompress</a></li><li data-type='method'><a href="GriddedDataSource.html#extractGridTimeSeries">extractGridTimeSeries</a></li><li data-type='method'><a href="GriddedDataSource.html#extractMultiplePoints">extractMultiplePoints</a></li><li data-type='method'><a href="GriddedDataSource.html#extractPointData">extractPointData</a></li><li data-type='method'><a href="GriddedDataSource.html#extractTimeSeries">extractTimeSeries</a></li><li data-type='method'><a href="GriddedDataSource.html#fetch">fetch</a></li><li data-type='method'><a href="GriddedDataSource.html#fetchJSON">fetchJSON</a></li><li data-type='method'><a href="GriddedDataSource.html#findNearestIndex">findNearestIndex</a></li><li data-type='method'><a href="GriddedDataSource.html#formatTimestamp">formatTimestamp</a></li><li data-type='method'><a href="GriddedDataSource.html#handleError">handleError</a></li><li data-type='method'><a href="GriddedDataSource.html#loadLibrary">loadLibrary</a></li><li data-type='method'><a href="GriddedDataSource.html#toCSV">toCSV</a></li><li data-type='method'><a href="GriddedDataSource.html#toNetCDF">toNetCDF</a></li><li data-type='method'><a href="GriddedDataSource.html#validateCoordinates">validateCoordinates</a></li></ul></li><li><a href="HLclearCreek.html">HLclearCreek</a><ul class='methods'><li data-type='method'><a href="HLclearCreek.html#.additionalData">additionalData</a></li><li data-type='method'><a href="HLclearCreek.html#.dataStep">dataStep</a></li><li data-type='method'><a href="HLclearCreek.html#.get_time_step">get_time_step</a></li><li data-type='method'><a href="HLclearCreek.html#.get_value_at_indices">get_value_at_indices</a></li><li data-type='method'><a href="HLclearCreek.html#.retrieveData">retrieveData</a></li><li data-type='method'><a href="HLclearCreek.html#.retrieveGauge">retrieveGauge</a></li><li data-type='method'><a href="HLclearCreek.html#.spreadGauge">spreadGauge</a></li><li data-type='method'><a href="HLclearCreek.html#.spreadResults">spreadResults</a></li><li data-type='method'><a href="HLclearCreek.html#.update">update</a></li><li data-type='method'><a href="HLclearCreek.html#.update_until">update_until</a></li><li data-type='method'><a href="HLclearCreek.html#rainID">rainID</a></li></ul></li><li><a href="HRRRDataSource.html">HRRRDataSource</a><ul class='methods'><li data-type='method'><a href="HRRRDataSource.html#extractGridData">extractGridData</a></li><li data-type='method'><a href="HRRRDataSource.html#extractPointData">extractPointData</a></li><li data-type='method'><a href="HRRRDataSource.html#fetch">fetch</a></li><li data-type='method'><a href="HRRRDataSource.html#findProductForVariable">findProductForVariable</a></li><li data-type='method'><a href="HRRRDataSource.html#generateURL">generateURL</a></li><li data-type='method'><a href="HRRRDataSource.html#getDatasetInfo">getDatasetInfo</a></li><li data-type='method'><a href="HRRRDataSource.html#processFile">processFile</a></li></ul></li><li><a href="hydro.html">hydro</a><ul class='methods'><li data-type='method'><a href="hydro.html#.analyzeCollectionofEvents">analyzeCollectionofEvents</a></li><li data-type='method'><a href="hydro.html#.analyzeEvent">analyzeEvent</a></li><li data-type='method'><a href="hydro.html#.arithmetic">arithmetic</a></li><li data-type='method'><a href="hydro.html#.bucketmodel">bucketmodel</a></li><li data-type='method'><a href="hydro.html#.calculate_tds">calculate_tds</a></li><li data-type='method'><a href="hydro.html#.calculate_tss">calculate_tss</a></li><li data-type='method'><a href="hydro.html#.calculateDOSaturation">calculateDOSaturation</a></li><li data-type='method'><a href="hydro.html#.calculatepH">calculatepH</a></li><li data-type='method'><a href="hydro.html#.calculatePrecipitationMinMax">calculatePrecipitationMinMax</a></li><li data-type='method'><a href="hydro.html#.calibratePH">calibratePH</a></li><li data-type='method'><a href="hydro.html#.compensateORP">compensateORP</a></li><li data-type='method'><a href="hydro.html#.convertTemperature">convertTemperature</a></li><li data-type='method'><a href="hydro.html#.convertTurbidity">convertTurbidity</a></li><li data-type='method'><a href="hydro.html#.darcysLaw">darcysLaw</a></li><li data-type='method'><a href="hydro.html#.detectPrecipEvents">detectPrecipEvents</a></li><li data-type='method'><a href="hydro.html#.dimunithydro">dimunithydro</a></li><li data-type='method'><a href="hydro.html#.dissolvedOxygenDemand">dissolvedOxygenDemand</a></li><li data-type='method'><a href="hydro.html#.dynamicGround1D">dynamicGround1D</a></li><li data-type='method'><a href="hydro.html#.equationsystemsolver">equationsystemsolver</a></li><li data-type='method'><a href="hydro.html#.ETBlaneyCriddle">ETBlaneyCriddle</a></li><li data-type='method'><a href="hydro.html#.ETHargreaves">ETHargreaves</a></li><li data-type='method'><a href="hydro.html#.ETPenmanMontheith">ETPenmanMontheith</a></li><li data-type='method'><a href="hydro.html#.ETPriestelyTaylor">ETPriestelyTaylor</a></li><li data-type='method'><a href="hydro.html#.ETThornthwaite">ETThornthwaite</a></li><li data-type='method'><a href="hydro.html#.floodhydro">floodhydro</a></li><li data-type='method'><a href="hydro.html#.floodhydro">floodhydro</a></li><li data-type='method'><a href="hydro.html#.generateSyntheticValue">generateSyntheticValue</a></li><li data-type='method'><a href="hydro.html#.getJulianDay">getJulianDay</a></li><li data-type='method'><a href="hydro.html#.hyetogen">hyetogen</a></li><li data-type='method'><a href="hydro.html#.InfGreenAmpt">InfGreenAmpt</a></li><li data-type='method'><a href="hydro.html#.InfHorton">InfHorton</a></li><li data-type='method'><a href="hydro.html#.InfKostiakov">InfKostiakov</a></li><li data-type='method'><a href="hydro.html#.InfPhilip">InfPhilip</a></li><li data-type='method'><a href="hydro.html#.InfSmithParlange">InfSmithParlange</a></li><li data-type='method'><a href="hydro.html#.inverseDistanceWeighting">inverseDistanceWeighting</a></li><li data-type='method'><a href="hydro.html#.kinematicWaveRouting">kinematicWaveRouting</a></li><li data-type='method'><a href="hydro.html#.lagAndRoute">lagAndRoute</a></li><li data-type='method'><a href="hydro.html#.matrix">matrix</a></li><li data-type='method'><a href="hydro.html#.move">move</a></li><li data-type='method'><a href="hydro.html#.muskingumCunge">muskingumCunge</a></li><li data-type='method'><a href="hydro.html#.precipitationFrequencyAnalysis">precipitationFrequencyAnalysis</a></li><li data-type='method'><a href="hydro.html#.rainaggr">rainaggr</a></li><li data-type='method'><a href="hydro.html#.rainfallErosivityIndex">rainfallErosivityIndex</a></li><li data-type='method'><a href="hydro.html#.rainfallIntensityDurationFrequency">rainfallIntensityDurationFrequency</a></li><li data-type='method'><a href="hydro.html#.rainfallInterceptionModel">rainfallInterceptionModel</a></li><li data-type='method'><a href="hydro.html#.rainfallThresholdAnalysis">rainfallThresholdAnalysis</a></li><li data-type='method'><a href="hydro.html#.stageDischarge">stageDischarge</a></li><li data-type='method'><a href="hydro.html#.staticGround1d">staticGround1d</a></li><li data-type='method'><a href="hydro.html#.stochasticRainfallGeneration">stochasticRainfallGeneration</a></li><li data-type='method'><a href="hydro.html#.syntheticalc">syntheticalc</a></li><li data-type='method'><a href="hydro.html#.thiessen">thiessen</a></li><li data-type='method'><a href="hydro.html#.timeAreaMethod">timeAreaMethod</a></li><li data-type='method'><a href="hydro.html#.totalprec">totalprec</a></li><li data-type='method'><a href="hydro.html#.unithydrocons">unithydrocons</a></li></ul></li><li><a href="HydroBMI.BMI.html">BMI</a></li><li><a href="HydroLangBMI.html">HydroLangBMI</a><ul class='methods'><li data-type='method'><a href="HydroLangBMI.html#.dataTypes">dataTypes</a></li><li data-type='method'><a href="HydroLangBMI.html#.finalize">finalize</a></li><li data-type='method'><a href="HydroLangBMI.html#.generateOutputs">generateOutputs</a></li><li data-type='method'><a href="HydroLangBMI.html#.get_component_name">get_component_name</a></li><li data-type='method'><a href="HydroLangBMI.html#.get_current_time">get_current_time</a></li><li data-type='method'><a href="HydroLangBMI.html#.get_end_time">get_end_time</a></li><li data-type='method'><a href="HydroLangBMI.html#.get_grid_edge_count">get_grid_edge_count</a></li><li data-type='method'><a href="HydroLangBMI.html#.get_grid_edge_nodes">get_grid_edge_nodes</a></li><li data-type='method'><a href="HydroLangBMI.html#.get_grid_face_count">get_grid_face_count</a></li><li data-type='method'><a href="HydroLangBMI.html#.get_grid_face_nodes">get_grid_face_nodes</a></li><li data-type='method'><a href="HydroLangBMI.html#.get_grid_face_nodes">get_grid_face_nodes</a></li><li data-type='method'><a href="HydroLangBMI.html#.get_grid_node_count">get_grid_node_count</a></li><li data-type='method'><a href="HydroLangBMI.html#.get_grid_nodes_per_face">get_grid_nodes_per_face</a></li><li data-type='method'><a href="HydroLangBMI.html#.get_grid_origin">get_grid_origin</a></li><li data-type='method'><a href="HydroLangBMI.html#.get_grid_shape">get_grid_shape</a></li><li data-type='method'><a href="HydroLangBMI.html#.get_grid_size">get_grid_size</a></li><li data-type='method'><a href="HydroLangBMI.html#.get_grid_size">get_grid_size</a></li><li data-type='method'><a href="HydroLangBMI.html#.get_grid_spacing">get_grid_spacing</a></li><li data-type='method'><a href="HydroLangBMI.html#.get_grid_type">get_grid_type</a></li><li data-type='method'><a href="HydroLangBMI.html#.get_grid_x">get_grid_x</a></li><li data-type='method'><a href="HydroLangBMI.html#.get_grid_y">get_grid_y</a></li><li data-type='method'><a href="HydroLangBMI.html#.get_grid_z">get_grid_z</a></li><li data-type='method'><a href="HydroLangBMI.html#.get_input_item_count">get_input_item_count</a></li><li data-type='method'><a href="HydroLangBMI.html#.get_time_step">get_time_step</a></li><li data-type='method'><a href="HydroLangBMI.html#.get_time_units">get_time_units</a></li><li data-type='method'><a href="HydroLangBMI.html#.get_value_at_indices">get_value_at_indices</a></li><li data-type='method'><a href="HydroLangBMI.html#.get_value_ptr">get_value_ptr</a></li><li data-type='method'><a href="HydroLangBMI.html#.get_var_type">get_var_type</a></li><li data-type='method'><a href="HydroLangBMI.html#.handleConfig">handleConfig</a></li><li data-type='method'><a href="HydroLangBMI.html#.initialize">initialize</a></li><li data-type='method'><a href="HydroLangBMI.html#.set_value">set_value</a></li><li data-type='method'><a href="HydroLangBMI.html#.set_value_at_indices">set_value_at_indices</a></li><li data-type='method'><a href="HydroLangBMI.html#.update">update</a></li><li data-type='method'><a href="HydroLangBMI.html#.update_until">update_until</a></li><li data-type='method'><a href="HydroLangBMI.html#.visualizer">visualizer</a></li></ul></li><li><a href="HydroLangCache.html">HydroLangCache</a></li><li><a href="HydroLangGRIB2Parser.html">HydroLangGRIB2Parser</a><ul class='methods'><li data-type='method'><a href="HydroLangGRIB2Parser.html#applyScanningMode">applyScanningMode</a></li><li data-type='method'><a href="HydroLangGRIB2Parser.html#calculateGridBounds">calculateGridBounds</a></li><li data-type='method'><a href="HydroLangGRIB2Parser.html#convertTo2DGrid">convertTo2DGrid</a></li><li data-type='method'><a href="HydroLangGRIB2Parser.html#createGridMetadataResponse">createGridMetadataResponse</a></li><li data-type='method'><a href="HydroLangGRIB2Parser.html#extractGRIBMetadataOnly">extractGRIBMetadataOnly</a></li><li data-type='method'><a href="HydroLangGRIB2Parser.html#extractParsedData">extractParsedData</a></li><li data-type='method'><a href="HydroLangGRIB2Parser.html#extractParsedData">extractParsedData</a></li><li data-type='method'><a href="HydroLangGRIB2Parser.html#generateBasicCoordinates">generateBasicCoordinates</a></li><li data-type='method'><a href="HydroLangGRIB2Parser.html#generateCoordinates">generateCoordinates</a></li><li data-type='method'><a href="HydroLangGRIB2Parser.html#generateCoordinatesFromParsedData">generateCoordinatesFromParsedData</a></li><li data-type='method'><a href="HydroLangGRIB2Parser.html#getFullGridBounds">getFullGridBounds</a></li><li data-type='method'><a href="HydroLangGRIB2Parser.html#getFullGridBounds">getFullGridBounds</a></li><li data-type='method'><a href="HydroLangGRIB2Parser.html#getParameterDescriptionFromData">getParameterDescriptionFromData</a></li><li data-type='method'><a href="HydroLangGRIB2Parser.html#getParameterDescriptionFromData">getParameterDescriptionFromData</a></li><li data-type='method'><a href="HydroLangGRIB2Parser.html#getParameterDescriptionFromParsedData">getParameterDescriptionFromParsedData</a></li><li data-type='method'><a href="HydroLangGRIB2Parser.html#getParameterFromData">getParameterFromData</a></li><li data-type='method'><a href="HydroLangGRIB2Parser.html#getParameterFromData">getParameterFromData</a></li><li data-type='method'><a href="HydroLangGRIB2Parser.html#getParameterFromParsedData">getParameterFromParsedData</a></li><li data-type='method'><a href="HydroLangGRIB2Parser.html#getParameterName">getParameterName</a></li><li data-type='method'><a href="HydroLangGRIB2Parser.html#getParameterNameFromData">getParameterNameFromData</a></li><li data-type='method'><a href="HydroLangGRIB2Parser.html#getParameterNameFromData">getParameterNameFromData</a></li><li data-type='method'><a href="HydroLangGRIB2Parser.html#getParameterNameFromParsedData">getParameterNameFromParsedData</a></li><li data-type='method'><a href="HydroLangGRIB2Parser.html#getUnitsFromData">getUnitsFromData</a></li><li data-type='method'><a href="HydroLangGRIB2Parser.html#getUnitsFromData">getUnitsFromData</a></li><li data-type='method'><a href="HydroLangGRIB2Parser.html#getUnitsFromParsedData">getUnitsFromParsedData</a></li><li data-type='method'><a href="HydroLangGRIB2Parser.html#getVariableFromMessage">getVariableFromMessage</a></li><li data-type='method'><a href="HydroLangGRIB2Parser.html#parseBuffer">parseBuffer</a></li><li data-type='method'><a href="HydroLangGRIB2Parser.html#parseBuffer">parseBuffer</a></li><li data-type='method'><a href="HydroLangGRIB2Parser.html#parseBufferStreaming">parseBufferStreaming</a></li><li data-type='method'><a href="HydroLangGRIB2Parser.html#parseGRIBHeaders">parseGRIBHeaders</a></li><li data-type='method'><a href="HydroLangGRIB2Parser.html#parseGridSection">parseGridSection</a></li><li data-type='method'><a href="HydroLangGRIB2Parser.html#parseProductSection">parseProductSection</a></li></ul></li><li><a href="map.html">map</a><ul class='methods'><li data-type='method'><a href="map.html#.addGeoRasterLayer">addGeoRasterLayer</a></li><li data-type='method'><a href="map.html#.addMarker">addMarker</a></li><li data-type='method'><a href="map.html#.addPopup">addPopup</a></li><li data-type='method'><a href="map.html#.draw">draw</a></li><li data-type='method'><a href="map.html#.generateColors">generateColors</a></li><li data-type='method'><a href="map.html#.geoJSON">geoJSON</a></li><li data-type='method'><a href="map.html#.kml">kml</a></li><li data-type='method'><a href="map.html#.Layers">Layers</a></li><li data-type='method'><a href="map.html#.loader">loader</a></li><li data-type='method'><a href="map.html#.markerStyles">markerStyles</a></li><li data-type='method'><a href="map.html#.renderMap">renderMap</a></li></ul></li><li><a href="ModelProxy.html">ModelProxy</a><ul class='methods'><li data-type='method'><a href="ModelProxy.html#.dispose">dispose</a></li><li data-type='method'><a href="ModelProxy.html#.predict">predict</a></li><li data-type='method'><a href="ModelProxy.html#.save">save</a></li><li data-type='method'><a href="ModelProxy.html#.train">train</a></li></ul></li><li><a href="MRMSDataSource.html">MRMSDataSource</a><ul class='methods'><li data-type='method'><a href="MRMSDataSource.html#extractGridData">extractGridData</a></li><li data-type='method'><a href="MRMSDataSource.html#extractPointData">extractPointData</a></li><li data-type='method'><a href="MRMSDataSource.html#fetch">fetch</a></li><li data-type='method'><a href="MRMSDataSource.html#findProductForVariable">findProductForVariable</a></li><li data-type='method'><a href="MRMSDataSource.html#generateURL">generateURL</a></li><li data-type='method'><a href="MRMSDataSource.html#getDatasetInfo">getDatasetInfo</a></li><li data-type='method'><a href="MRMSDataSource.html#inferVariableFromProduct">inferVariableFromProduct</a></li><li data-type='method'><a href="MRMSDataSource.html#loadDatasource">loadDatasource</a></li><li data-type='method'><a href="MRMSDataSource.html#processFile">processFile</a></li></ul></li><li><a href="NetCDFDataSource.html">NetCDFDataSource</a><ul class='methods'><li data-type='method'><a href="NetCDFDataSource.html#getNetCDFSlice">getNetCDFSlice</a></li><li data-type='method'><a href="NetCDFDataSource.html#getNetCDFValue">getNetCDFValue</a></li><li data-type='method'><a href="NetCDFDataSource.html#getNetCDFVariable">getNetCDFVariable</a></li><li data-type='method'><a href="NetCDFDataSource.html#openNetCDF">openNetCDF</a></li></ul></li><li><a href="NLDASDataSource.html">NLDASDataSource</a><ul class='methods'><li data-type='method'><a href="NLDASDataSource.html#extractDayData">extractDayData</a></li><li data-type='method'><a href="NLDASDataSource.html#extractGridData">extractGridData</a></li><li data-type='method'><a href="NLDASDataSource.html#extractPointData">extractPointData</a></li><li data-type='method'><a href="NLDASDataSource.html#extractRawNetCDF">extractRawNetCDF</a></li><li data-type='method'><a href="NLDASDataSource.html#generateFileURL">generateFileURL</a></li></ul></li><li><a href="nn.html">nn</a><ul class='methods'><li data-type='method'><a href="nn.html#.createModel">createModel</a></li><li data-type='method'><a href="nn.html#.loadModel">loadModel</a></li></ul></li><li><a href="nnUtils.html">nnUtils</a></li><li><a href="NWMDataSource.html">NWMDataSource</a><ul class='methods'><li data-type='method'><a href="NWMDataSource.html#buildFileURL">buildFileURL</a></li><li data-type='method'><a href="NWMDataSource.html#convertToTypedArray">convertToTypedArray</a></li><li data-type='method'><a href="NWMDataSource.html#extractData">extractData</a></li><li data-type='method'><a href="NWMDataSource.html#extractNetCDFData">extractNetCDFData</a></li><li data-type='method'><a href="NWMDataSource.html#extractZarrData">extractZarrData</a></li><li data-type='method'><a href="NWMDataSource.html#findCOMIDIndex">findCOMIDIndex</a></li><li data-type='method'><a href="NWMDataSource.html#getDatasetInfo">getDatasetInfo</a></li></ul></li><li><a href="PRISMDataSource.html">PRISMDataSource</a><ul class='methods'><li data-type='method'><a href="PRISMDataSource.html#determinePRISMParams">determinePRISMParams</a></li><li data-type='method'><a href="PRISMDataSource.html#extractGridData">extractGridData</a></li><li data-type='method'><a href="PRISMDataSource.html#extractPointData">extractPointData</a></li><li data-type='method'><a href="PRISMDataSource.html#fetchAndExtractPRISM">fetchAndExtractPRISM</a></li><li data-type='method'><a href="PRISMDataSource.html#generateFileURL">generateFileURL</a></li></ul></li><li><a href="stats.html">stats</a><ul class='methods'><li data-type='method'><a href="stats.html#.andersonDarling">andersonDarling</a></li><li data-type='method'><a href="stats.html#.anova">anova</a></li><li data-type='method'><a href="stats.html#.arrchange">arrchange</a></li><li data-type='method'><a href="stats.html#.autoCorrelation">autoCorrelation</a></li><li data-type='method'><a href="stats.html#.autocovarianceMatrix">autocovarianceMatrix</a></li><li data-type='method'><a href="stats.html#.basicstats">basicstats</a></li><li data-type='method'><a href="stats.html#.bernoulliDist">bernoulliDist</a></li><li data-type='method'><a href="stats.html#.betaDist">betaDist</a></li><li data-type='method'><a href="stats.html#.binomialCoefficient">binomialCoefficient</a></li><li data-type='method'><a href="stats.html#.binomialDist">binomialDist</a></li><li data-type='method'><a href="stats.html#.bootstrap">bootstrap</a></li><li data-type='method'><a href="stats.html#.breuschPaganTest">breuschPaganTest</a></li><li data-type='method'><a href="stats.html#.chisqCDF">chisqCDF</a></li><li data-type='method'><a href="stats.html#.cleaner">cleaner</a></li><li data-type='method'><a href="stats.html#.computeD">computeD</a></li><li data-type='method'><a href="stats.html#.copydata">copydata</a></li><li data-type='method'><a href="stats.html#.correlation">correlation</a></li><li data-type='method'><a href="stats.html#.datagaps">datagaps</a></li><li data-type='method'><a href="stats.html#.dateparser">dateparser</a></li><li data-type='method'><a href="stats.html#.differencing">differencing</a></li><li data-type='method'><a href="stats.html#.dotProduct">dotProduct</a></li><li data-type='method'><a href="stats.html#.efficiencies">efficiencies</a></li><li data-type='method'><a href="stats.html#.errorMetrics">errorMetrics</a></li><li data-type='method'><a href="stats.html#.exponentialDist">exponentialDist</a></li><li data-type='method'><a href="stats.html#.exponentialMovingAverage">exponentialMovingAverage</a></li><li data-type='method'><a href="stats.html#.fastfourier">fastfourier</a></li><li data-type='method'><a href="stats.html#.flatenise">flatenise</a></li><li data-type='method'><a href="stats.html#.forwardFill">forwardFill</a></li><li data-type='method'><a href="stats.html#.frequency">frequency</a></li><li data-type='method'><a href="stats.html#.fTest">fTest</a></li><li data-type='method'><a href="stats.html#.gammaCDFApprox">gammaCDFApprox</a></li><li data-type='method'><a href="stats.html#.gammaDist">gammaDist</a></li><li data-type='method'><a href="stats.html#.gapfiller">gapfiller</a></li><li data-type='method'><a href="stats.html#.gapremoval">gapremoval</a></li><li data-type='method'><a href="stats.html#.gaussianDist">gaussianDist</a></li><li data-type='method'><a href="stats.html#.generateRandomData">generateRandomData</a></li><li data-type='method'><a href="stats.html#.geometricDist">geometricDist</a></li><li data-type='method'><a href="stats.html#.getNextState">getNextState</a></li><li data-type='method'><a href="stats.html#.gevDistribution">gevDistribution</a></li><li data-type='method'><a href="stats.html#.gumbelDist">gumbelDist</a></li><li data-type='method'><a href="stats.html#.interoutliers">interoutliers</a></li><li data-type='method'><a href="stats.html#.itemfilter">itemfilter</a></li><li data-type='method'><a href="stats.html#.joinarray">joinarray</a></li><li data-type='method'><a href="stats.html#.KS_computePValue">KS_computePValue</a></li><li data-type='method'><a href="stats.html#.KS_rejectAtAlpha">KS_rejectAtAlpha</a></li><li data-type='method'><a href="stats.html#.kurtosis">kurtosis</a></li><li data-type='method'><a href="stats.html#.linearMovingAverage">linearMovingAverage</a></li><li data-type='method'><a href="stats.html#.lognormalDist">lognormalDist</a></li><li data-type='method'><a href="stats.html#.LogSeriesDistribution">LogSeriesDistribution</a></li><li data-type='method'><a href="stats.html#.mannWhitney">mannWhitney</a></li><li data-type='method'><a href="stats.html#.matrixInverse">matrixInverse</a></li><li data-type='method'><a href="stats.html#.max">max</a></li><li data-type='method'><a href="stats.html#.mean">mean</a></li><li data-type='method'><a href="stats.html#.median">median</a></li><li data-type='method'><a href="stats.html#.min">min</a></li><li data-type='method'><a href="stats.html#.MK">MK</a></li><li data-type='method'><a href="stats.html#.multinomialDistribution">multinomialDistribution</a></li><li data-type='method'><a href="stats.html#.multiplyMatrix">multiplyMatrix</a></li><li data-type='method'><a href="stats.html#.multiregression">multiregression</a></li><li data-type='method'><a href="stats.html#.normalcdf">normalcdf</a></li><li data-type='method'><a href="stats.html#.normalDistribution">normalDistribution</a></li><li data-type='method'><a href="stats.html#.normoutliers">normoutliers</a></li><li data-type='method'><a href="stats.html#.numerise">numerise</a></li><li data-type='method'><a href="stats.html#.onearray">onearray</a></li><li data-type='method'><a href="stats.html#.outremove">outremove</a></li><li data-type='method'><a href="stats.html#.partialAutoCorrelation">partialAutoCorrelation</a></li><li data-type='method'><a href="stats.html#.poissonProcess">poissonProcess</a></li><li data-type='method'><a href="stats.html#.push">push</a></li><li data-type='method'><a href="stats.html#.quantile">quantile</a></li><li data-type='method'><a href="stats.html#.randomWalk">randomWalk</a></li><li data-type='method'><a href="stats.html#.range">range</a></li><li data-type='method'><a href="stats.html#.regression">regression</a></li><li data-type='method'><a href="stats.html#.residualVariance">residualVariance</a></li><li data-type='method'><a href="stats.html#.returnPeriod">returnPeriod</a></li><li data-type='method'><a href="stats.html#.runMarkovChainMonteCarlo">runMarkovChainMonteCarlo</a></li><li data-type='method'><a href="stats.html#.runMonteCarlo">runMonteCarlo</a></li><li data-type='method'><a href="stats.html#.runSimulation">runSimulation</a></li><li data-type='method'><a href="stats.html#.runVegas">runVegas</a></li><li data-type='method'><a href="stats.html#.seasonalDecompose">seasonalDecompose</a></li><li data-type='method'><a href="stats.html#.shapiroWilk">shapiroWilk</a></li><li data-type='method'><a href="stats.html#.simpleMovingAverage">simpleMovingAverage</a></li><li data-type='method'><a href="stats.html#.skewness">skewness</a></li><li data-type='method'><a href="stats.html#.spiCompute">spiCompute</a></li><li data-type='method'><a href="stats.html#.standardize">standardize</a></li><li data-type='method'><a href="stats.html#.stddev">stddev</a></li><li data-type='method'><a href="stats.html#.sum">sum</a></li><li data-type='method'><a href="stats.html#.sumsqrd">sumsqrd</a></li><li data-type='method'><a href="stats.html#.timegaps">timegaps</a></li><li data-type='method'><a href="stats.html#.transposeMatrix">transposeMatrix</a></li><li data-type='method'><a href="stats.html#.tTest">tTest</a></li><li data-type='method'><a href="stats.html#.uniformDist">uniformDist</a></li><li data-type='method'><a href="stats.html#.unique">unique</a></li><li data-type='method'><a href="stats.html#.variance">variance</a></li><li data-type='method'><a href="stats.html#.weibullDist">weibullDist</a></li><li data-type='method'><a href="stats.html#.wilcoxonSignedRank">wilcoxonSignedRank</a></li></ul></li><li><a href="visualize.html">visualize</a><ul class='methods'><li data-type='method'><a href="visualize.html#.chart">chart</a></li><li data-type='method'><a href="visualize.html#.draw">draw</a></li><li data-type='method'><a href="visualize.html#.drawHtmlTable">drawHtmlTable</a></li><li data-type='method'><a href="visualize.html#.generateReport">generateReport</a></li><li data-type='method'><a href="visualize.html#.prettyPrint">prettyPrint</a></li><li data-type='method'><a href="visualize.html#.table">table</a></li></ul></li><li><a href="ZarrDataSource.html">ZarrDataSource</a><ul class='methods'><li data-type='method'><a href="ZarrDataSource.html#getZarrArrayData">getZarrArrayData</a></li><li data-type='method'><a href="ZarrDataSource.html#getZarrChunk">getZarrChunk</a></li><li data-type='method'><a href="ZarrDataSource.html#getZarrRegion">getZarrRegion</a></li><li data-type='method'><a href="ZarrDataSource.html#getZarrSlice">getZarrSlice</a></li><li data-type='method'><a href="ZarrDataSource.html#getZarrValue">getZarrValue</a></li><li data-type='method'><a href="ZarrDataSource.html#openZarrArray">openZarrArray</a></li></ul></li></ul><h3>Modules</h3><ul><li><a href="module-analyze.html">analyze</a><ul class='methods'><li data-type='method'><a href="module-analyze.html#loadFloodDM">loadFloodDM</a></li></ul></li><li><a href="module-mapsources.html">mapsources</a></li></ul><h3>Externals</h3><ul><li><a href="external-D3.html">D3</a></li><li><a href="external-GeospatialLoader.html">GeospatialLoader</a></li><li><a href="external-GoogleCharts.html">GoogleCharts</a></li><li><a href="external-googlemapsapi.html">googlemapsapi</a></li><li><a href="external-GriddedData.html">GriddedData</a></li><li><a href="external-HDF5Loader.html">HDF5Loader</a></li><li><a href="external-leafletosmapi.html">leafletosmapi</a></li><li><a href="external-NetCDFLoader.html">NetCDFLoader</a></li><li><a href="external-tensorflow.html">tensorflow</a></li><li><a href="external-tileprov.html">tileprov</a></li><li><a href="external-ZarritaLoader.html">ZarritaLoader</a></li></ul><h3>Namespaces</h3><ul><li><a href="data.cache.html">cache</a><ul class='methods'><li data-type='method'><a href="data.cache.html#.checkCache">checkCache</a></li><li data-type='method'><a href="data.cache.html#.clear">clear</a></li><li data-type='method'><a href="data.cache.html#.delete">delete</a></li><li data-type='method'><a href="data.cache.html#.getStats">getStats</a></li><li data-type='method'><a href="data.cache.html#.list">list</a></li></ul></li><li><a href="datasources.html">datasources</a><ul class='members'><li data-type='method'><a href="datasources.html#.AEMET">AEMET</a></li><li data-type='method'><a href="datasources.html#.AORC">AORC</a></li><li data-type='method'><a href="datasources.html#.BMKG">BMKG</a></li><li data-type='method'><a href="datasources.html#.CHIRPS">CHIRPS</a></li><li data-type='method'><a href="datasources.html#.ClearCreek">ClearCreek</a></li><li data-type='method'><a href="datasources.html#.CMA">CMA</a></li><li data-type='method'><a href="datasources.html#.CPTEC">CPTEC</a></li><li data-type='method'><a href="datasources.html#.3DEP">3DEP</a></li><li data-type='method'><a href="datasources.html#.DWD">DWD</a></li><li data-type='method'><a href="datasources.html#.EAUK">EAUK</a></li><li data-type='method'><a href="datasources.html#.ECMWF">ECMWF</a></li><li data-type='method'><a href="datasources.html#.EPA">EPA</a></li><li data-type='method'><a href="datasources.html#.FAO">FAO</a></li><li data-type='method'><a href="datasources.html#.FEMA">FEMA</a></li><li data-type='method'><a href="datasources.html#.flooddamage_dt">flooddamage_dt</a></li><li data-type='method'><a href="datasources.html#.FMI">FMI</a></li><li data-type='method'><a href="datasources.html#.HRRR">HRRR</a></li><li data-type='method'><a href="datasources.html#.HydroGeospatial">HydroGeospatial</a></li><li data-type='method'><a href="datasources.html#.IDEAM">IDEAM</a></li><li data-type='method'><a href="datasources.html#.IFIS">IFIS</a></li><li data-type='method'><a href="datasources.html#.IMD">IMD</a></li><li data-type='method'><a href="datasources.html#.ISRIC">ISRIC</a></li><li data-type='method'><a href="datasources.html#.JMA">JMA</a></li><li data-type='method'><a href="datasources.html#.KMA">KMA</a></li><li data-type='method'><a href="datasources.html#.KNMI">KNMI</a></li><li data-type='method'><a href="datasources.html#.MeteoFrance">MeteoFrance</a></li><li data-type='method'><a href="datasources.html#.MeteoIT">MeteoIT</a></li><li data-type='method'><a href="datasources.html#.MeteoSTAT">MeteoSTAT</a></li><li data-type='method'><a href="datasources.html#.MetNo">MetNo</a></li><li data-type='method'><a href="datasources.html#.mitigation_dt">mitigation_dt</a></li><li data-type='method'><a href="datasources.html#.MRMS">MRMS</a></li><li data-type='method'><a href="datasources.html#.NASAPOWER">NASAPOWER</a></li><li data-type='method'><a href="datasources.html#.NHDPlus">NHDPlus</a></li><li data-type='method'><a href="datasources.html#.NLDAS">NLDAS</a></li><li data-type='method'><a href="datasources.html#.NLDI">NLDI</a></li><li data-type='method'><a href="datasources.html#.NOAA">NOAA</a></li><li data-type='method'><a href="datasources.html#.NWM">NWM</a></li><li data-type='method'><a href="datasources.html#.NWPS">NWPS</a></li><li data-type='method'><a href="datasources.html#.NWS">NWS</a></li><li data-type='method'><a href="datasources.html#.OpenMeteo">OpenMeteo</a></li><li data-type='method'><a href="datasources.html#.PRISM">PRISM</a></li><li data-type='method'><a href="datasources.html#.ProxyServers">ProxyServers</a></li><li data-type='method'><a href="datasources.html#.SILO">SILO</a></li><li data-type='method'><a href="datasources.html#.SISSA">SISSA</a></li><li data-type='method'><a href="datasources.html#.SMHI">SMHI</a></li><li data-type='method'><a href="datasources.html#.SMN">SMN</a></li><li data-type='method'><a href="datasources.html#.soapEnv">soapEnv</a></li><li data-type='method'><a href="datasources.html#.TAMSAT">TAMSAT</a></li><li data-type='method'><a href="datasources.html#.TMD">TMD</a></li><li data-type='method'><a href="datasources.html#.USGS">USGS</a></li><li data-type='method'><a href="datasources.html#.USGS">USGS</a></li><li data-type='method'><a href="datasources.html#.WBD">WBD</a></li><li data-type='method'><a href="datasources.html#.Worldbank">Worldbank</a></li><li data-type='method'><a href="datasources.html#.WQP">WQP</a></li></ul></li><li><a href="datasources.CUAHSI.html">CUAHSI</a><ul class='members'><li data-type='method'><a href="datasources.CUAHSI.html#.hisCentral">hisCentral</a></li><li data-type='method'><a href="datasources.CUAHSI.html#.hydroShare">hydroShare</a></li><li data-type='method'><a href="datasources.CUAHSI.html#.waterOneFlow">waterOneFlow</a></li></ul></li><li><a href="HydroBMI.html">HydroBMI</a><ul class='members'><li data-type='method'><a href="HydroBMI.html#.BMIConfig">BMIConfig</a></li></ul></li><li><a href="HydroBMI.Hydro.html">Hydro</a></li><li><a href="Hydrolang.html">Hydrolang</a></li></ul><h3>Global</h3><ul><li><a href="global.html#_openGDALSource">_openGDALSource</a></li><li><a href="global.html#addCustomLegend">addCustomLegend</a></li><li><a href="global.html#aggregateSpatial">aggregateSpatial</a></li><li><a href="global.html#aggregateTemporal">aggregateTemporal</a></li><li><a href="global.html#aggregateTime">aggregateTime</a></li><li><a href="global.html#algebra">algebra</a></li><li><a href="global.html#applyDataScaling">applyDataScaling</a></li><li><a href="global.html#applyQualityControl">applyQualityControl</a></li><li><a href="global.html#applyScalingToValue">applyScalingToValue</a></li><li><a href="global.html#aspect">aspect</a></li><li><a href="global.html#bandMath">bandMath</a></li><li><a href="global.html#cacheAPI">cacheAPI</a></li><li><a href="global.html#cachedFetch">cachedFetch</a></li><li><a href="global.html#calculateStatistics">calculateStatistics</a></li><li><a href="global.html#clip">clip</a></li><li><a href="global.html#clipGeo">clipGeo</a></li><li><a href="global.html#constructNWMFileURL">constructNWMFileURL</a></li><li><a href="global.html#convertAORCToCSV">convertAORCToCSV</a></li><li><a href="global.html#convertAORCToNetCDF">convertAORCToNetCDF</a></li><li><a href="global.html#convertDataUnits">convertDataUnits</a></li><li><a href="global.html#convertGeoTIFFToGeoraster">convertGeoTIFFToGeoraster</a></li><li><a href="global.html#convertNWMToCSV">convertNWMToCSV</a></li><li><a href="global.html#convertToArray">convertToArray</a></li><li><a href="global.html#convertToCSV">convertToCSV</a></li><li><a href="global.html#convertToNetCDF">convertToNetCDF</a></li><li><a href="global.html#createGoogleMapsGeoRasterLayer">createGoogleMapsGeoRasterLayer</a></li><li><a href="global.html#createLeafletCanvasGeoRasterLayer">createLeafletCanvasGeoRasterLayer</a></li><li><a href="global.html#createLeafletGeoRasterLayer">createLeafletGeoRasterLayer</a></li><li><a href="global.html#createSegmentationModel">createSegmentationModel</a></li><li><a href="global.html#createSimpleGeoRasterOverlay">createSimpleGeoRasterOverlay</a></li><li><a href="global.html#createStore">createStore</a></li><li><a href="global.html#createTransformer">createTransformer</a></li><li><a href="global.html#createZarrStore">createZarrStore</a></li><li><a href="global.html#decompressGzip">decompressGzip</a></li><li><a href="global.html#detectFormat">detectFormat</a></li><li><a href="global.html#determinePRISMRegion">determinePRISMRegion</a></li><li><a href="global.html#downloadERA5File">downloadERA5File</a></li><li><a href="global.html#drawHtmlTable">drawHtmlTable</a></li><li><a href="global.html#execute">execute</a></li><li><a href="global.html#expandSpatialBounds">expandSpatialBounds</a></li><li><a href="global.html#extractERA5Data">extractERA5Data</a></li><li><a href="global.html#extractERA5GridData">extractERA5GridData</a></li><li><a href="global.html#extractERA5PointData">extractERA5PointData</a></li><li><a href="global.html#extractERA5TimeSeries">extractERA5TimeSeries</a></li><li><a href="global.html#extractGRIB2Data">extractGRIB2Data</a></li><li><a href="global.html#extractHRRRGridData">extractHRRRGridData</a></li><li><a href="global.html#extractHRRRPointData">extractHRRRPointData</a></li><li><a href="global.html#extractHRRRTimeSeries">extractHRRRTimeSeries</a></li><li><a href="global.html#extractMRMSGridData">extractMRMSGridData</a></li><li><a href="global.html#extractMRMSPointData">extractMRMSPointData</a></li><li><a href="global.html#extractMRMSTimeSeries">extractMRMSTimeSeries</a></li><li><a href="global.html#extractNLDASGridData">extractNLDASGridData</a></li><li><a href="global.html#extractNLDASMultiplePoints">extractNLDASMultiplePoints</a></li><li><a href="global.html#extractNLDASPointData">extractNLDASPointData</a></li><li><a href="global.html#extractNLDASRawNetCDF">extractNLDASRawNetCDF</a></li><li><a href="global.html#extractNWMData">extractNWMData</a></li><li><a href="global.html#extractPRISMGridData">extractPRISMGridData</a></li><li><a href="global.html#extractPRISMPointData">extractPRISMPointData</a></li><li><a href="global.html#extractPRISMTimeSeries">extractPRISMTimeSeries</a></li><li><a href="global.html#fetchDEMData">fetchDEMData</a></li><li><a href="global.html#fetchPointElevation">fetchPointElevation</a></li><li><a href="global.html#fillSinks">fillSinks</a></li><li><a href="global.html#flattenND">flattenND</a></li><li><a href="global.html#formatAORCOutput">formatAORCOutput</a></li><li><a href="global.html#formatData">formatData</a></li><li><a href="global.html#formatNWMOutput">formatNWMOutput</a></li><li><a href="global.html#formatPRISMTimePeriod">formatPRISMTimePeriod</a></li><li><a href="global.html#generateNWMDateRange">generateNWMDateRange</a></li><li><a href="global.html#generatePRISMFileURL">generatePRISMFileURL</a></li><li><a href="global.html#generateProcessedDataKey">generateProcessedDataKey</a></li><li><a href="global.html#generateSimpleCacheKey">generateSimpleCacheKey</a></li><li><a href="global.html#getArrayData">getArrayData</a></li><li><a href="global.html#getAvailableERA5Variables">getAvailableERA5Variables</a></li><li><a href="global.html#getAvailableHRRRVariables">getAvailableHRRRVariables</a></li><li><a href="global.html#getAvailableMRMSProducts">getAvailableMRMSProducts</a></li><li><a href="global.html#getAvailableNLDASVariables">getAvailableNLDASVariables</a></li><li><a href="global.html#getAvailablePRISMVariables">getAvailablePRISMVariables</a></li><li><a href="global.html#getChunk">getChunk</a></li><li><a href="global.html#getFile">getFile</a></li><li><a href="global.html#getGridDataLibrary">getGridDataLibrary</a></li><li><a href="global.html#getHRRRDatasetInfo">getHRRRDatasetInfo</a></li><li><a href="global.html#getInfo">getInfo</a></li><li><a href="global.html#getLeafletColorForElevation">getLeafletColorForElevation</a></li><li><a href="global.html#getMap">getMap</a></li><li><a href="global.html#getMRMSDatasetInfo">getMRMSDatasetInfo</a></li><li><a href="global.html#getNLDASDatasetInfo">getNLDASDatasetInfo</a></li><li><a href="global.html#getNWMTemporalInfo">getNWMTemporalInfo</a></li><li><a href="global.html#getPRISMDatasetInfo">getPRISMDatasetInfo</a></li><li><a href="global.html#getRecommendedPRISMResolution">getRecommendedPRISMResolution</a></li><li><a href="global.html#getRegion">getRegion</a></li><li><a href="global.html#goldfeldQuandtTest">goldfeldQuandtTest</a></li><li><a href="global.html#GRIDDED_SOURCES">GRIDDED_SOURCES</a></li><li><a href="global.html#gridToTensor">gridToTensor</a></li><li><a href="global.html#hillshade">hillshade</a></li><li><a href="global.html#imgToTensor">imgToTensor</a></li><li><a href="global.html#info">info</a></li><li><a href="global.html#isGridDataLibraryLoaded">isGridDataLibraryLoaded</a></li><li><a href="global.html#isLoaded">isLoaded</a></li><li><a href="global.html#isValidBoundingBox">isValidBoundingBox</a></li><li><a href="global.html#isValidCoordinate">isValidCoordinate</a></li><li><a href="global.html#load">load</a></li><li><a href="global.html#loadGeoRasterLayerPlugin">loadGeoRasterLayerPlugin</a></li><li><a href="global.html#loadGeoTIFFFromBuffer">loadGeoTIFFFromBuffer</a></li><li><a href="global.html#loadGridDataLibrary">loadGridDataLibrary</a></li><li><a href="global.html#mapPixels">mapPixels</a></li><li><a href="global.html#mask">mask</a></li><li><a href="global.html#modelRegistry">modelRegistry</a></li><li><a href="global.html#openArray">openArray</a></li><li><a href="global.html#parseGRIB2">parseGRIB2</a></li><li><a href="global.html#pca">pca</a></li><li><a href="global.html#pollECMWFStatus">pollECMWFStatus</a></li><li><a href="global.html#preprocess">preprocess</a></li><li><a href="global.html#preprocessData">preprocessData</a></li><li><a href="global.html#processAORCBulkExtraction">processAORCBulkExtraction</a></li><li><a href="global.html#processAORCDatasetInfo">processAORCDatasetInfo</a></li><li><a href="global.html#processAORCGridData">processAORCGridData</a></li><li><a href="global.html#processAORCPointData">processAORCPointData</a></li><li><a href="global.html#processAORCTimeSeriesData">processAORCTimeSeriesData</a></li><li><a href="global.html#processERA5GRIB2Data">processERA5GRIB2Data</a></li><li><a href="global.html#processFileInChunks">processFileInChunks</a></li><li><a href="global.html#processGriddedSource">processGriddedSource</a></li><li><a href="global.html#processNWMBulkExtraction">processNWMBulkExtraction</a></li><li><a href="global.html#readGRIB2Chunked">readGRIB2Chunked</a></li><li><a href="global.html#readNetCDFChunked">readNetCDFChunked</a></li><li><a href="global.html#recenter">recenter</a></li><li><a href="global.html#reproject">reproject</a></li><li><a href="global.html#saveFile">saveFile</a></li><li><a href="global.html#seriesToTensor">seriesToTensor</a></li><li><a href="global.html#slope">slope</a></li><li><a href="global.html#sourceType">sourceType</a></li><li><a href="global.html#streamExtract">streamExtract</a></li><li><a href="global.html#testMRMSUrlGeneration">testMRMSUrlGeneration</a></li><li><a href="global.html#tile">tile</a></li><li><a href="global.html#transformVariable">transformVariable</a></li><li><a href="global.html#validate3DEPParams">validate3DEPParams</a></li><li><a href="global.html#validateERA5Config">validateERA5Config</a></li><li><a href="global.html#validateHRRRConfig">validateHRRRConfig</a></li><li><a href="global.html#validateMRMSConfig">validateMRMSConfig</a></li><li><a href="global.html#validateNLDASConfig">validateNLDASConfig</a></li><li><a href="global.html#validatePRISMConfig">validatePRISMConfig</a></li><li><a href="global.html#validatePRISMVariable">validatePRISMVariable</a></li><li><a href="global.html#vectorize">vectorize</a></li><li><a href="global.html#whitesTest">whitesTest</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">modules/data/data.js</h1>
    
    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import * as datasources from "./datasources.js";
import stats from "../analyze/components/stats.js";
import { cachedFetch } from "./utils/data-cache.js";
import {
  GRIDDED_SOURCES,
  processGriddedSource,
  applyDataScaling,
  convertDataUnits,
  aggregateTemporal,
  applyQualityControl,
  calculateStatistics,
  formatData,
  loadGridDataLibrary,
} from "./utils/index.js";

//import fxparserMin from "./fxparser.min.js";

//import XMLParser from './fxparser.min.js'
//import  {XMLParser} from "./fxparser.min.js";

//Workaround for DOM manipulation using a web worker environment


// 'https://cdnjs.cloudflare.com/ajax/libs/fast-xml-parser/4.5.1/fxparser.min.js'

/**
 * Module for dealing with data retrieval, transformation, upload, and download operations.
 * Provides functions to interact with various hydrological data sources and perform data operations.
 * @class 
 * @name data
 */

/**
 * Main function to retrieve data from various hydrological data sources.
 * Supports multiple data sources including USGS, NLDI, NWS, and others.
 * 
 * @function retrieve
 * @memberof data
 * @async
 * @param {Object} options - Configuration object for data retrieval
 * @param {Object} options.params - Parameters for the request
 * @param {string} options.params.source - Data source identifier (e.g., 'usgs', 'nldi', 'nws')
 * @param {string} options.params.datatype - Type of data to retrieve (varies by source)
 * @param {string} [options.params.type] - Response format ('json', 'xml', 'csv', 'soap') - defaults to source's default
 * @param {boolean} [options.params.transform] - Whether to apply data transformation
 * @param {boolean} [options.params.placeHolder] - Whether to use placeholder data
 * @param {string} [options.params.keyname] - API key parameter name for authenticated sources
 * @param {Object} options.args - Arguments specific to the data source endpoint
 * @param {Object} [options.data] - Additional data payload (for POST requests)
 * @returns {Promise&lt;Object|string>} Promise resolving to retrieved data in specified format
 * 
 * @example
 * // Retrieve USGS instantaneous streamflow data
 * const streamflowData = await hydro.data.retrieve({
 *   params: {
 *     source: 'usgs',
 *     datatype: 'instant-values',
 *     transform: true
 *   },
 *   args: {
 *     format: 'json',
 *     sites: '05454500',
 *     startDT: '2020-01-01',
 *     endDT: '2020-01-07'
 *   }
 * });
 * 
 * @example
 * // Retrieve NLDI basin boundary data
 * const basinData = await hydro.data.retrieve({
 *   params: {
 *     source: 'nldi',
 *     datatype: 'getBasin'
 *   },
 *   args: {
 *     featureSource: 'comid',
 *     featureId: '13297246'
 *   }
 * });
 * 
 * @example
 * // Retrieve NASA POWER meteorological data
 * const powerData = await hydro.data.retrieve({
 *   params: {
 *     source: 'nasapower',
 *     datatype: 'point-data'
 *   },
 *   args: {
 *     parameters: 'T2M,PRECTOTCORR,RH2M',
 *     community: 're',
 *     longitude: -76.3,
 *     latitude: 38.5,
 *     start: '20200101',
 *     end: '20200131',
 *     format: 'JSON'
 *   }
 * });
 * 
 * @example
 * // Retrieve NOAA climate data with API key
 * const climateData = await hydro.data.retrieve({
 *   params: {
 *     source: 'noaa',
 *     datatype: 'prec-15min',
 *     token: 'YOUR_NOAA_TOKEN'
 *   },
 *   args: {
 *     datasetid: 'PRECIP_15',
 *     stationid: 'GHCND:USW00014895',
 *     startdate: '2020-01-01',
 *     enddate: '2020-01-07',
 *     limit: 100
 *   }
 * });
 * 
 * @example
 * // Retrieve Meteostat weather station data
 * const meteoData = await hydro.data.retrieve({
 *   params: {
 *     source: 'meteostat',
 *     datatype: 'dailydata-station',
 *     'x-rapidapi-key': 'YOUR_RAPIDAPI_KEY'
 *   },
 *   args: {
 *     station: '10382',
 *     start: '2020-01-01',
 *     end: '2020-01-31'
 *   }
 * });
 * 
 * @example
 * // Retrieve EPA precipitation data (POST request)
 * const epaData = await hydro.data.retrieve({
 *   params: {
 *     source: 'epa',
 *     datatype: 'precipitation',
 *     type: 'json'
 *   },
 *   args: {
 *     source: 'nldas',
 *     dateTimeSpan: {
 *       startDate: '2020-01-01 00',
 *       endDate: '2020-01-07 00',
 *       dateTimeFormat: 'yyyy-MM-dd HH'
 *     },
 *     geometry: {
 *       point: {
 *         latitude: 33.925,
 *         longitude: -83.356
 *       }
 *     },
 *     dataValueFormat: 'E3',
 *     temporalResolution: 'hourly',
 *     units: 'metric'
 *   }
 * });
 * 
 * @example
 * // Retrieve flood damage scenario data
 * const floodData = await hydro.data.retrieve({
 *   params: {
 *     source: 'flooddamage_dt',
 *     datatype: 'x500_year',
 *     transform: 'eval'
 *   },
 *   args: {
 *     sourceType: 'Cedar Rapids'
 *   }
 * });
 */

async function retrieve({ params, args, data } = {}) {

  let source = params.source;
  let dataType = params.datatype;
  let placeHolder = params.placeHolder || false;
  let trans = params.transform || false;

  try {
    // Check if this is a gridded data source
    const griddedConfig = GRIDDED_SOURCES[source];
    if (griddedConfig) {
      // Run preprocessing if needed (e.g., NLDI lookup for NWM)
      if (griddedConfig.preProcess) {
        const result = await griddedConfig.preProcess(params, args, dataType);
        args = result.args;
      }

      // Use the new generic processor (pass datasources, not params)
      // Pass process flag if present
      if (params.process !== true) {
        args.process = false;
      }
      return processGriddedSource(source, dataType, args, datasources);
    }

    // Resolve source configuration robustly (handling named vs default exports)
    // Resolve source configuration robustly (handling named vs default exports)
    //const sourceModule = datasources[source] || (datasources.default ? datasources.default[source] : undefined);

    // Safety check for wrapped modules (nested default)
    // We unwrap .default until we find a likely configuration object (has 'datasets' or 'sourceType')
    // We need to find the object that actually HAS the sourceType function.
    let sourceModule = datasources[source];

    // Check main object, then .default, then .default.default using a helper
    const findConfig = (obj) => {
      if (!obj) return null;
      if (typeof obj.sourceType === 'function') return obj;
      if (obj.default) return findConfig(obj.default);
      // Fallback for objects that might have datasets but sourceType is on global export
      if (obj.datasets) return obj;
      // Fallback for standard datasources (like usgs, nws) that have requirements and info
      if (obj.requirements &amp;&amp; obj.info) return obj;
      return null;
    };

    // Try finding it starting from datasources[source]
    let sourceConfig = findConfig(datasources[source]);

    // If not found, try starting from datasources.default (if it exists)
    if (!sourceConfig &amp;&amp; datasources.default) {
      sourceConfig = findConfig(datasources.default[source]);
    }

    // For other datasources, check if they exist
    // Use the resolved sourceConfig to check for the dataType
    // sourceConfig might be the datasource object itself (like usgs.js default export)
    // or it might be the module namespace
    let dataSource;
    if (sourceConfig) {
      dataSource = sourceConfig[dataType];
      // If not found directly, it might be in datasets (for gridded sources masquerading as direct, like chirps/ecmwf)
      if (!dataSource &amp;&amp; sourceConfig.datasets) {
        dataSource = sourceConfig.datasets[dataType];
      }
    }

    if (!dataSource &amp;&amp; !sourceConfig &amp;&amp; !GRIDDED_SOURCES[source]) {
      return Promise.reject(new Error(`No data source found for source '${source}' and type '${dataType}'.`));
    }

    // Fallback if we have sourceConfig but couldn't resolve specific dataSource yet
    // (This happens for dynamic sources like chirps/ecmwf where methods are looked up later or custom logic used)
    if (!dataSource &amp;&amp; (source === 'chirps' || source === 'ecmwf' || source === 'dwd' || source === 'nldas')) {
      // Create dummy dataSource to pass the check, endpoint calculation handles it later
      dataSource = { methods: { type: 'json' } };
    }

    if (!dataSource) {
      return Promise.reject(new Error(`No configuration found for source '${source}' and datatype '${dataType}'.`));
    }

    let endpoint =
      source === "waterOneFlow" || source === "hisCentral" || source === "mitigation_dt" || source === "flooddamage_dt" || source === "nldas" || source === "dwd" || source === "chirps" || source === "ecmwf"
        ? (source === "nldas" ? sourceConfig.sourceType(args.dataset, dataType, args) : (source === "dwd" || source === "chirps" || source === "ecmwf" ? sourceConfig.sourceType(args, dataType) : sourceConfig.sourceType(args.sourceType, dataType)))
        : dataSource.endpoint;

    if (!endpoint) {
      throw new Error(`Endpoint resolution failed for source '${source}'. sourceType returned null or undefined.`);
    }

    let type = params.type || dataSource.methods.type;

    // Check if proxy is needed based on datasource requirements
    // Use the robust sourceConfig resolved earlier, not datasources[source] which might be undefined for default exports
    let proxy = "";
    const needsProxy = (sourceConfig.requirements &amp;&amp; sourceConfig.requirements.needProxy) ||
      (datasources[source] &amp;&amp; datasources[source].requirements &amp;&amp; datasources[source].requirements.needProxy);

    if (needsProxy) {
      // Use specified proxy or default to researchverse
      const proxyName = params.proxyServer || "local-proxy";

      const proxiesContainer = datasources.proxies || (datasources.default &amp;&amp; datasources.default.proxies);

      if (!proxiesContainer) {
        throw new Error("Proxies configuration not found in datasources.");
      }

      console.log(`[Proxy Debug] Requested: ${proxyName}`);
      console.log(`[Proxy Debug] Available: ${Object.keys(proxiesContainer).join(', ')}`);

      proxy = proxiesContainer[proxyName]?.endpoint || proxiesContainer["local-proxy"].endpoint;
      console.log(`[Proxy Debug] Resolved: ${proxy}`);
    }

    let headers = {
      "content-type": (() => {
        if (type === "json") {
          return "application/json";
        } else if (type === "xml" || type === "soap") {
          return "text/xml; charset=utf-8";
        } else if (type === "csv" || type === "tab") {
          return "application/text";
        } else if (type === "netcdf" || type === "tiff" || type === "image" || type === "blob" || type === "binary") {
          // If we are POSTing to get a binary file (like ECMWF), we usually send JSON params.
          if (dataSource.methods.method === 'POST') {
            return "application/json";
          }
          return "application/octet-stream";
        } else {
          return "application/json"; // Default
        }
      })(),
    };

    if (type === "soap") {
      headers["SOAPAction"] = datasources.default[source]?.action + dataType;
    }

    let keyname = sourceConfig.requirements?.keyname || datasources[source]?.requirements?.keyname;
    if (keyname &amp;&amp; params[keyname]) {
      headers[keyname] = params[keyname];
    } else if (keyname) {
      console.warn("info: please verify the keyname of the source.");
    }

    endpoint = endpoint.replace(/{(\w+)}/g, (match, key) => {
      const value = args[key];
      delete args[key];
      return value;
    });


    let fetchOptions = {
      method: dataSource.methods.method || 'GET',
      headers: headers,
    };

    if (fetchOptions.method === 'POST') {
      if (type === 'json' || type === 'binary') {
        // If content-type is json, stringify args
        if (headers['content-type'] &amp;&amp; headers['content-type'].includes('application/json')) {
          fetchOptions.body = JSON.stringify(args);
        } else {
          // Fallback if binary but not json header (unlikely given logic above)
          fetchOptions.body = JSON.stringify(args);
        }
      } else if (type === 'soap' || type === 'xml') {
        fetchOptions.body = Object.keys(args).length
          ? datasources.default.envelope(dataSource.body(args))
          : datasources.default.envelope(dataSource.body());
      }
    } else if (fetchOptions.method === 'GET') {
      // Merge preset parameters from datasource with user-provided args
      // Start with preset params from datasource definition
      const mergedParams = {};

      if (dataSource.params) {
        // Add all preset parameters that have non-null values
        for (const [key, value] of Object.entries(dataSource.params)) {
          if (value !== null &amp;&amp; value !== undefined) {
            mergedParams[key] = value;
          }
        }

        // Override with user-provided args (for params that were null)
        for (const [key, value] of Object.entries(args)) {
          if (value !== null &amp;&amp; value !== undefined) {
            mergedParams[key] = value;
          }
        }
      } else {
        // If no preset params, just use args as before
        Object.assign(mergedParams, args);
      }

      // Only add query string if we have parameters
      if (Object.keys(mergedParams).length > 0) {
        const queryString = new URLSearchParams(mergedParams).toString();
        endpoint += `?${queryString}`;
      }
    }


    // Determine whether to use cache
    // Cache is DISABLED by default - must explicitly opt-in with cache: true
    let globalCache = false;
    if (typeof window !== 'undefined' &amp;&amp; window.hydroConfig &amp;&amp; window.hydroConfig.cache !== undefined) {
      globalCache = window.hydroConfig.cache;
    }
    const useCache = params.cache === true || globalCache === true;

    // Execute Request
    const executeRequest = useCache ? cachedFetch : fetch;

    return executeRequest(proxy + endpoint, fetchOptions)
      .then(async (response) => {
        // DEBUG: Log raw response
        if (typeof response.clone === 'function') {
          const clone = response.clone();
          try {
            const text = await clone.text();
            console.log(`[Retrieve Debug] Raw response from ${proxy + endpoint}:`, text.substring(0, 500)); // Log first 500 chars
          } catch (err) {
            console.log(`[Retrieve Debug] Failed to read raw response:`, err);
          }
        } else {
          console.log(`[Retrieve Debug] Response from ${proxy + endpoint} is not a standard Response object (no clone method).`);
        }

        // Handle non-Response objects (ArrayBuffer from cachedFetch)
        if (typeof response.text !== 'function') {
          if (response instanceof ArrayBuffer || response.byteLength !== undefined) {
            const text = new TextDecoder().decode(response);
            // If we expect JSON, try to parse it
            if (params.datatype === 'json' || dataSource.methods.type === 'json') {
              return JSON.parse(text);
            }
            return text;
          }
          return response;
        }

        // Check if response is a valid Response object (it might be raw data from cache)
        const isResponseObj = response &amp;&amp; typeof response.ok !== 'undefined' &amp;&amp; typeof response.headers !== 'undefined';

        if (!isResponseObj) {
          // It's raw data (likely ArrayBuffer/Blob from cache)
          if (type === 'json' &amp;&amp; typeof response === 'string') {
            try { return JSON.parse(response); } catch (e) { return response; }
          }
          // Wrap raw data if specific binary type requested
          if (['blob', 'netcdf', 'grib2', 'tiff', 'image'].includes(type)) {
            return new Blob([response]);
          }
          return response;
        }

        if (!response.ok) {
          const errorData = await response.text();
          throw new Error(`HTTP error ${response.status} fetching ${endpoint}: ${errorData}`);
        }

        // If process is not explicitly true, return raw text or blob based on content type
        if (params.process !== true) {
          const contentType = response.headers.get('content-type');
          if (contentType &amp;&amp; (contentType.includes('application/json') || contentType.includes('text/'))) {
            return response.text();
          } else {
            return response.blob();
          }
        }

        // Logic for handling response types
        // Priority: 1. User specified type, 2. Datasource default type, 3. Content-Type detection
        let targetType = type || dataSource.methods.type || 'unknown';

        // Force blob for known binary types
        if (['netcdf', 'grib2', 'tiff', 'image', 'blob', 'zip', 'tar', 'kmz', 'zarr', 'binary'].includes(targetType)) {
          if (typeof response.blob === 'function') {
            return response.blob();
          } else if (typeof response.arrayBuffer === 'function') {
            return response.arrayBuffer().then(buf => new Blob([buf]));
          }
          return new Blob([response]); // Fallback
        }

        if (targetType === 'json') {
          // Safety check: if content indicates binary/image preventing JSON parse error
          const ct = response.headers.get('content-type');
          if (ct &amp;&amp; (ct.includes('image/') || ct.includes('application/octet-stream') || ct.includes('application/x-tar') || ct.includes('application/zip'))) {
            if (typeof response.blob === 'function') return response.blob();
            return response.arrayBuffer().then(buf => new Blob([buf]));
          }
          return response.json();
        }

        if (['xml', 'soap', 'csv', 'tab', 'kml'].includes(targetType)) {
          return response.text();
        }

        // Dynamic detection if type is unknown or generic
        const contentType = response.headers.get('content-type') || '';
        if (contentType.includes('application/json')) {
          return response.json();
        } else if (contentType.includes('text/') || contentType.includes('xml') || contentType.includes('application/vnd.google-earth.kml+xml')) {
          return response.text();
        } else {
          // Default to blob for anything else (likely binary) to avoid JSON parse errors
          return response.blob();
        }
      })
      .then((responseData) => {
        // If process is not explicitly true, return raw data
        if (params.process !== true) {
          return responseData;
        }

        if (type === "soap") {
          try {
            //DOM Parser workaround
            // const parser = new DOMParser();
            // const xmlDoc = parser.parseFromString(responseData, "text/xml");

            // const parser = new XMLParser();
            // console.log(parser)
            // const xmlDoc = parser.parse(responseData);

            return responseData

            //let j = xml2json(xmlDoc);
            // return xmlDoc["soap:Envelope"]?.["soap:Body"] || j; // Handle cases where soap:Body might not exist
          } catch (xmlError) {
            throw new Error(`Error parsing SOAP response from ${endpoint}: ${xmlError.message}`);
          }
        } else if (type === "xml" || type === "tab" || type === "CSV") {
          return JSON.stringify(responseData);
        } else if (trans) {
          if (source === "usgs") {
            return transform({
              params: { save: 'value' },
              args: { keep: '["datetime", "value"]', type: 'ARR' },
              data: lowercasing(responseData)
            });
          } else if (trans === "eval") {
            return eval(responseData); // Use eval cautiously
          }
        } else {
          return lowercasing(responseData);
        }
      });
  } finally {
    // Context will be cleaned up by next request or kept for subsequent calls
    // Don't delete here - cachedFetch needs it for caching
  }
}


/**
 * Get a raw cached file for manual processing
 * @param {Object} params - Parameters object
 * @param {string} params.source - Data source
 * @param {string} params.datatype - Data type
 * @param {Object} args - Arguments object
 * @param {string} args.key - Cache key to retrieve
 * @param {Object} data - Data object (unused)
 * @returns {Promise&lt;Object>} Raw file data and metadata
 */
async function getFile({ params, args, data } = {}) {
  const cache = globalThis.hydro?.cache;
  if (!cache) {
    throw new Error('Cache not available');
  }

  const key = args.key;
  if (!key) {
    throw new Error('Cache key required in args.key');
  }

  const cached = await cache.get(key);
  if (!cached) {
    throw new Error(`No cached file found with key: ${key}`);
  }

  return {
    data: cached.data,
    metadata: cached.metadata,
    key: key,
    raw: true
  };
}

/**
 * Save processed data with a user-defined key
 * @param {Object} params - Parameters object
 * @param {string} params.source - Data source
 * @param {string} params.datatype - Data type
 * @param {Object} args - Arguments object
 * @param {string} args.key - User-defined key for the dataset
 * @param {string} args.name - Optional human-readable name
 * @param {Object} data - Data object to save
 * @returns {Promise&lt;boolean>} Success status
 */
async function saveFile({ params, args, data } = {}) {
  const cache = globalThis.hydro?.cache;
  if (!cache) {
    throw new Error('Cache not available');
  }

  const key = args.key;
  if (!key) {
    throw new Error('Dataset key required in args.key');
  }

  if (!data) {
    throw new Error('Data to save is required');
  }

  const metadata = {
    source: params.source || 'user',
    datatype: params.datatype || 'dataset',
    name: args.name || key,
    savedAt: new Date().toISOString(),
    userSaved: true
  };

  return await cache.saveDataset(key, data, metadata);
}





/**
 * Transform AORC (NOAA Analysis of Record for Calibration) data with comprehensive manipulation capabilities
 * Handles scaling, unit conversion, temporal/spatial aggregation, and various output formats
 *
 * @function transformAORCData
 * @memberof data
 * @param {Object} options - Configuration object for AORC transformation
 * @param {Object} [options.params] - Parameters for transformation type
 * @param {Object} [options.args] - Arguments for transformation options
 * @param {Object|Array} options.data - AORC data to transform
 * @returns {Object|Array|string} Transformed AORC data
 */
const transformGriddedData = ({ params, args, data }) => {
  console.log('[transform] Processing gridded data transformation');

  // Detect data source and apply appropriate transformations
  const source = params?.source || 'generic';

  // Detect if this is a single variable or multi-variable dataset
  const isMultiVariable = data &amp;&amp; typeof data === 'object' &amp;&amp; !data.variable &amp;&amp; !Array.isArray(data);

  if (isMultiVariable) {
    // Handle multiple variables
    const results = {};
    for (const [variableName, variableData] of Object.entries(data)) {
      try {
        results[variableName] = transformVariable(variableName, variableData, source, params, args);
      } catch (error) {
        console.warn(`Failed to transform ${variableName}: ${error.message}`);
        results[variableName] = { error: error.message };
      }
    }
    return results;
  } else {
    // Handle single variable
    const variableName = data.variable || Object.keys(data)[0];
    return transformVariable(variableName, data, source, params, args);
  }
};

/**
 * Transform a single gridded data variable with comprehensive manipulations
 */
const transformVariable = (variableName, variableData, source, params, args) => {
  let processedData = deepClone(variableData);

  // Apply source-specific scaling
  if (source === 'aorc') {
    processedData = applyDataScaling(processedData, variableName, datasources, 'aorc');
  } else if (source === 'nwm') {
    processedData = applyDataScaling(processedData, variableName, datasources, 'nwm');
  } else if (source === 'threedep') {
    processedData = applyDataScaling(processedData, variableName, datasources, 'threedep');
  } else if (source === 'prism') {
    processedData = applyDataScaling(processedData, variableName, datasources, 'prism');
  }

  // Apply unit conversions if requested
  if (args?.units) {
    processedData = convertDataUnits(processedData, variableName, args.units, source, datasources);
  }

  // Apply temporal aggregations
  if (args?.temporalAggregation) {
    processedData = aggregateTemporal(processedData, args.temporalAggregation);
  }

  // Apply spatial aggregations
  if (args?.spatialAggregation) {
    processedData = aggregateSpatial(processedData, args.spatialAggregation);
  }

  // Apply quality control filters
  if (args?.qualityControl) {
    processedData = applyQualityControl(processedData, args.qualityControl);
  }

  // Apply statistical transformations
  if (args?.statistics) {
    processedData = calculateStatistics(processedData, args.statistics);
  }

  // Apply format transformations
  if (args?.type) {
    return formatData(processedData, args, source, datasources);
  }

  return processedData;
};





/**
 * Convert data types into various formats based on JavaScript objects as primary input.
 * Supports extraction of nested data, filtering, and format conversion.
 * 
 * @function transform
 * @memberof data
 * @param {Object} options - Configuration object for transformation
 * @param {Object} [options.params] - Parameters for data extraction and saving
 * @param {string} [options.params.save] - Key name to search for and extract from nested objects
 * @param {string} [options.params.output] - Output variable name (currently unused)
 * @param {Object} [options.args] - Arguments for transformation options
 * @param {string} [options.args.type] - Output format: 'ARR', 'ARR-col', 'CSV', 'JSON', 'XML2JSON'
 * @param {string[]|string} [options.args.keep] - Array of column headers to keep (JSON string or array)
 * @param {boolean} [options.args.parse] - Whether to parse strings to numbers/dates/booleans
 * @param {string} [options.args.mode] - Processing mode: 'flatten', 'flatten-objects'
 * @param {number} [options.args.pick] - Pick specific row index from 2D array
 * @param {boolean} [options.args.attachNames=true] - Whether to attach column names to arrays
 * @param {Object|Array} options.data - Input data object to be transformed
 * @returns {Object|Array|string} Transformed data in the specified format
 * 
 * @example
 * // Extract specific data from nested object and convert to array
 * const arrayData = hydro.data.transform({
 *   params: { save: 'timeSeries' },
 *   args: { 
 *     keep: ['dateTime', 'value'], 
 *     type: 'ARR',
 *     parse: true 
 *   },
 *   data: usgsResponseData
 * });
 * 
 * @example
 * // Convert object array to CSV format
 * const csvData = hydro.data.transform({
 *   args: { type: 'CSV' },
 *   data: [
 *     { date: '2023-01-01', flow: 100.5 },
 *     { date: '2023-01-02', flow: 95.3 }
 *   ]
 * });
 * 
 * @example
 * // Flatten nested object structure
 * const flattenedData = hydro.data.transform({
 *   args: { mode: 'flatten-objects' },
 *   data: {
 *     station: {
 *       info: { name: 'USGS Station', id: '01646500' },
 *       data: { flow: 100.5, stage: 2.1 }
 *     }
 *   }
 * });
 * // Result: { 'station.info.name': 'USGS Station', 'station.info.id': '01646500', ... }
 * 
 * @example
 * // Extract specific columns as separate arrays
 * const columnArrays = hydro.data.transform({
 *   args: { 
 *     type: 'ARR-col',
 *     keep: ['dateTime', 'value'],
 *     attachNames: false
 *   },
 *   data: [
 *     { dateTime: '2023-01-01', value: 100.5, quality: 'A' },
 *     { dateTime: '2023-01-02', value: 95.3, quality: 'A' }
 *   ]
 * });
 * // Result: [['2023-01-01', '2023-01-02'], [100.5, 95.3]]
 * 
 * @example
 * // Convert XML string to JSON
 * const jsonData = hydro.data.transform({
 *   args: { type: 'XML2JSON' },
 *   data: '&lt;root>&lt;item>value1&lt;/item>&lt;item>value2&lt;/item>&lt;/root>'
 * });
 * 
 * @example
 * // Pick specific row from 2D array and flatten
 * const singleRow = hydro.data.transform({
 *   args: { 
 *     pick: 0, 
 *     mode: 'flatten' 
 *   },
 *   data: [
 *     ['dates', '2023-01-01', '2023-01-02'],
 *     ['values', 100.5, 95.3]
 *   ]
 * });
 * // Result: [100.5, 95.3] (numeric values from first row, excluding header)
 */
function transform({ params, args, data } = {}) {
  function deepClone(value) {
    if (value === null || typeof value !== 'object') return value;
    if (value instanceof Date) return new Date(value.getTime());
    if (Array.isArray(value)) return value.map(deepClone);
    const result = {};
    for (const key in value) {
      if (Object.prototype.hasOwnProperty.call(value, key)) {
        result[key] = deepClone(value[key]);
      }
    }
    return result;
  }

  const convertToNumberIfPossible = (value) => {
    if (typeof value === 'string' &amp;&amp; !isNaN(value) &amp;&amp; value.trim() !== '') {
      return Number(value);
    }
    return value;
  };

  const cleanData = (data) => {
    if (Array.isArray(data)) {
      return data.map(item => cleanData(item));
    } else if (typeof data === 'object' &amp;&amp; data !== null) {
      const cleaned = {};
      for (const key in data) {
        cleaned[key] = cleanData(data[key]);
      }
      return cleaned;
    } else {
      return convertToNumberIfPossible(data);
    }
  };

  const parseSpecialTypes = (value) => {
    if (typeof value === 'string') {
      const date = new Date(value);
      if (!isNaN(date.getTime())) return date;
      if (value.toLowerCase() === 'true' || value.toLowerCase() === 'false') {
        return value.toLowerCase() === 'true';
      }
    }
    return value;
  };

  const extractNestedValue = (obj, path) => {
    // Check for direct property match first (handles keys with dots like "site.name")
    if (obj &amp;&amp; typeof obj === 'object' &amp;&amp; Object.prototype.hasOwnProperty.call(obj, path)) {
      return obj[path];
    }
    return path.split('.').reduce((acc, key) => acc?.[key], obj);
  };

  const flattenObject = (obj, parentKey = '', result = {}) => {
    for (const key in obj) {
      const value = obj[key];
      const newKey = parentKey ? `${parentKey}.${key}` : key;
      if (typeof value === 'object' &amp;&amp; value !== null &amp;&amp; !Array.isArray(value)) {
        flattenObject(value, newKey, result);
      } else {
        result[newKey] = value;
      }
    }
    return result;
  };

  // Helper to parse 'keep' argument which can be JSON string, comma-separated string, or array
  const parseKeepArg = (keepArg) => {
    if (!keepArg) return [];
    if (Array.isArray(keepArg)) return keepArg;
    if (typeof keepArg === 'string') {
      try {
        return JSON.parse(keepArg);
      } catch (e) {
        // Fallback: assume comma-separated string
        return keepArg.split(',').map(k => k.trim()).filter(k => k);
      }
    }
    return [];
  };

  // === AORC-SPECIFIC HELPER FUNCTIONS ===
  const findNearestIndex = (coordSystem, targetValue) => {
    const { min, resolution } = coordSystem;
    const index = Math.round((targetValue - min) / resolution);
    return Math.max(0, Math.min(index, Math.floor((coordSystem.max - min) / resolution)));
  };

  const aggregateTime = (date, timeStep, direction) => {
    const dateObj = new Date(date);
    const hours = timeStep === '1D' ? 24 : parseInt(timeStep) || 1;

    if (direction === 'start') {
      const startOfPeriod = new Date(dateObj);
      startOfPeriod.setHours(Math.floor(dateObj.getHours() / hours) * hours, 0, 0, 0);
      return startOfPeriod.toISOString();
    } else {
      const endOfPeriod = new Date(dateObj);
      endOfPeriod.setHours(Math.ceil((dateObj.getHours() + 1) / hours) * hours, 0, 0, 0);
      return endOfPeriod.toISOString();
    }
  };



  // Start transforming
  console.log('[transform] Original input data:', data);
  data = deepClone(data);

  // === GRIDDED DATA TRANSFORMATIONS ===
  if (params?.source === 'aorc' || params?.source === 'nwm' || params?.source === 'threedep' || params?.source === 'prism' ||
    (data &amp;&amp; typeof data === 'object' &amp;&amp; data.variable)) {
    return transformGriddedData({ params, args, data });
  }

  // === PARAMS &amp; ARGS LOGIC ===
  if (!params) {
    data = args?.parse ? cleanData(data) : data;
  } else if (params.save !== undefined) {
    // Determine if we should perform iterative extraction on an array
    const isIterativeExtraction = Array.isArray(data) &amp;&amp; (
      // If save path has dots (nested) OR explicit instruction (could add flag later, for now infer from data type)
      // If the user wants to filter *elements* of an array matching a path
      params.save.includes('.') || args?.keep
    );

    if (isIterativeExtraction &amp;&amp; Array.isArray(data)) {
      // New logic: Map over the array and extract the 'save' path from each item
      // This is for cases like: data=[{site: {name: 'A'}}, {site: {name: 'B'}}], save='site.name' -> ['A', 'B']
      // OR data=[{val: {x: 1}}, {val: {x: 2}}], save='val', keep=['x'] -> [{x:1}, {x:2}]
      const extracted = data.map(item => extractNestedValue(item, params.save)).filter(val => val !== undefined);

      // If extraction yielded results, use them. If not (e.g. maybe save was meant to find a global key?), fall back.
      // But typically if input is array and we provided a path, we expect mapped results.
      if (extracted.length > 0) {
        data = extracted;
      } else {
        // Fallback to recursive search (original behavior)
        const found = recursiveSearch({ obj: data, searchkey: params.save });
        data = found?.[0] || data; // keep original if not found? or null? existing logic implied found[0]
      }
    } else {
      // Logic for single object input or non-iterative cases
      const hasDots = params.save.includes('.');

      if (hasDots) {
        const val = extractNestedValue(data, params.save);
        if (val !== undefined) data = val;
      } else {
        let found = recursiveSearch({ obj: data, searchkey: params.save });
        if (found &amp;&amp; found.length > 0) {
          data = found[0];
        } else {
          // Fallback: direct property access.
          const val = extractNestedValue(data, params.save);
          if (val !== undefined) data = val;
        }
      }
    }

    if (args?.parse &amp;&amp; data) {
      data = cleanData(data);
    }
  }

  // === SLICING ARRAY (e.g. remove headers) ===
  if (args?.slice !== undefined) {
    if (Array.isArray(data)) {
      // slice could be a number (start) or array [start, end]
      const sliceParams = Array.isArray(args.slice) ? args.slice : [args.slice];
      data = data.slice(...sliceParams);
    }
  }

  // === INNER SLICE (slice each sub-array) ===
  if (args?.innerSlice !== undefined) {
    if (Array.isArray(data)) {
      const sliceParams = Array.isArray(args.innerSlice) ? args.innerSlice : [args.innerSlice];
      data = data.map(item => {
        if (Array.isArray(item)) {
          return item.slice(...sliceParams);
        }
        return item;
      });
    }
  }

  // === PICKING A SPECIFIC ROW FROM 2D ARRAY ===
  if (args?.pick !== undefined) {
    if (Array.isArray(data) &amp;&amp; Array.isArray(data[0])) {
      const idx = Number(args.pick);
      if (!isNaN(idx) &amp;&amp; data.length > idx) {
        data = data[idx];
      }
    }
  }

  // === MODE HANDLING ===
  if (args?.mode === 'flatten') {
    if (Array.isArray(data) &amp;&amp; Array.isArray(data[0])) {
      if (typeof data[0][0] === 'string' &amp;&amp; data[0].length > 1) {
        return data[0].slice(1).map(convertToNumberIfPossible);
      }
    }
    if (Array.isArray(data)) {
      return data
        .map(convertToNumberIfPossible)
        .filter(val => typeof val === 'number' &amp;&amp; !isNaN(val));
    }
  }

  if (args?.mode === 'flatten-objects') {
    if (Array.isArray(data) &amp;&amp; typeof data[0] === 'object') {
      data = data.map(flattenObject);
    } else if (typeof data === 'object') {
      data = flattenObject(data);
    }
  }

  // === KEEP NESTED KEYS AFTER FLATTEN / EXTRACT ===
  // This handles both Array and Object data types for consistent nested key support
  if (args?.keep) {
    const keepPaths = parseKeepArg(args.keep);

    if (Array.isArray(data)) {
      data = data.map(item => {
        const extracted = {};
        for (const path of keepPaths) {
          // Use the full path as the key to ensure it matches 'args.keep' for later lookup
          // and to prevent collisions (e.g. site.id vs user.id)
          const value = extractNestedValue(item, path);

          if (value !== undefined) {
            extracted[path] = value;
          }
        }
        return extracted;
      });
    } else if (typeof data === 'object' &amp;&amp; data !== null) {
      const extracted = {};
      for (const path of keepPaths) {
        const value = extractNestedValue(data, path);
        if (value !== undefined) {
          extracted[path] = value;
        }
      }
      data = extracted;
    }
  }

  const type = args?.type;
  let arr;

  if (Array.isArray(data)) {
    arr = deepClone(data);
    // Previous "keep" logic here (lines 984-993) was deleting keys from arr based on regex again.
    // Since we already filtered above using correct logic, we don't need this block.
  }

  // === FORMAT TRANSFORMATIONS ===
  if (type === 'ARR') {
    if (!arr || !Array.isArray(arr)) {
      console.error('[transform] arr is undefined or not an array:', arr);
      return null;
    }

    // Determine the order of keys to extract
    // If args.keep is provided, use it to ensure order matches headers
    // Otherwise, use sorted keys from the first object to be deterministic
    let keys;
    if (args.keep &amp;&amp; Array.isArray(args.keep)) {
      keys = args.keep;
    } else if (arr.length > 0) {
      keys = Object.keys(arr[0]).sort();
    } else {
      keys = [];
    }

    const arrays = arr.map(obj =>
      keys.map(key => args.parse ? parseSpecialTypes(obj[key]) : obj[key])
    );

    const final = Array(arrays[0]?.length || 0)
      .fill(0)
      .map(() => Array(arrays.length).fill(0));

    for (let j = 0; j &lt; arrays[0]?.length; j++) {
      for (let n = 0; n &lt; arrays.length; n++) {
        final[j][n] = arrays[n][j];
      }
    }

    // Attach names only if requested
    if (args.attachNames !== false) {
      for (let j = 0; j &lt; final.length; j++) {
        // Use the same keys array for headers to ensure alignment
        if (keys[j]) {
          final[j].unshift(keys[j]);
        }
      }
    }

    return final;
  }

  else if (type === 'ARR-col') {
    if (!arr || !Array.isArray(arr)) return null;

    const keysToUse = args.keep;
    const arrays = keysToUse.map(key => {
      const column = [];
      if (args.attachNames !== false) {
        column.push(key); // Only attach name if requested
      }
      for (let i = 0; i &lt; arr.length; i++) {
        const val = arr[i]?.[key];
        column.push(args.parse ? parseSpecialTypes(val) : val);
      }
      return column;
    });

    return arrays;
  }

  else if (type === 'CSV') {
    if (!arr || !Array.isArray(arr)) {
      console.error('[transform] CSV conversion failed: arr is invalid');
      return null;
    }

    let str = '';
    for (let i = 0; i &lt; arr.length; i++) {
      let line = '';
      for (const index in arr[i]) {
        if (line !== '') line += ',';
        line += `"${arr[i][index]}"`;
      }
      str += line + '\r\n';
    }
    return str;
  }

  else if (type === 'JSON') {
    return JSON.stringify(data);
  }

  else if (type === 'XML2JSON') {
    const XMLJSon = (data) => {
      const json = {};
      for (const res of data.matchAll(/(?:&lt;(\w*)(?:\s[^>]*)*>)((?:(?!&lt;\1).)*)(?:&lt;\/\1>)|&lt;(\w*)(?:\s*)*\/>/gm)) {
        const key = res[1] || res[3],
          value = res[2] &amp;&amp; XMLJSon(res[2]);
        json[key] = value &amp;&amp; Object.keys(value).length ? value : res[2] || null;
      }
      return json;
    };
    return XMLJSon(data);
  }

  else if (type) {
    throw new Error('Please select a supported data conversion type!');
  }

  return data;
}


/**
 * Upload data from the user's local file system for analysis.
 * Creates a file input dialog and processes the selected file based on its type.
 * 
 * @function upload
 * @memberof data
 * @async
 * @param {Object} options - Configuration object for file upload
 * @param {Object} options.params - Parameters for upload configuration
 * @param {string} options.params.type - File type to accept ('CSV', 'JSON', 'KML')
 * @param {Object} [options.args] - Additional arguments (currently unused)
 * @param {Object} [options.data] - Additional data (currently unused)
 * @returns {Promise&lt;Array|Object|string>} Promise resolving to parsed file content
 * 
 * @example
 * // Upload and parse CSV file
 * const csvData = await hydro.data.upload({
 *   params: { type: 'CSV' }
 * });
 * // Returns array of arrays with numeric conversion for numeric columns
 * // Example result: [['Date', 'Flow', 'Stage'], ['2023-01-01', 100.5, 2.1], ...]
 * 
 * @example
 * // Upload and parse JSON file
 * const jsonData = await hydro.data.upload({
 *   params: { type: 'JSON' }
 * });
 * // Returns parsed JSON object
 * 
 * @example
 * // Upload KML file as raw text
 * const kmlData = await hydro.data.upload({
 *   params: { type: 'KML' }
 * });
 * // Returns raw KML content as string
 */
async function upload({ params, args, data } = {}) {
  const fileInput = document.createElement("input");
  fileInput.type = "file";
  fileInput.accept = params.type;

  let ret = null;

  const getFileContent = (file) => {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = () => resolve(reader.result);
      reader.onerror = () => reject(reader.error);
      reader.readAsText(file);
    });
  };

  const isNumeric = (value) => {
    return /^-?\d+\.?\d*$/.test(value);
  };

  const handleFileSelect = async (event) => {
    const file = event.target.files[0];
    const content = await getFileContent(file);

    if (params.type === "CSV") {
      const rows = content.split(/\r\n|\n/).map((row) => {
        return row.split(",").map((value) => value.replace(/^"|"$/g, ""));
      });

      const columns = rows[0].map((_, i) => rows.map((row) => row[i]));
      ret = [];
      columns.forEach((column, i) => {
        if (column.every(isNumeric)) {
          ret.push(column.map((value) => parseFloat(value)));
        } else {
          ret.push(column);
        }
      });

    } else if (params.type === "JSON") {
      ret = JSON.parse(content);

    } else if (params.type === "KML") {
      ret = content
    }
  };

  fileInput.addEventListener("change", handleFileSelect);
  fileInput.click();

  return new Promise((resolve) => {
    const intervalId = setInterval(() => {
      if (ret !== null) {
        clearInterval(intervalId);
        resolve(ret);
      }
    }, 100);
  });
}


/**
 * Download data in various formats to the user's local file system.
 * Automatically transforms data using the transform function and creates a downloadable file.
 * 
 * @function download
 * @memberof data
 * @async
 * @param {Object} options - Configuration object for download
 * @param {Object} [options.params] - Parameters for download configuration
 * @param {string} [options.params.fileName] - Name for the downloaded file (without extension)
 * @param {Object} options.args - Arguments for download format and transformation
 * @param {string} options.args.type - Download format ('CSV', 'JSON')
 * @param {string[]} [options.args.keep] - Column headers to keep (for CSV)
 * @param {Object|Array|Promise} options.data - Data to download (can be a Promise)
 * @returns {Promise&lt;void>} Promise that resolves when download is initiated
 * 
 * @example
 * // Download data as CSV file
 * await hydro.data.download({
 *   params: { fileName: 'streamflow_data' },
 *   args: { 
 *     type: 'CSV',
 *     keep: ['dateTime', 'value']
 *   },
 *   data: transformedData
 * });
 * // Downloads file as 'streamflow_data.csv'
 * 
 * @example
 * // Download data as JSON file
 * await hydro.data.download({
 *   params: { fileName: 'station_info' },
 *   args: { type: 'JSON' },
 *   data: stationData
 * });
 * // Downloads file as 'station_info.json'
 * 
 * @example
 * // Download with auto-generated filename
 * await hydro.data.download({
 *   args: { type: 'CSV' },
 *   data: myData
 * });
 * // Downloads with timestamp-based filename like '23.12.15.14:30.csv'
 */
async function download({ params, args, data } = {}) {
  let { type } = args;
  let blob = null;
  let exportfilename = null;
  const { fileName } = params || generateDateString();

  //if CSV is required to be download, call the transform function.
  if (type === "CSV") {
    const csv = this.transform({ params, args, data: await data });
    blob = new Blob([csv], {
      type: "text/csv; charset=utf-8;",
    });
    exportfilename = `${fileName}.csv`;

    //if JSON file is required. Similar as before.
  } else if (type === "JSON") {
    let js;
    if (Array.isArray(data)) {
      js = this.transform({ params, args, data });
    } else {
      js = data;
    }
    blob = new Blob([JSON.stringify(await js)], {
      type: "text/json",
    });
    exportfilename = `${fileName}.json`;
  }

  //if XML file is required for loading. Needs improvement.
  /*else if (type === 'XML') {
    const xs = this.transform(data, config);
    blob = new Blob([xs], {type: 'text/xml'});
    exportfilename = 'export.xml';
  };*/

  //after the data has been transformed, create a new download file and link. No name is given but "export".
  if (navigator.msSaveOrOpenBlob) {
    navigator.msSaveOrOpenBlob(blob, exportfilename);
  } else {
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = exportfilename;
    a.click();
    a.remove();
  }
}

/**********************************/
/****** Helper functions **********/
/**********************************/

/**
 * Recursively searches for arrays with specific key names in nested objects.
 * Useful for extracting data from complex nested JSON structures returned by APIs.
 * 
 * @function recursiveSearch
 * @memberof data
 * @param {Object} options - Search configuration object
 * @param {Object} options.obj - Object to search within
 * @param {string} options.searchkey - Key name to search for
 * @param {Array} [options.results=[]] - Array to store found values (used internally for recursion)
 * @returns {Array} Array containing all found values for the specified key
 * 
 * @example
 * // Search for 'timeSeries' arrays in USGS response
 * const complexData = {
 *   value: {
 *     queryInfo: { ... },
 *     timeSeries: [
 *       { name: 'Streamflow', values: [{ value: 100 }, { value: 95 }] }
 *     ]
 *   }
 * };
 * 
 * const timeSeries = hydro.data.recursiveSearch({
 *   obj: complexData,
 *   searchkey: 'timeSeries'
 * });
 * // Returns: [[{ name: 'Streamflow', values: [...] }]]
 * 
 * @example
 * // Search for 'values' arrays in nested data
 * const found = hydro.data.recursiveSearch({
 *   obj: complexData,
 *   searchkey: 'values'
 * });
 * // Returns all arrays with key 'values'
 */
function recursiveSearch({ obj, searchkey, results = [] } = {}) {
  const r = results;
  Object.keys(obj).forEach((key) => {
    const value = obj[key];
    if (key === searchkey &amp;&amp; Array.isArray(value)) {
      r.push(value);
      return;
    } else if (typeof value === "object" &amp;&amp; value !== null) {
      recursiveSearch({ obj: value, searchkey: searchkey, results: r });
    }
  });
  return r;
}

/**
 * Converts all object keys to lowercase recursively, including nested objects and arrays.
 * Useful for normalizing API responses that may have inconsistent casing.
 * 
 * @function lowercasing
 * @memberof data
 * @param {Object|Array|*} obj - Object, array, or value to process
 * @returns {Object|Array|*} Copy of input with all object keys converted to lowercase
 * 
 * @example
 * // Normalize object keys
 * const normalized = hydro.data.lowercasing({
 *   StationName: "USGS Station",
 *   FlowData: {
 *     DateTime: "2023-01-01T12:00:00Z",
 *     Value: 100.5
 *   }
 * });
 * // Returns: { stationname: "USGS Station", flowdata: { datetime: "2023-01-01T12:00:00Z", value: 100.5 } }
 * 
 * @example
 * // Process array of objects
 * const normalizedArray = hydro.data.lowercasing([
 *   { StationID: "01646500", FlowRate: 100 },
 *   { StationID: "01647000", FlowRate: 85 }
 * ]);
 * // Returns: [{ stationid: "01646500", flowrate: 100 }, { stationid: "01647000", flowrate: 85 }]
 */
function lowercasing(obj) {
  if (typeof obj !== "object") return obj;
  if (Array.isArray(obj)) return obj.map(lowercasing);
  return Object.keys(obj).reduce((newObj, key) => {
    let val = obj[key],
      newVal = typeof val === "object" &amp;&amp; val !== null ? lowercasing(val) : val;
    newObj[key.toLowerCase()] = newVal;
    return newObj;
  }, {});
}

/**
 * Recursively converts XML document format to JSON format.
 * Handles XML attributes, text content, and nested elements.
 * 
 * @function xml2json
 * @memberof data
 * @param {Document|Element} xml - Parsed XML document or element from DOMParser
 * @returns {Object|string|null} Object representation of XML structure, or null if error occurs
 * 
 * @example
 * // Convert XML to JSON
 * const parser = new DOMParser();
 * const xmlDoc = parser.parseFromString(xmlString, "text/xml");
 * const jsonResult = hydro.data.xml2json(xmlDoc);
 * 
 * // For XML like: &lt;station id="01646500">&lt;name>Potomac River&lt;/name>&lt;flow>100.5&lt;/flow>&lt;/station>
 * // Returns: { station: { "@id": "01646500", name: "Potomac River", flow: "100.5" } }
 * 
 * @example
 * // Handle XML with multiple elements
 * // XML: &lt;stations>&lt;station>Station1&lt;/station>&lt;station>Station2&lt;/station>&lt;/stations>
 * // Returns: { stations: { station: ["Station1", "Station2"] } }
 */
function xml2json(xml) {
  try {
    let obj = {};

    // Handle attributes
    if (xml.attributes &amp;&amp; xml.attributes.length > 0) {
      for (let i = 0; i &lt; xml.attributes.length; i++) {
        const attr = xml.attributes.item(i);
        obj[`@${attr.nodeName}`] = attr.nodeValue;
      }
    }

    // Handle child nodes
    for (let i = 0; i &lt; xml.childNodes.length; i++) {
      const node = xml.childNodes[i];

      if (node.nodeType === Node.TEXT_NODE) {
        const text = node.textContent.trim();
        if (text.length > 0) {
          obj["#text"] = text;
        }
      } else if (node.nodeType === Node.ELEMENT_NODE) {
        const nodeName = node.nodeName;
        const childObj = xml2json(node);

        if (obj[nodeName] === undefined) {
          obj[nodeName] = childObj;
        } else {
          if (!Array.isArray(obj[nodeName])) {
            obj[nodeName] = [obj[nodeName]];
          }
          obj[nodeName].push(childObj);
        }
      }
    }

    // Edge case: If no children or attributes and there's textContent
    if (
      Object.keys(obj).length === 0 &amp;&amp;
      xml.textContent &amp;&amp;
      xml.textContent.trim().length > 0
    ) {
      return xml.textContent.trim();
    }

    return obj;
  } catch (e) {
    console.error('[xml2json] Error during conversion:', e.message);
    return null;
  }
}


/**
 * Generates a timestamp-based string for file naming.
 * Creates a formatted date string in YY.MM.DD.HH:MM format.
 * 
 * @function generateDateString
 * @memberof data
 * @returns {string} Formatted date string
 * 
 * @example
 * // Get current timestamp for filename
 * const timestamp = hydro.data.generateDateString();
 * // Returns something like: "23.12.15.14:30"
 * 
 * @example
 * // Use in file download
 * const filename = `data_${hydro.data.generateDateString()}.csv`;
 * // Results in: "data_23.12.15.14:30.csv"
 */
function generateDateString() {
  const now = new Date();
  const year = now.getFullYear().toString().slice(-2);
  const month = (now.getMonth() + 1).toString().padStart(2, '0');
  const day = now.getDate().toString().padStart(2, '0');
  const hours = now.getHours().toString().padStart(2, '0');
  const minutes = now.getMinutes().toString().padStart(2, '0');
  return `${year}.${month}.${day}.${hours}:${minutes}`;
}

/**********************************/
/*** NWM Processing Functions ****/
/**********************************/











/**********************************/
/*** End of Helper functions **/
/**********************************/

// Cache management - simple list and get by key
/**
 * Cache management API - simple interface
 * list() to see what's cached, get(key) to retrieve by name
 * 
 * @namespace cache
 * @memberof data
 */
export const cache = {
  /**
   * List all cached datasets with human-readable key names
   * 
   * @function list
   * @memberof data.cache
   * @param {Object} [options] - Optional filter options
   * @param {string} [options.source] - Filter by data source (e.g., 'nldas', 'usgs')
   * @returns {Promise&lt;Array>} Array with cacheKey, size, age for each cached dataset
   * 
   * @example
   * const cached = await hydro.data.cache.list();
   * cached.forEach(item => {
   *   console.log(`${item.cacheKey} - ${item.sizeFormatted}, ${item.ageFormatted} old`);
   * });
   */
  async list(options = {}) {
    const cacheInstance = globalThis._hydroCache;
    if (!cacheInstance) {
      console.warn('Cache not initialized');
      return [];
    }
    return await cacheInstance.list(options);
  },

  /**
   * Get a cached dataset by cache key
   * @param {string} cacheKey - The cache key (e.g., 'nhdplus/flowlines/abc1')
   * @returns {Promise&lt;Object|null>} Dataset with data and metadata, or null if not found
   * 
   * @example
   * const data = await hydro.data.cache.get('nhdplus/flowlines/iowa-city');
   * console.log(data);
   */
  async get(cacheKey) {
    const cacheInstance = globalThis.hydro?.cache || globalThis._hydroCache;
    if (!cacheInstance) {
      console.warn('Cache not initialized');
      return null;
    }
    const cached = await cacheInstance.get(cacheKey);
    return cached ? cached.data : null;
  },

  /**
   * Delete cached dataset by key
   * 
   * @function delete
   * @memberof data.cache
   * @param {string} cacheKey - Key to delete
   * @returns {Promise&lt;boolean>} Success
   * 
   * @example
   * await hydro.data.cache.delete('nldas_hourly_lat40.0_lon-105.0_start2024-01-01');
   */
  async delete(cacheKey) {
    const cacheInstance = globalThis.hydro?.cache || globalThis._hydroCache;
    if (!cacheInstance) {
      console.warn('Cache not initialized');
      return false;
    }
    await cacheInstance.delete(cacheKey);
    return true;
  },

  /**
   * Clear all cache
   * 
   * @function clear
   * @memberof data.cache
   * @returns {Promise&lt;boolean>} Success
   * 
   * @example
   * await hydro.data.cache.clear();
   */
  async clear() {
    const cacheInstance = globalThis._hydroCache;
    if (!cacheInstance) {
      console.warn('Cache not initialized');
      return false;
    }
    await cacheInstance.clear();
    return true;
  },

  /**
   * Get cache statistics
   * @returns {Promise&lt;Object>} Cache statistics
   * 
   * @example
   * const stats = await hydro.data.cache.stats();
   * console.log(stats);
   * // {totalSize: 104857600, totalEntries: 42, sizeFormatted: '100 MB', ...}
   */
  async stats() {
    const cacheInstance = globalThis._hydroCache;
    if (!cacheInstance) {
      console.warn('Cache not initialized');
      return { totalSize: 0, totalEntries: 0, sizeFormatted: '0 B' };
    }

    const allEntries = await cacheInstance.list({ includeVariables: true });
    const totalSize = allEntries.reduce((sum, entry) => sum + entry.size, 0);

    return {
      totalSize,
      totalEntries: allEntries.length,
      sizeFormatted: cacheInstance.formatBytes(totalSize),
      entries: allEntries
    };
  },

  /**
   * Check if data is available in cache without fetching
   * Returns metadata about cached data including size and age
   * 
   * @function checkCache
   * @memberof data.cache
   * @param {Object} options - Check options
   * @param {Object} options.params - Same params as retrieve function
   * @param {string} options.params.source - Data source (e.g., 'nldas', 'usgs')
   * @param {string} options.params.datatype - Data type
   * @param {Object} options.args - Same args as retrieve function  
   * @returns {Promise&lt;Object|null>} Cached data info or null if not cached
   * 
   * @example
   * // Check if NLDAS data is cached
   * const cached = await hydro.data.cache.checkCache({
   *   params: { source: 'nldas', datatype: 'hourly' },
   *   args: { lat: 40, lon: -105, startDate: '2024-01-01', endDate: '2024-01-02' }
   * });
   * if (cached) {
   *   console.log(`Data cached: ${cached.sizeMB} MB, ${cached.ageDays} days old`);
   * }
   */
  async checkCache({ params, args }) {
    const cacheInstance = globalThis.hydro?.cache || globalThis._hydroCache;
    if (!cacheInstance) return null;

    // Generate key from params
    globalThis._hydroCacheContext = { params: { args } };
    const key = cacheInstance.generateCacheKey('', params);

    const cached = await cacheInstance.get(key);
    if (!cached) return null;

    return {
      available: true,
      key: key,
      size: cached.data?.byteLength || 0,
      sizeMB: ((cached.data?.byteLength || 0) / 1024 / 1024).toFixed(2),
      age: Date.now() - (cached.metadata?.timestamp || cached.timestamp || Date.now()),
      ageDays: ((Date.now() - (cached.metadata?.timestamp || cached.timestamp || Date.now())) / (24 * 60 * 60 * 1000)).toFixed(1)
    };
  },

  /**
   * Get comprehensive cache statistics
   * Returns total size, file count, and detailed entries
   * 
   * @function getStats  
   * @memberof data.cache
   * @returns {Promise&lt;Object>} Cache statistics
   * 
   * @example
   * const stats = await hydro.data.cache.getStats();
   * console.log(`Total cache size: ${stats.totalSizeMB} MB`);
   * console.log(`Files cached: ${stats.totalFiles}`);
   */
  async getStats() {
    const cacheInstance = globalThis.hydro?.cache || globalThis._hydroCache;
    if (!cacheInstance) {
      return {
        totalFiles: 0,
        totalSize: 0,
        totalSizeMB: '0.0',
        totalSizeGB: '0.00',
        entries: []
      };
    }
    return await cacheInstance.getStats();
  }
};

export { retrieve, transform, download, upload, recursiveSearch, xml2json, getFile, saveFile };
export default { retrieve, transform, download, upload, recursiveSearch, xml2json, getFile, saveFile, cache };
</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.7</a> on Mon Jan 12 2026 20:25:33 GMT+0000 (Coordinated Universal Time) using the Toast theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
