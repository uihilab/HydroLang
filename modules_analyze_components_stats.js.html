<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>modules/analyze/components/stats.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="https://code.ionicframework.com/ionicons/2.0.1/css/ionicons.min.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="data.html">data</a><ul class='methods'><li data-type='method'><a href="data.html#.download">download</a></li><li data-type='method'><a href="data.html#.generateDateString">generateDateString</a></li><li data-type='method'><a href="data.html#.lowercasing">lowercasing</a></li><li data-type='method'><a href="data.html#.recursiveSearch">recursiveSearch</a></li><li data-type='method'><a href="data.html#.retrieve">retrieve</a></li><li data-type='method'><a href="data.html#.transform">transform</a></li><li data-type='method'><a href="data.html#.upload">upload</a></li><li data-type='method'><a href="data.html#.xml2json">xml2json</a></li></ul></li><li><a href="divisors.html">divisors</a><ul class='methods'><li data-type='method'><a href="divisors.html#.createDiv">createDiv</a></li><li data-type='method'><a href="divisors.html#.createScript">createScript</a></li><li data-type='method'><a href="divisors.html#.isdivAdded">isdivAdded</a></li><li data-type='method'><a href="divisors.html#.isScriptAdded">isScriptAdded</a></li></ul></li><li><a href="floodDM.html">floodDM</a><ul class='methods'><li data-type='method'><a href="floodDM.html#.buildPropertyDMScenario">buildPropertyDMScenario</a></li><li data-type='method'><a href="floodDM.html#.createTableFromObject">createTableFromObject</a></li><li data-type='method'><a href="floodDM.html#.getBridgeDamage">getBridgeDamage</a></li><li data-type='method'><a href="floodDM.html#.getCityFloodDamage">getCityFloodDamage</a></li><li data-type='method'><a href="floodDM.html#.getFloodInundation">getFloodInundation</a></li><li data-type='method'><a href="floodDM.html#.getLifeLoss">getLifeLoss</a></li><li data-type='method'><a href="floodDM.html#.getPropertyLoss">getPropertyLoss</a></li><li data-type='method'><a href="floodDM.html#.getUtilityDamage">getUtilityDamage</a></li><li data-type='method'><a href="floodDM.html#.getVehicleDamage">getVehicleDamage</a></li><li data-type='method'><a href="floodDM.html#initDamageScenario">initDamageScenario</a></li><li data-type='method'><a href="floodDM.html#initMitigationScenario">initMitigationScenario</a></li><li data-type='method'><a href="floodDM.html#runMitigationScenario">runMitigationScenario</a></li></ul></li><li><a href="HLclearCreek.html">HLclearCreek</a><ul class='methods'><li data-type='method'><a href="HLclearCreek.html#.additionalData">additionalData</a></li><li data-type='method'><a href="HLclearCreek.html#.dataStep">dataStep</a></li><li data-type='method'><a href="HLclearCreek.html#.get_time_step">get_time_step</a></li><li data-type='method'><a href="HLclearCreek.html#.get_value_at_indices">get_value_at_indices</a></li><li data-type='method'><a href="HLclearCreek.html#.retrieveData">retrieveData</a></li><li data-type='method'><a href="HLclearCreek.html#.retrieveGauge">retrieveGauge</a></li><li data-type='method'><a href="HLclearCreek.html#.spreadGauge">spreadGauge</a></li><li data-type='method'><a href="HLclearCreek.html#.spreadResults">spreadResults</a></li><li data-type='method'><a href="HLclearCreek.html#.update">update</a></li><li data-type='method'><a href="HLclearCreek.html#.update_until">update_until</a></li><li data-type='method'><a href="HLclearCreek.html#rainID">rainID</a></li></ul></li><li><a href="hydro.html">hydro</a><ul class='methods'><li data-type='method'><a href="hydro.html#.analyzeCollectionofEvents">analyzeCollectionofEvents</a></li><li data-type='method'><a href="hydro.html#.analyzeEvent">analyzeEvent</a></li><li data-type='method'><a href="hydro.html#.arithmetic">arithmetic</a></li><li data-type='method'><a href="hydro.html#.bucketmodel">bucketmodel</a></li><li data-type='method'><a href="hydro.html#.calculate_tds">calculate_tds</a></li><li data-type='method'><a href="hydro.html#.calculate_tss">calculate_tss</a></li><li data-type='method'><a href="hydro.html#.calculateDOSaturation">calculateDOSaturation</a></li><li data-type='method'><a href="hydro.html#.calculatepH">calculatepH</a></li><li data-type='method'><a href="hydro.html#.calculatePrecipitationMinMax">calculatePrecipitationMinMax</a></li><li data-type='method'><a href="hydro.html#.calibratePH">calibratePH</a></li><li data-type='method'><a href="hydro.html#.compensateORP">compensateORP</a></li><li data-type='method'><a href="hydro.html#.convertTemperature">convertTemperature</a></li><li data-type='method'><a href="hydro.html#.convertTurbidity">convertTurbidity</a></li><li data-type='method'><a href="hydro.html#.darcysLaw">darcysLaw</a></li><li data-type='method'><a href="hydro.html#.detectPrecipEvents">detectPrecipEvents</a></li><li data-type='method'><a href="hydro.html#.dissolvedOxygenDemand">dissolvedOxygenDemand</a></li><li data-type='method'><a href="hydro.html#.dynamicGround1D">dynamicGround1D</a></li><li data-type='method'><a href="hydro.html#.equationsystemsolver">equationsystemsolver</a></li><li data-type='method'><a href="hydro.html#.ETBlaneyCriddle">ETBlaneyCriddle</a></li><li data-type='method'><a href="hydro.html#.ETHargreaves">ETHargreaves</a></li><li data-type='method'><a href="hydro.html#.ETPenmanMontheith">ETPenmanMontheith</a></li><li data-type='method'><a href="hydro.html#.ETPriestelyTaylor">ETPriestelyTaylor</a></li><li data-type='method'><a href="hydro.html#.ETThornthwaite">ETThornthwaite</a></li><li data-type='method'><a href="hydro.html#.floodhydro">floodhydro</a></li><li data-type='method'><a href="hydro.html#.generateSyntheticValue">generateSyntheticValue</a></li><li data-type='method'><a href="hydro.html#.getJulianDay">getJulianDay</a></li><li data-type='method'><a href="hydro.html#.ground1d">ground1d</a></li><li data-type='method'><a href="hydro.html#.hyetogen">hyetogen</a></li><li data-type='method'><a href="hydro.html#.InfGreenAmpt">InfGreenAmpt</a></li><li data-type='method'><a href="hydro.html#.InfHorton">InfHorton</a></li><li data-type='method'><a href="hydro.html#.InfKostiakov">InfKostiakov</a></li><li data-type='method'><a href="hydro.html#.InfPhilip">InfPhilip</a></li><li data-type='method'><a href="hydro.html#.InfSmithParlange">InfSmithParlange</a></li><li data-type='method'><a href="hydro.html#.inverseDistanceWeighting">inverseDistanceWeighting</a></li><li data-type='method'><a href="hydro.html#.kinematicWaveRouting">kinematicWaveRouting</a></li><li data-type='method'><a href="hydro.html#.lagAndRoute">lagAndRoute</a></li><li data-type='method'><a href="hydro.html#.matrix">matrix</a></li><li data-type='method'><a href="hydro.html#.move">move</a></li><li data-type='method'><a href="hydro.html#.muskingumCunge">muskingumCunge</a></li><li data-type='method'><a href="hydro.html#.precipitationFrequencyAnalysis">precipitationFrequencyAnalysis</a></li><li data-type='method'><a href="hydro.html#.rainaggr">rainaggr</a></li><li data-type='method'><a href="hydro.html#.rainfallErosivityIndex">rainfallErosivityIndex</a></li><li data-type='method'><a href="hydro.html#.rainfallIntensityDurationFrequency">rainfallIntensityDurationFrequency</a></li><li data-type='method'><a href="hydro.html#.rainfallInterceptionModel">rainfallInterceptionModel</a></li><li data-type='method'><a href="hydro.html#.rainfallThresholdAnalysis">rainfallThresholdAnalysis</a></li><li data-type='method'><a href="hydro.html#.stochasticRainfallGeneration">stochasticRainfallGeneration</a></li><li data-type='method'><a href="hydro.html#.syntheticalc">syntheticalc</a></li><li data-type='method'><a href="hydro.html#.thiessen">thiessen</a></li><li data-type='method'><a href="hydro.html#.timeAreaMethod">timeAreaMethod</a></li><li data-type='method'><a href="hydro.html#.totalprec">totalprec</a></li><li data-type='method'><a href="hydro.html#.unithydrocons">unithydrocons</a></li></ul></li><li><a href="HydroBMI.BMI.html">BMI</a></li><li><a href="HydroLangBMI.html">HydroLangBMI</a><ul class='methods'><li data-type='method'><a href="HydroLangBMI.html#.dataTypes">dataTypes</a></li><li data-type='method'><a href="HydroLangBMI.html#.finalize">finalize</a></li><li data-type='method'><a href="HydroLangBMI.html#.generateOutputs">generateOutputs</a></li><li data-type='method'><a href="HydroLangBMI.html#.get_component_name">get_component_name</a></li><li data-type='method'><a href="HydroLangBMI.html#.get_current_time">get_current_time</a></li><li data-type='method'><a href="HydroLangBMI.html#.get_end_time">get_end_time</a></li><li data-type='method'><a href="HydroLangBMI.html#.get_grid_edge_count">get_grid_edge_count</a></li><li data-type='method'><a href="HydroLangBMI.html#.get_grid_edge_nodes">get_grid_edge_nodes</a></li><li data-type='method'><a href="HydroLangBMI.html#.get_grid_face_count">get_grid_face_count</a></li><li data-type='method'><a href="HydroLangBMI.html#.get_grid_face_nodes">get_grid_face_nodes</a></li><li data-type='method'><a href="HydroLangBMI.html#.get_grid_face_nodes">get_grid_face_nodes</a></li><li data-type='method'><a href="HydroLangBMI.html#.get_grid_node_count">get_grid_node_count</a></li><li data-type='method'><a href="HydroLangBMI.html#.get_grid_nodes_per_face">get_grid_nodes_per_face</a></li><li data-type='method'><a href="HydroLangBMI.html#.get_grid_origin">get_grid_origin</a></li><li data-type='method'><a href="HydroLangBMI.html#.get_grid_shape">get_grid_shape</a></li><li data-type='method'><a href="HydroLangBMI.html#.get_grid_size">get_grid_size</a></li><li data-type='method'><a href="HydroLangBMI.html#.get_grid_size">get_grid_size</a></li><li data-type='method'><a href="HydroLangBMI.html#.get_grid_spacing">get_grid_spacing</a></li><li data-type='method'><a href="HydroLangBMI.html#.get_grid_type">get_grid_type</a></li><li data-type='method'><a href="HydroLangBMI.html#.get_grid_x">get_grid_x</a></li><li data-type='method'><a href="HydroLangBMI.html#.get_grid_y">get_grid_y</a></li><li data-type='method'><a href="HydroLangBMI.html#.get_grid_z">get_grid_z</a></li><li data-type='method'><a href="HydroLangBMI.html#.get_input_item_count">get_input_item_count</a></li><li data-type='method'><a href="HydroLangBMI.html#.get_time_step">get_time_step</a></li><li data-type='method'><a href="HydroLangBMI.html#.get_time_units">get_time_units</a></li><li data-type='method'><a href="HydroLangBMI.html#.get_value_at_indices">get_value_at_indices</a></li><li data-type='method'><a href="HydroLangBMI.html#.get_value_ptr">get_value_ptr</a></li><li data-type='method'><a href="HydroLangBMI.html#.get_var_type">get_var_type</a></li><li data-type='method'><a href="HydroLangBMI.html#.handleConfig">handleConfig</a></li><li data-type='method'><a href="HydroLangBMI.html#.initialize">initialize</a></li><li data-type='method'><a href="HydroLangBMI.html#.set_value">set_value</a></li><li data-type='method'><a href="HydroLangBMI.html#.set_value_at_indices">set_value_at_indices</a></li><li data-type='method'><a href="HydroLangBMI.html#.update">update</a></li><li data-type='method'><a href="HydroLangBMI.html#.update_until">update_until</a></li><li data-type='method'><a href="HydroLangBMI.html#.visualizer">visualizer</a></li></ul></li><li><a href="map.html">map</a><ul class='methods'><li data-type='method'><a href="map.html#.addMarker">addMarker</a></li><li data-type='method'><a href="map.html#.draw">draw</a></li><li data-type='method'><a href="map.html#.generateColors">generateColors</a></li><li data-type='method'><a href="map.html#.geoJSON">geoJSON</a></li><li data-type='method'><a href="map.html#.kml">kml</a></li><li data-type='method'><a href="map.html#.Layers">Layers</a></li><li data-type='method'><a href="map.html#.loader">loader</a></li><li data-type='method'><a href="map.html#.markerStyles">markerStyles</a></li><li data-type='method'><a href="map.html#.renderMap">renderMap</a></li></ul></li><li><a href="nn.html">nn</a><ul class='methods'><li data-type='method'><a href="nn.html#.convertToTensor">convertToTensor</a></li><li data-type='method'><a href="nn.html#.createModel">createModel</a></li><li data-type='method'><a href="nn.html#.prediction">prediction</a></li><li data-type='method'><a href="nn.html#.saveModel">saveModel</a></li><li data-type='method'><a href="nn.html#.trainModel">trainModel</a></li></ul></li><li><a href="stats.html">stats</a><ul class='methods'><li data-type='method'><a href="stats.html#.arrchange">arrchange</a></li><li data-type='method'><a href="stats.html#.autocovarianceMatrix">autocovarianceMatrix</a></li><li data-type='method'><a href="stats.html#.basicstats">basicstats</a></li><li data-type='method'><a href="stats.html#.bernoulliDist">bernoulliDist</a></li><li data-type='method'><a href="stats.html#.binomialCoefficient">binomialCoefficient</a></li><li data-type='method'><a href="stats.html#.binomialDist">binomialDist</a></li><li data-type='method'><a href="stats.html#.breuschPaganTest">breuschPaganTest</a></li><li data-type='method'><a href="stats.html#.chisqCDF">chisqCDF</a></li><li data-type='method'><a href="stats.html#.cleaner">cleaner</a></li><li data-type='method'><a href="stats.html#.computeD">computeD</a></li><li data-type='method'><a href="stats.html#.copydata">copydata</a></li><li data-type='method'><a href="stats.html#.correlation">correlation</a></li><li data-type='method'><a href="stats.html#.datagaps">datagaps</a></li><li data-type='method'><a href="stats.html#.dateparser">dateparser</a></li><li data-type='method'><a href="stats.html#.differencing">differencing</a></li><li data-type='method'><a href="stats.html#.efficiencies">efficiencies</a></li><li data-type='method'><a href="stats.html#.exponentialMovingAverage">exponentialMovingAverage</a></li><li data-type='method'><a href="stats.html#.fastfourier">fastfourier</a></li><li data-type='method'><a href="stats.html#.flatenise">flatenise</a></li><li data-type='method'><a href="stats.html#.frequency">frequency</a></li><li data-type='method'><a href="stats.html#.gammaCDFApprox">gammaCDFApprox</a></li><li data-type='method'><a href="stats.html#.gapfiller">gapfiller</a></li><li data-type='method'><a href="stats.html#.gapremoval">gapremoval</a></li><li data-type='method'><a href="stats.html#.gaussianDist">gaussianDist</a></li><li data-type='method'><a href="stats.html#.generateRandomData">generateRandomData</a></li><li data-type='method'><a href="stats.html#.geometricDist">geometricDist</a></li><li data-type='method'><a href="stats.html#.getNextState">getNextState</a></li><li data-type='method'><a href="stats.html#.gevDistribution">gevDistribution</a></li><li data-type='method'><a href="stats.html#.gumbelDist">gumbelDist</a></li><li data-type='method'><a href="stats.html#.interoutliers">interoutliers</a></li><li data-type='method'><a href="stats.html#.itemfilter">itemfilter</a></li><li data-type='method'><a href="stats.html#.joinarray">joinarray</a></li><li data-type='method'><a href="stats.html#.KS_computePValue">KS_computePValue</a></li><li data-type='method'><a href="stats.html#.KS_rejectAtAlpha">KS_rejectAtAlpha</a></li><li data-type='method'><a href="stats.html#.linearMovingAverage">linearMovingAverage</a></li><li data-type='method'><a href="stats.html#.lognormalDist">lognormalDist</a></li><li data-type='method'><a href="stats.html#.LogSeriesDistribution">LogSeriesDistribution</a></li><li data-type='method'><a href="stats.html#.matrixInverse">matrixInverse</a></li><li data-type='method'><a href="stats.html#.max">max</a></li><li data-type='method'><a href="stats.html#.mean">mean</a></li><li data-type='method'><a href="stats.html#.median">median</a></li><li data-type='method'><a href="stats.html#.min">min</a></li><li data-type='method'><a href="stats.html#.MK">MK</a></li><li data-type='method'><a href="stats.html#.multinomialDistribution">multinomialDistribution</a></li><li data-type='method'><a href="stats.html#.multipleMatrix">multipleMatrix</a></li><li data-type='method'><a href="stats.html#.multiregression">multiregression</a></li><li data-type='method'><a href="stats.html#.normalcdf">normalcdf</a></li><li data-type='method'><a href="stats.html#.normalDistribution">normalDistribution</a></li><li data-type='method'><a href="stats.html#.normoutliers">normoutliers</a></li><li data-type='method'><a href="stats.html#.numerise">numerise</a></li><li data-type='method'><a href="stats.html#.onearray">onearray</a></li><li data-type='method'><a href="stats.html#.outremove">outremove</a></li><li data-type='method'><a href="stats.html#.poissonProcess">poissonProcess</a></li><li data-type='method'><a href="stats.html#.push">push</a></li><li data-type='method'><a href="stats.html#.quantile">quantile</a></li><li data-type='method'><a href="stats.html#.range">range</a></li><li data-type='method'><a href="stats.html#.regression">regression</a></li><li data-type='method'><a href="stats.html#.residualVariance">residualVariance</a></li><li data-type='method'><a href="stats.html#.returnPeriod">returnPeriod</a></li><li data-type='method'><a href="stats.html#.runMarkovChainMonteCarlo">runMarkovChainMonteCarlo</a></li><li data-type='method'><a href="stats.html#.runMonteCarlo">runMonteCarlo</a></li><li data-type='method'><a href="stats.html#.runSimulation">runSimulation</a></li><li data-type='method'><a href="stats.html#.runVegas">runVegas</a></li><li data-type='method'><a href="stats.html#.simpleMovingAverage">simpleMovingAverage</a></li><li data-type='method'><a href="stats.html#.spiCompute">spiCompute</a></li><li data-type='method'><a href="stats.html#.standardize">standardize</a></li><li data-type='method'><a href="stats.html#.stddev">stddev</a></li><li data-type='method'><a href="stats.html#.sum">sum</a></li><li data-type='method'><a href="stats.html#.sumsqrd">sumsqrd</a></li><li data-type='method'><a href="stats.html#.timegaps">timegaps</a></li><li data-type='method'><a href="stats.html#.transposeMatrix">transposeMatrix</a></li><li data-type='method'><a href="stats.html#.uniformDist">uniformDist</a></li><li data-type='method'><a href="stats.html#.unique">unique</a></li><li data-type='method'><a href="stats.html#.variance">variance</a></li></ul></li><li><a href="visualize.html">visualize</a><ul class='methods'><li data-type='method'><a href="visualize.html#.chart">chart</a></li><li data-type='method'><a href="visualize.html#.draw">draw</a></li><li data-type='method'><a href="visualize.html#.drawHtmlTable">drawHtmlTable</a></li><li data-type='method'><a href="visualize.html#.generateReport">generateReport</a></li><li data-type='method'><a href="visualize.html#.prettyPrint">prettyPrint</a></li><li data-type='method'><a href="visualize.html#.table">table</a></li></ul></li></ul><h3>Modules</h3><ul><li><a href="module-analyze.html">analyze</a></li><li><a href="module-mapsources.html">mapsources</a></li></ul><h3>Externals</h3><ul><li><a href="external-D3.html">D3</a></li><li><a href="external-GoogleCharts.html">GoogleCharts</a></li><li><a href="external-googlemapsapi.html">googlemapsapi</a></li><li><a href="external-leafletosmapi.html">leafletosmapi</a></li><li><a href="external-tensorflow.html">tensorflow</a></li><li><a href="external-tileprov.html">tileprov</a></li></ul><h3>Namespaces</h3><ul><li><a href="datasources.html">datasources</a><ul class='members'><li data-type='method'><a href="datasources.html#.AEMET">AEMET</a></li><li data-type='method'><a href="datasources.html#.ClearCreek">ClearCreek</a></li><li data-type='method'><a href="datasources.html#.EAUK">EAUK</a></li><li data-type='method'><a href="datasources.html#.ECMWF">ECMWF</a></li><li data-type='method'><a href="datasources.html#.EPA">EPA</a></li><li data-type='method'><a href="datasources.html#.FEMA">FEMA</a></li><li data-type='method'><a href="datasources.html#.flooddamage_dt">flooddamage_dt</a></li><li data-type='method'><a href="datasources.html#.IFIS">IFIS</a></li><li data-type='method'><a href="datasources.html#.MeteoIT">MeteoIT</a></li><li data-type='method'><a href="datasources.html#.MeteoIT">MeteoIT</a></li><li data-type='method'><a href="datasources.html#.MeteoSTAT">MeteoSTAT</a></li><li data-type='method'><a href="datasources.html#.mitigation_dt">mitigation_dt</a></li><li data-type='method'><a href="datasources.html#.NASAPOWER">NASAPOWER</a></li><li data-type='method'><a href="datasources.html#.NLDI">NLDI</a></li><li data-type='method'><a href="datasources.html#.NOAA">NOAA</a></li><li data-type='method'><a href="datasources.html#.NWPS">NWPS</a></li><li data-type='method'><a href="datasources.html#.NWS">NWS</a></li><li data-type='method'><a href="datasources.html#.ProxyServers">ProxyServers</a></li><li data-type='method'><a href="datasources.html#.soapEnv">soapEnv</a></li><li data-type='method'><a href="datasources.html#.USGS">USGS</a></li><li data-type='method'><a href="datasources.html#.USGS">USGS</a></li><li data-type='method'><a href="datasources.html#.Worldbank">Worldbank</a></li><li data-type='method'><a href="datasources.html#.WQP">WQP</a></li></ul></li><li><a href="datasources.CUAHSI.html">CUAHSI</a><ul class='members'><li data-type='method'><a href="datasources.CUAHSI.html#.hisCentral">hisCentral</a></li><li data-type='method'><a href="datasources.CUAHSI.html#.hydroShare">hydroShare</a></li><li data-type='method'><a href="datasources.CUAHSI.html#.waterOneFlow">waterOneFlow</a></li></ul></li><li><a href="HydroBMI.html">HydroBMI</a><ul class='members'><li data-type='method'><a href="HydroBMI.html#.BMIConfig">BMIConfig</a></li></ul></li><li><a href="HydroBMI.Hydro.html">Hydro</a></li><li><a href="Hydrolang.html">Hydrolang</a></li></ul><h3>Global</h3><ul><li><a href="global.html#addCustomLegend">addCustomLegend</a></li><li><a href="global.html#dotProduct">dotProduct</a></li><li><a href="global.html#goldfeldQuandtTest">goldfeldQuandtTest</a></li><li><a href="global.html#recenter">recenter</a></li><li><a href="global.html#whitesTest">whitesTest</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">modules/analyze/components/stats.js</h1>
    
    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * Main class used for statistical analyses and data cleaning.
 * @class
 * @name stats
 */
export default class stats {
  /**
   * Makes a deep copy of original data for further manipulation.
   * @method copydata
   * @memberof stats
   * @param {Object}  data - Contains: 1d-JS array or object with original data.
   * @returns {Object} Deep copy of original data.
   * @example
   * hydro.analyze.stats.copydata({data: [someData]})
   */

  static copydata({ params, args, data } = {}) {
    var arr, values, keys;

    if (typeof data !== "object" || data === null) {
      return data;
    }

    arr = Array.isArray(data) ? [] : {};

    for (keys in data) {
      values = data[keys];

      arr[keys] = this.copydata({ data: values });
    }

    return arr;
  }

  /**
   * Retrieves a 1D array with the data.
   * @method onearray
   * @memberof stats
   * @param {Object} data - Contains: 1d-JS array as [data]
   * @returns {Object[]} Array object.
   * @example
   * hydro.analyze.stats.onearray({data: [someData]})
   */

  static onearray({ params, args, data } = {}) {
    var arr = [];
    arr.push(data[1]);
    return arr;
  }

  /**
   * Gives the range of a dataset
   * @method range
   * @memberof stats
   * @param {Object} data - Contains: 1d-JS array with data as [data].
   * @returns {Array} Range of the data.
   * @example
   * hydro.analyze.stats.range({data: [someData]})
   */
  static range({ params, args, data } = {}) {
    const min = this.min({ data }),
      max = this.max({ data });
    const N = params.N || data.length;
    const step = (max - min) / N;
    const range = [];

    for (let i = 0; i &lt;= N; i++) {
      range.push(min + i * step);
    }

    return range;
  }

  /**
   * Identifies gaps in data.
   * @method datagaps
   * @memberof stats
   * @param {Object} data - Contains: 1d-JS array with data as [data].
   * @returns {Number} Number of gaps in data.
   * @example
   * hydro.analyze.stats.datagaps({data: [someData]})
   */

  static datagaps({ params, args, data } = {}) {
    var arr = data,
      or,
      gap = 0;

    if (typeof arr[0] != "object") {
      or = this.copydata({ data: arr });
    } else {
      or = this.copydata({ data: arr[1] });
    }
    for (var i = 0; i &lt; or.length; i++) {
      if (or[i] === undefined || Number.isNaN(or[i]) || or[i] === false) {
        gap++;
      }
    }

    return console.log(`Total amount of gaps in data: ${gap}.`);
  }

  /**
   * Remove gaps in data with an option to fill the gap.
   * @method gapremoval
   * @memberof stats
   * @param {Object} data - Contains: 1d-JS array object with data as [data].
   * @returns {Number} Number of gaps found in the data.
   * @example
   * hydro.analyze.stats.gapremoval({data: [someData]})
   */

  static gapremoval({ params = {}, args = {}, data } = {}) {
    const gapValues = params.gapValues || [undefined, null, NaN, false, -9999, 9999];
    const method = args.method || 'interpolate'; // 'interpolate', 'mean', 'median'
    const isGap = (v) => gapValues.some(gap => Object.is(gap, v) || (Number.isNaN(gap) &amp;&amp; Number.isNaN(v)));
  
    const cleanArray = (arr) => arr.filter(v => !isGap(v));
  
    const interpolate = (arr) => {
      const result = [...arr];
      for (let i = 0; i &lt; result.length; i++) {
        if (isGap(result[i])) {
          // Find nearest non-gap neighbors
          let prev = i - 1;
          let next = i + 1;
          while (prev >= 0 &amp;&amp; isGap(result[prev])) prev--;
          while (next &lt; result.length &amp;&amp; isGap(result[next])) next++;
  
          if (prev >= 0 &amp;&amp; next &lt; result.length) {
            result[i] = (result[prev] + result[next]) / 2;
          } else if (prev >= 0) {
            result[i] = result[prev];
          } else if (next &lt; result.length) {
            result[i] = result[next];
          } else {
            result[i] = 0;
          }
        }
      }
      return result;
    };
  
    const fillStat = (arr, stat = 'mean') => {
      const valid = cleanArray(arr);
      const fill = stat === 'median'
        ? valid.sort((a, b) => a - b)[Math.floor(valid.length / 2)]
        : valid.reduce((a, b) => a + b, 0) / valid.length;
      return arr.map(v => isGap(v) ? fill : v);
    };
  
    if (!Array.isArray(data)) return data;
  
    // Case 1: Flat numeric array
    if (typeof data[0] !== 'object') {
      return method === 'interpolate'
        ? interpolate(data)
        : fillStat(data, method);
    }
  
    // Case 2: 2D array (e.g. [time, values])
    let time = data[0], series = data[1];
  
    // Optionally remove both time &amp; value if value is invalid
    const validTime = [], validSeries = [];
    for (let i = 0; i &lt; series.length; i++) {
      if (!isGap(series[i])) {
        validTime.push(time[i]);
        validSeries.push(series[i]);
      }
    }
  
    let filled = method === 'interpolate'
      ? interpolate(series)
      : fillStat(series, method);
  
    return [time, filled];
  }
  

  /**
   * Identifies gaps in time. Used for filling gaps if required by the
   * user. Time in minutes and timestep must be divisible by the total time of the event.
   * @method timegaps
   * @memberof stats
   * @param {Object} params - Contains: timestep (in min)
   * @param {Object} data - Contains: 1d-JS array with timedata in minutes as [timeData].
   * @returns {Object[]} Array with gaps.
   * @example
   * hydro.analyze.stats.timegaps({params: {timestep: 'someNum'} data: [timeData]})
   */

  static timegaps({ params, args, data } = {}) {
    var timestep = params.timestep,
      arr = data,
      or = this.copydata({ data: arr });

    if (typeof arr[0] === "object") {
      or = this.copydata({ data: arr[0] });
    }
    var datetr = [];

    for (var i = 0; i &lt; or.length; i++) {
      if (typeof or[0] == "string") {
        datetr.push(Math.abs(Date.parse(or[i]) / (60 * 1000)));
      } else {
        datetr.push(or[i]);
      }
    }

    var gaps = 0,
      loc = [],
      //timestep and total duration in minutes.
      time = timestep;

    for (var i = 1; i &lt; or.length - 1; i++) {
      if (
        Math.abs(datetr[i - 1] - datetr[i]) != time ||
        Math.abs(datetr[i] - datetr[i + 1]) != time
      ) {
        gaps++;
        loc.push(or[i]);
      }
    }

    if (loc.length === 0) {
      console.log("No gaps in times!");
      return;
    } else {
      console.log(`Number of time gaps: ${gaps}`);
      return loc;
    }
  }

  /**
   * Fills data gaps (either time missig or data missing). Unfinished.
   * @method gapfiller
   * @memberof stats
   * @param {Object} params - Contains: type (time or data)
   * @param {Object} data - Contains: 2d-JS array with data or time gaps to be filled as [[time],[data]].
   * @returns {Object[]} Array with gaps filled.
   * @example
   * hydro.analyze.stats.gapfiller({params: {type: 'someType'}, data: [[time1,time2...], [data1, data2,...]]})
   */

  static gapfiller({ params, args, data } = {}) {
    var or = this.copydata({ data: data }),
      datetr = [];

    if (typeof data[0] === "object") {
      or = this.copydata({ data: data[0] });
    }

    for (var i = 0; i &lt; or.length; i++) {
      if (typeof or[0] == "string") {
        datetr.push(Math.abs(Date.parse(or[i]) / (60 * 1000)));
      } else {
        datetr.push(or[i]);
      }
    }

    if (params.type === "time") {
      var xo = [];
    }
  }

  /**
   * Sums all data in a 1-d array.
   * @method sum
   * @memberof stats
   * @param {Object} data - Contains: 1d-JS array object with data as [data].
   * @returns {Number} Sum of all data in an array.
   * @example
   * hydro.analyze.stats.sum({data: [data]})
   */

  static sum({ params, args, data } = {}) {
    return data.reduce((acc, curr) => acc + curr, 0);
  }

  /**
   * Calculates the mean of a 1d array.
   * @method mean
   * @memberof stats
   * @param {Object} data - Contains: 1d-JS array object with data as [data].
   * @returns {Number} Mean of the data.
   * @example
   * hydro.analyze.stats.mean({data: [data]})
   */

  static mean({ params, args, data } = {}) {
    const sum = this.sum({ data });
    const mean = sum / data.length;
    return mean;
  }

  /**
   * Calculates the median values for a 1d array.
   * @method median
   * @memberof stats
   * @param {Object} data - Contains: 1d-JS array object with data as [data].
   * @returns {Number} Median of the data.
   * @example
   * hydro.analyze.stats.median({data: [data]})
   */

  static median({ params, args, data } = {}) {
    const sortedArray = data.slice().sort((a, b) => a - b);
    const middleIndex = Math.floor(sortedArray.length / 2);

    if (sortedArray.length % 2 === 0) {
      const left = sortedArray[middleIndex - 1];
      const right = sortedArray[middleIndex];
      return (left + right) / 2;
    } else {
      return sortedArray[middleIndex];
    }
  }

  /**
   * Calculates standard deviation of a 1d array.
   * @method stddev
   * @memberof stats
   * @param {Object} data - Contains: 1d-JS array object with data as [data].
   * @returns {Number} Standard deviation.
   * @example
   * hydro.analyze.stats.stddev({data: [data]})
   */

  static stddev({ params, args, data } = {}) {
    var mean = this.mean({ data }),
      SD = 0,
      nex = [];
    for (var i = 0; i &lt; data.length; i += 1) {
      nex.push((data[i] - mean) * (data[i] - mean));
    }
    return (SD = Math.sqrt(this.sum({ data: nex }) / nex.length));
  }

  /**
   * Calculate variance for an 1-d array of data.
   * @method variance
   * @memberof stats
   * @param {Object} data - Contains 1d-JS array object with data as [data].
   * @returns {Number} Variance of the data.
   * @example
   * hydro.analyze.stats.variance({data: [data]})
   */

  static variance({ params, args, data } = {}) {
    const mean = this.mean({ data });
    const squareDiffs = data.map((num) => (num - mean) ** 2);
    const sumSquareDiffs = squareDiffs.reduce((acc, curr) => acc + curr, 0);
    const variance = sumSquareDiffs / data.length;
    return variance;
  }

  /**
   * Calculates sum of squares for a dataset.
   * @method sumsqrd
   * @memberof stats
   * @param {Object} data - Contains: 1d-JS array object with data as [data].
   * @returns {Number} Sum of squares for data.
   * @example
   * hydro.analyze.stats.sumsqrd({data: [data]})
   */

  static sumsqrd({ params, args, data } = {}) {
    var sum = 0,
      i = data.length;
    while (--i >= 0) sum += data[i];
    return sum;
  }

  /**
   * Minimum value of an array.
   * @method min
   * @memberof stats
   * @param {Object} data - Contains: 1d-JS array object with data as [data].
   * @returns {Number} Minimum value of a dataset.
   * @example
   * hydro.analyze.stats.min({data: [data]})
   */

  static min({ params, args, data } = {}) {
    return Math.min(...data);
  }

  /**
   * Maximum value of an array.
   * @method max
   * @memberof stats
   * @param {Object} data - Contains: 1d-JS array object with data as [data].
   * @returns {Number} Maximum value of a dataset.
   * @example
   * hydro.analyze.stats.max({data: [data]})
   */

  static max({ params, args, data } = {}) {
    return Math.max(...data);
  }

  /**
   * Unique values in an array.
   * @method unique
   * @memberof stats
   * @param {Object} data - Contains: 1d-JS array object with data as [data].
   * @returns {Object[]} Array with unique values.
   * @example
   * hydro.analyze.stats.unique({data: [data]})
   */

  static unique({ params, args, data } = {}) {
    var un = {},
      _arr = [];
    for (var i = 0; i &lt; data.length; i++) {
      if (!un[data[i]]) {
        un[data[i]] = true;
        _arr.push(data[i]);
      }
    }
    return _arr;
  }

  /**
   * Calculates the frequency in data.
   * @method frequency
   * @memberof stats
   * @param {Object} data - Contains: 1d-JS array object with data as [data].
   * @returns {Object} Object with frenquency distribution.
   * @example
   * hydro.analyze.stats.frequency({data: [data]})
   */

  static frequency({ params, args, data } = {}) {
    console.log(data)
    var _arr = this.copydata({ data: data }),
      counter = {};
    _arr.forEach((i) => {
      counter[i] = (counter[i] || 0) + 1;
    });
    return counter;
  }

  /**
   * Use mean and standard deviation to standardize the original dataset.
   * @method standardize
   * @memberof stats
   * @param {Object} data - Contains: 1d-JS array object with data as [data].
   * @returns {Object[]} Array with standardized data.
   * @example
   * hydro.analyze.stats.standardize({data: [data]})
   */

  static standardize({ params, args, data } = {}) {
    var _arr = [],
      stddev = this.stddev({ data: data }),
      mean = this.mean({ data: data });
    for (var i = 0; i &lt; data.length; i++) {
      _arr[i] = (data[i] - mean) / stddev;
    }
    return _arr;
  }

  /**
   * Quantile calculator for given data.
   * @method quantile
   * @memberof stats
   * @param {Object} params - Contains: q(quartile as 0.25, 0.75, or required)
   * @param {Object} data - Contains: 1d-JS array object with data as [data].
   * @returns {Object[]} Array with values fitting the quartile.
   * @example
   * hydro.analyze.stats.quantile({params: {q: 'someNum'}, data: [data]})
   */

  static quantile({ params, args, data } = {}) {
    var _arr = data.slice();
    _arr.sort(function (a, b) {
      return a - b;
    });
    var p = (data.length - 1) * params.q;
    if (p % 1 === 0) {
      return _arr[p];
    } else {
      var b = Math.floor(p),
        rest = p - b;
      if (_arr[b + 1] !== undefined) {
        return _arr[b] + rest * (_arr[b + 1] - _arr[b]);
      } else {
        return _arr[b];
      }
    }
  }

  /**
   * Removes interquartile outliers from an array or a set of arrays.
   * @method interoutliers
   * @memberof stats
   * @param {Object} [params={ q1: 0.25, q2: 0.75 }] - Parameters object.
   * @param {Array} data - Data to filter. If a 2D array is provided, the first array will be considered as a time array.
   * @returns {Array} - Filtered data.
   * @example
   * hydro.analyze.stats.interoutliers({ params: { q1: 0.25, q2: 0.75 }, data: [1, 2, 3, 100, 4, 5, 6]});
   */

  static interoutliers({ params = { q1: 0.25, q2: 0.75 }, data = [] } = {}) {
    const { q1, q2 } = params;
    const or = [...data];
    let time = [];

    if (Array.isArray(data[0])) {
      [time, or] = data;
    }

    const Q1 = this.quantile({ data: or, params: { q: q1 } });
    const Q3 = this.quantile({ data: or, params: { q: q2 } });
    const IQR = Math.abs(Q3 - Q1);
    const qd = Math.abs(Q1 - 1.5 * IQR);
    const qu = Math.abs(Q3 + 1.5 * IQR);

    const filteredData = or.filter((value, index) => {
      if (value >= qd &amp;&amp; value &lt;= qu) {
        if (time.length) {
          return [time[index], value];
        } else {
          return value;
        }
      }
    });

    return time.length ? filteredData : filteredData;
  }

  /**
   * Filters the outliers from the given data set based on its standard score (z-score).
   *
   * @memberof stats
   * @static
   * @method normoutliers
   *
   * @param {Object} [params={}] - An object containing optional parameters.
   * @param {Number} [params.low=-0.5] - The lower threshold value for filtering data.
   * @param {Number} [params.high=0.5] - The higher threshold value for filtering data.
   * @param {Object} [args] - An object containing any additional arguments.
   * @param {Array} data - The data set to filter outliers from.
   * @param {Array} [data[0]=[]] - An optional array of timestamps corresponding to the data.
   * @param {Array} data[1] - The main data array containing values to filter outliers from.
   *
   * @returns {Array} Returns the filtered data set. If timestamps are provided, it will return an array of
   * timestamps and filtered data set as [t, out]. If no timestamps are provided, it will return the filtered data set.
   *
   * @example
   *
   * // Filter outliers from the data set between z-scores of -0.5 and 0.5
   * let data = [1, 2, 3, 4, 5, 10, 12, 15, 20];
   * let filteredData = hydro.analyze.stats.normoutliers({ params: { low: -0.5, high: 0.5 }, data: data });
   * // filteredData => [1, 2, 3, 4, 5, 15, 20]
   *
   * // Filter outliers from the data set between z-scores of -1 and 1 with timestamps
   * let data = [[1, 2, 3, 4, 5, 10, 12, 15, 20], [1, 2, 3, 4, 5, 10, 12, 15, 200]];
   * let [timestamps, filteredData] = hydro.analyze.stats.normoutliers({ params: { low: -1, high: 1 }, data: data });
   * // timestamps => [1, 2, 3, 4, 5, 10, 12, 15]
   * // filteredData => [1, 2, 3, 4, 5, 10, 12, 15]
   */

  static normoutliers({ params = {}, args, data } = {}) {
    const { lowerBound = -0.5, upperBound = 0.5 } = params;
    const [time, or] = Array.isArray(data[0]) ? data : [[], data];
    const stnd = this.standardize({ data: or });

    const out = or.filter(
      (_, i) => stnd[i] &lt; lowerBound || stnd[i] > upperBound
    );
    const t = time.filter(
      (_, j) => stnd[j] &lt; lowerBound || stnd[j] > upperBound
    );

    return time.length === 0 ? out : [t, out];
  }

  /**
   * Remove outliers from dataset. It uses p1 and p2 as outliers to remove.
   * @method outremove
   * @memberof stats
   * @param {Object} params - Contains: type ('normalized', 'interquartile')
   * @param {Object} args - Contains: p1 (low end value), p2 (high end value) both depending on outlier analysis type
   * @param {Object} data - Contains: 2d-JS array with time series data as [[time],[data]].
   * @returns {Object[]} Array with cleaned data.
   * @example
   * hydro.analyze.stats.outremove({params: {type: 'someType'}, args: {p1: 'someNum', p2: 'someNum'},
   * data: [[time1, time2,...], [data1, data2,...]]})
   */

  static outremove({ data, args = {}, params = {} } = {}) {
    const {
      replaceValue = 0,
      thresholds = [-9999, 9999],
    } = args;
  
    const isOutlier = (v) =>
      typeof v === 'number' &amp;&amp;
      (v &lt;= thresholds[0] || v >= thresholds[1]);
  
    const convert = (v) => {
      const n = Number(v);
      return isNaN(n) ? v : n;
    };
  
    const clean1D = (arr) => arr.map(v => {
      const num = convert(v);
      return isOutlier(num) ? replaceValue : num;
    });
  
    const clean2D = (arr) => arr.map(sub => clean1D(sub));
  
    const isNamedStructure = (arr) =>
      Array.isArray(arr) &amp;&amp;
      arr.length === 2 &amp;&amp;
      typeof arr[0][0] === 'string' &amp;&amp;
      typeof arr[1][0] === 'string';
  
    if (Array.isArray(data[0])) {
      if (isNamedStructure(data)) {
        const [timeRow, valueRow] = data;
  
        const timeHeader = timeRow[0];
        const valueHeader = valueRow[0];
  
        const timeArray = timeRow.slice(1);
        const valueArray = valueRow.slice(1).map(convert);
  
        const cleanedValues = valueArray.map(v =>
          isOutlier(v) ? replaceValue : v
        );
  
        return [
          [timeHeader, ...timeArray],
          [valueHeader, ...cleanedValues]
        ];
      } else {
        return clean2D(data);
      }
    } else {
      return clean1D(data);
    }
  }
  

  /**
   * Calculates pearson coefficient for bivariate analysis.
   * The sets must be of the same size.
   * @method correlation
   * @memberof stats
   * @param {Object} params.data - An object containing the two data sets as set1 and set2.
   * @returns {Number} Pearson coefficient.
   * @example
   * const data = {set1: [1,2,3], set2: [2,4,6]};
   * const pearsonCoefficient = hydro1.analyze.stats.correlation({data})
   */

  static correlation({ params, args, data } = {}) {
    const { set1, set2 } = data;
    const n = set1.length + set2.length;
    const q1q2 = [];
    const sq1 = [];
    const sq2 = [];

    for (let i = 0; i &lt; set1.length; i++) {
      q1q2[i] = set1[i] * set2[i];
      sq1[i] = set1[i] ** 2;
      sq2[i] = set2[i] ** 2;
    }

    const r1 =
      n * this.sum({ data: q1q2 }) -
      this.sum({ data: set1 }) * this.sum({ data: set2 });
    const r2a = Math.sqrt(
      n * this.sum({ data: sq1 }) - this.sum({ data: set1 }) ** 2
    );
    const r2b = Math.sqrt(
      n * this.sum({ data: sq2 }) - this.sum({ data: set2 }) ** 2
    );

    return r1 / (r2a * r2b);
  }

  /**
   * Calculates various efficiency metrics to evaluate model performance
   * Efficiency metrics are essential for evaluating hydrological model performance by comparing
   * simulated outputs with observed data. These metrics help quantify the accuracy and reliability
   * of models for streamflow prediction, water quality simulation, or other hydrological processes.
   * @method efficiencies
   * @memberof stats
   * @param {Object} params - Contains: type (type of efficiency metric to calculate)
   *                          Options include:
   *                          - 'NSE': Nash-Sutcliffe Efficiency (ranges from -∞ to 1, with 1 being perfect)
   *                          - 'determination': Coefficient of determination (R²) (ranges from 0 to 1)
   *                          - 'agreement': Index of agreement (ranges from 0 to 1)
   *                          - 'all': Calculate all available metrics
   * @param {Array} data - Array containing two arrays: [observed, modeled] values
   * @returns {Number|Object} - A number representing the calculated metric, or an object containing multiple metrics if 'all' is specified
   * @example
   * // Calculate Nash-Sutcliffe Efficiency for a streamflow model
   * const observedFlow = [12.5, 15.2, 22.8, 31.5, 25.4, 18.7, 10.3, 8.2];
   * const modeledFlow = [11.3, 14.7, 20.5, 28.9, 27.1, 16.2, 11.8, 7.5];
   * 
   * const nse = hydro.analyze.stats.efficiencies({ 
   *   params: { type: 'NSE' }, 
   *   data: [observedFlow, modeledFlow] 
   * });
   * console.log(`NSE: ${nse.toFixed(3)}`); // Example: NSE: 0.856
   * 
   * // Calculate all efficiency metrics for model evaluation
   * const metrics = hydro.analyze.stats.efficiencies({ 
   *   params: { type: 'all' }, 
   *   data: [observedFlow, modeledFlow] 
   * });
   * 
   * console.log(`NSE: ${metrics.NSE.toFixed(3)}`);       // Example: 0.856
   * console.log(`R²: ${metrics.r2.toFixed(3)}`);         // Example: 0.923
   * console.log(`Agreement: ${metrics.d.toFixed(3)}`);   // Example: 0.947
   * 
   * // Interpretation guidelines for NSE values in hydrology:
   * // NSE > 0.8: Excellent model performance
   * // 0.6 &lt; NSE &lt; 0.8: Very good performance
   * // 0.4 &lt; NSE &lt; 0.6: Good performance
   * // 0.2 &lt; NSE &lt; 0.4: Poor performance
   * // NSE &lt; 0.2: Unacceptable performance
   */
  static efficiencies({ params, args, data } = {}) {
    let { type } = params,
      [obs, model] = data;
    const meanobs = this.mean({ data: obs });
    const meanmodel = this.mean({ data: model });

    if (type === "NSE") {
      const diff1 = model.map((val, i) => Math.pow(val - obs[i], 2));
      const diff2 = obs.map((val) => Math.pow(val - meanobs, 2));
      const NSE = 1 - this.sum({ data: diff1 }) / this.sum({ data: diff2 });
      return NSE;
    } else if (type === "determination") {
      const diff1 = [];
      const diff2 = [];
      const diff3 = [];

      for (let i = 0; i &lt; obs.length; i++) {
        diff1[i] = (model[i] - meanmodel) * (obs[i] - meanobs);
        diff2[i] = Math.pow(model[i] - meanmodel, 2);
        diff3[i] = Math.pow(obs[i] - meanobs, 2);
      }

      console.log(
        `The values are - Upper: ${this.sum({
          data: diff1,
        })}, Lower: ${this.sum({ data: diff2 })} and ${this.sum({
          data: diff3,
        })}`
      );

      const r = Math.pow(
        this.sum({ data: diff1 }) /
          (Math.sqrt(this.sum({ data: diff2 })) *
            Math.sqrt(this.sum({ data: diff3 }))),
        2
      );
      return r;
    } else if (type === "agreement") {
      const diff1 = obs.map((val, i) => Math.pow(val - model[i], 2));
      const diff2 = obs.map((val, i) =>
        Math.pow(Math.abs(model[i] - meanobs) + Math.abs(val - meanobs), 2)
      );
      const d = 1 - this.sum({ data: diff1 }) / this.sum({ data: diff2 });
      return d;
    }

    if (type === "all") {
      const metrics = {
        NSE: this.efficiencies({
          params: { type: "NSE" },
          data: [obs, model],
        }),
        r2: this.efficiencies({
          params: { type: "determination" },
          data: [obs, model],
        }),
        d: this.efficiencies({
          params: { type: "agreement" },
          data: [obs, model],
        }),
      };
      return metrics;
    }
  }

  /**
   * Fast fourier analysis over a 1d dataset
   * and see if there are any patterns within the data. Should be considered to be used
   * for small data sets.
   * @method fastfourier
   * @memberof stats
   * @param {Object} data - Contains: 1d-JS array with data as [data]
   * @returns {Object[]} calculated array.
   * @example
   * hydro.analyze.stats.fastfourier({data: [someData]})
   */

  static fastFourier({ params, args, data } = {}) {
    const nearest = Math.pow(2, Math.ceil(Math.log2(data.length)));
    let paddedData = tf.pad1d(data, [0, nearest - data.length]);
    const imag = tf.zerosLike(paddedData);
    const complexData = tf.complex(paddedData, imag);
    const fft = tf.spectral.fft(complexData);
    const fftResult = fft.arraySync();
    return fftResult;
  }

  /**
   * Calculates the skewness of a dataset
   * @method skewness
   * @memberof stat
   * @param {Object} params - Contains: none
   * @param {Array} data - Array of numeric values
   * @returns {Number} Skewness value
   * @example
   * hydro.analyze.stats.skewness({data: [1, 2, 3, 4, 5]})
   */
  static skewness({ params, arg, data } = {}) {
    const n = data.length;
    const mean = this.mean({ data: data });
    const sum3 = data.reduce((acc, val) => acc + Math.pow(val - mean, 3), 0);
    const stdDev = Math.sqrt(
      data.reduce((acc, val) => acc + Math.pow(val - mean, 2), 0) / n
    );
    return (n / ((n - 1) * (n - 2))) * (sum3 / Math.pow(stdDev, 3));
  }

  /**
   * Calculates the kurtosis of a dataset
   * @method kurtosis
   * @memberof stat
   * @param {Object} params - Contains: none
   * @param {Array} data - Array of numeri
   * values
   * @returns {Number} Kurtosis value
   * @example
   * hydro.analyze.stats.kurtosis({data: [1
   * 2, 3, 4, 5]})
   */
  static kurtosis({ params, args, data } = {}) {
    const n = data.length;
    const mean = this.mean({ data: data });
    const sum4 = data.reduce((acc, val) => acc + Math.pow(val - mean, 4), 0);
    const stdDev = this.stddev({ data: data });
    return (
      ((n * (n + 1)) / ((n - 1) * (n - 2) * (n - 3))) *
        (sum4 / Math.pow(stdDev, 4)) -
      (3 * Math.pow(n - 1, 2)) / ((n - 2) * (n - 3))
    );
  }

  /**
   * Performs forward fill to replace missin
   * values in an array with the last
   * non-null value
   * @method forwardFill
   * @memberof stat
   * @param {Object} params - Contains: none
   * @param {Array} data - Array of value
   * with missing entries
   * @returns {Object} Object containing th
   * filled data array and an array of
   * replace indices
   * @example hydro.analyze.stats.forwardFi
   * ({data: [1, null, 3, null, null, 6]})
   */
  static forwardFill({ params, args, data } = {}) {
    let previousValue = null;
    let replaceIndices = [];
    const filledData = data.map((value, index) => {
      if (value > 0) {
        previousValue = value;
        return value;
      } else if (previousValue !== null) {
        replaceIndices.push(index);
        return previousValue;
      } else {
        // Handle the case when the first value is missing
        return null;
      }
    });
    return { data: filledData, replaceIndices };
  }

  /**
   * Returns an array that Contains the basic statistics
   * of a dataset. It is used afterwards to be prompted
   * using google graphing tools.
   * @method basicstats
   * @memberof stats
   * @param {Object} data - 1d-JS array with data arranged as [data].
   * @returns {Object[]} flatenned array for the dataset.
   * @example
   * hydro.analyze.stats.basicstats({data: [someData]})
   */

  static basicstats({ params, args, data } = {}) {
    //Can pass time series data as a 2d array without additional manipulation
    typeof data[0] === "object"
      ? (() => {
          data = data[1];
          data.shift();
        })()
      : data;
    data = data.map((val) => JSON.parse(val));
    //if value is outside the values required from the api call
    data = data.map((val) => {
      val > 99998 ? (val = 0) : val;
      return val;
    });
    var temp = [],
      values = [];
    //call the basic functions for analysis.
    values.push("Value");
    values.push(data.length);
    values.push(this.min({ data }));
    values.push(this.max({ data }));
    values.push(this.sum({ data }));
    values.push(this.mean({ data }));
    values.push(this.median({ data }));
    values.push(this.stddev({ data }));
    values.push(this.variance({ data }));
    values.push(this.skewness({ data }));
    values.push(this.kurtosis({ data }));

    temp.push([
      "Metric",
      "Number of values",
      "Minimum Value",
      "Maximum value",
      "Sum",
      "Mean",
      "Median",
      "Standard deviation",
      "Variance",
      "Skewness",
      "Kurtosis",
    ]);
    temp.push(values);
    return temp;
  }

  /***************************/
  /*****Statistic Tests ****/
  /***************************/

  /**
   * Performs the Mann-Kendall trend test for time series data
   * The Mann-Kendall test is a non-parametric statistical test used to identify trends in time series data.
   * In hydrology, it's widely used to detect monotonic trends in climate variables, streamflow, water quality,
   * and other environmental data. This test is particularly valuable because it doesn't require normally
   * distributed data and is robust against outliers.
   * @method MK
   * @memberof stats
   * @param {Object} params - Contains alpha (significance level, default 0.05)
   * @param {Object} data - Array of time series data to test for trend
   * @returns {Object} Results containing:
   *   - S: Mann-Kendall statistic
   *   - z: Standardized test statistic 
   *   - p: p-value of the test
   *   - trend: String indicating detected trend ("increasing", "decreasing", or "no trend")
   *   - significant: Boolean indicating if trend is statistically significant
   * @example
   * // Detect trend in annual streamflow data (m³/s) over 30 years
   * const annualStreamflow = [
   *   105, 98, 102, 95, 90, 100, 92, 87, 93, 85,
   *   88, 82, 80, 85, 78, 75, 80, 76, 72, 70,
   *   75, 68, 65, 72, 67, 62, 65, 60, 58, 55
   * ];
   * 
   * const trendResult = hydro.analyze.stats.MK({
   *   params: { alpha: 0.05 },  // 5% significance level
   *   data: annualStreamflow
   * });
   * 
   * // Interpret the results for water resource management
   * if (trendResult.significant) {
   *   if (trendResult.trend === "decreasing") {
   *     console.log("Significant decreasing trend detected in streamflow");
   *     console.log("Water management implication: Potential water scarcity issues");
   *   } else if (trendResult.trend === "increasing") {
   *     console.log("Significant increasing trend detected in streamflow");
   *     console.log("Water management implication: Potential increased flood risk");
   *   }
   * } else {
   *   console.log("No significant trend detected in streamflow");
   * }
   * console.log(`Test statistic (S): ${trendResult.S}`);
   * console.log(`p-value: ${trendResult.p}`);
   */

  static MK({ params, args, data }) {
    var sum = 0,
      count = 0,
      sum_v = 0.0,
      S_sum = 0.0,
      z = 0.0;
    
    params = params || {};
    const alpha = params.alpha || 0.05;

    var p_equal, p_smaller, p_greater;

    for (var i = 0; i &lt; data.length; i++) {
      for (var j = i + 1; j &lt; data.length; j++) {
        count += 1;
        if (data[j] > data[i]) {
          sum += 1;
        } else if (data[j] == data[i]) {
          sum_v += 1;
        }
      }
    }

    p_equal = sum_v / count;
    p_greater = sum / count;
    p_smaller = 1 - p_greater - p_equal;

    S_sum = sum - (count - sum - sum_v);

    var n = data.length;

    // If n ≤ 10, use the exact variance calculation
    // Otherwise, use the approximation
    var sigma;
    if (n &lt;= 10) {
      var ties = new Map();
      // Count frequencies of values
      for (var i = 0; i &lt; n; i++) {
        if (ties.has(data[i])) {
          ties.set(data[i], ties.get(data[i]) + 1);
        } else {
          ties.set(data[i], 1);
        }
      }

      // Calculate sum for ties correction
      var tieCorrection = 0;
      for (var [_, count] of ties) {
        if (count > 1) {
          tieCorrection += count * (count - 1) * (2 * count + 5);
        }
      }

      sigma = Math.sqrt((n * (n - 1) * (2 * n + 5) - tieCorrection) / 18);
    } else {
      sigma = Math.sqrt((n * (n - 1) * (2 * n + 5)) / 18);
    }

    if (S_sum > 0) {
      z = (S_sum - 1) / sigma;
    } else if (S_sum &lt; 0) {
      z = (S_sum + 1) / sigma;
    } else {
      z = 0;
    }

    var pvalue = 2 * (1 - this.normalcdf({ data: [Math.abs(z)] })[0]);

    const trend = z > 0 ? "increasing" : z &lt; 0 ? "decreasing" : "no trend";
    const significant = pvalue &lt; alpha;

    return { S: S_sum, z, p: pvalue, trend, significant };
  }

  /**
   * Regularized incomplete gamma function approximation using series expansion.
   * @method gammaCDFApprox
   * @memberof stats
   * @param {Object} params - Parameters for the function
   * @param {number} params.alpha - Shape parameter
   * @param {number} params.beta - Scale parameter
   * @param {Object} data - Data input (array with single value x)
   * @returns {number} Regularized incomplete gamma CDF value
   */
  static gammaCDFApprox({ params = {}, args = {}, data } = {}) {
    const { alpha, beta } = params;
    const x = data[0];
    const EPSILON = 1e-8;
    const ITMAX = 100;

    function gammln(zz) {
      const cof = [76.18009172947146, -86.50532032941677,
                   24.01409824083091, -1.231739572450155,
                   0.1208650973866179e-2, -0.5395239384953e-5];
      let x = zz - 1.0;
      let tmp = x + 5.5;
      tmp -= (x + 0.5) * Math.log(tmp);
      let ser = 1.000000000190015;
      for (let j = 0; j &lt; 6; j++) {
        x += 1;
        ser += cof[j] / x;
      }
      return -tmp + Math.log(2.5066282746310005 * ser);
    }

    function gser(a, x) {
      let sum = 1.0 / a;
      let del = sum;
      let ap = a;
      for (let n = 1; n &lt;= ITMAX; n++) {
        ap += 1;
        del *= x / ap;
        sum += del;
        if (Math.abs(del) &lt; Math.abs(sum) * EPSILON) {
          return sum * Math.exp(-x + a * Math.log(x) - gammln(a));
        }
      }
      return sum * Math.exp(-x + a * Math.log(x) - gammln(a));
    }

    function gcf(a, x) {
      let b = x + 1 - a;
      let c = 1 / 1e-30;
      let d = 1 / b;
      let h = d;
      for (let i = 1; i &lt;= ITMAX; i++) {
        let an = -i * (i - a);
        b += 2;
        d = an * d + b;
        if (Math.abs(d) &lt; EPSILON) d = EPSILON;
        c = b + an / c;
        if (Math.abs(c) &lt; EPSILON) c = EPSILON;
        d = 1 / d;
        let delta = d * c;
        h *= delta;
        if (Math.abs(delta - 1.0) &lt; EPSILON) break;
      }
      return Math.exp(-x + a * Math.log(x) - gammln(a)) * h;
    }

    const scaledX = x / beta;
    return scaledX &lt; alpha + 1
      ? gser(alpha, scaledX)
      : 1 - gcf(alpha, scaledX);
  }

  /**
   * Normal distribution
   * @method normalcdf
   * @memberof stats
   * @author Alexander Michalek &amp; Renato Amorim, IFC, University of Iowa.
   * @param {Object[]} data - Contains: 1d-JS array with timeseries
   * @returns {Object[]} 1d array with 3 values: p-value, value sum and z value
   * @param {Object[]} data - 1d-JS array
   * @returns {Number} number value for the distribution
   * @example
   * hydro.analyze.stats.normalcdf({data: [someData]})
   */

  static normalcdf({ params, args, data }) {
    let results = [];
    for (var i = 0; i &lt; data.length; i++) {
      var X = data[i],
        //HASTINGS.  MAX ERROR = .000001
        T = 1 / (1 + 0.2316419 * Math.abs(X)),
        D = 0.3989423 * Math.exp((-X * X) / 2),
        Prob =
          D *
          T *
          (0.3193815 +
            T * (-0.3565638 + T * (1.781478 + T * (-1.821256 + T * 1.330274))));
      if (X > 0) {
        Prob = 1 - Prob;
      }
      results.push(Prob);
    }
    return results;
  }

  /**
   * D-statistic
   * Computes D-statistic from two samples to evaluate if they come from the same distribution
   * Reference: Kottegoda &amp; Rosso, 2008.
   * @method computeD
   * @memberof stats
   * @author Alexander Michalek &amp; Renato Amorim, IFC, University of Iowa.
   * @param {Object[]} data - 2d-JS array containing ordered as [samples_A, samples_B], with each being 1-d arrays
   * @returns {Number} d-statistic of the samples
   * @example
   * hydro.analyze.stats.computeD({data: [samples_A, samples_B]})
   */
  static computeD({ params, args, data }) {
    var { sampleA, sampleB } = data,
      maximumDifference = 0,
      N = 1e3;
    let minimum = this.min({ data: sampleA.concat(sampleB) }),
      maximum = this.max({ data: sampleA.concat(sampleB) }),
      N_A = sampleA.length,
      N_B = sampleB.length;

    for (var x of this.range({ params: { N }, data })) {
      var CDF_A = sampleA.filter((d) => d &lt;= x).length / N_A,
        CDF_B = sampleB.filter((d) => d &lt;= x).length / N_B,
        difference = Math.abs(CDF_A - CDF_B);

      if (difference > maximumDifference) {
        maximumDifference = difference;
      }
    }
    return maximumDifference;
  }

  /**
   * Kolmogorov Smirnov Two-sided Test
   * Calculates the P value, based on the D-statistic from the function above.
   * Reference: Kottegoda &amp; Rosso, 2008.
   * @method KS_computePValue
   * @memberof stats
   * @author Alexander Michalek &amp; Renato Amorim, IFC, University of Iowa
   * @param {Object[]} data - 2d-JS array containing ordered as [samples_A, samples_B], with each being 1-d arrays
   * @returns {Object[]} array with [p-Statistic, d-Statistic]
   * @example
   * hydro.analyze.stats.KS_computePValue({data: [samples_A, samples_B]})
   */
  static KS_computePValue({ params, args, data }) {
    var samples_A = data[0],
      samples_B = data[1],
      d = this.computeD({ data: [samples_A, samples_B] }),
      n = samples_A.length,
      m = samples_B.length,
      p = 2 * Math.exp((-2 * d * d * (n * m)) / (n + m));
    return [p, d];
  }

  /**
   * Reject P statistic based on a significance level alpha.
   * Reference: Kottegoda &amp; Rosso, 2008.
   * @method KS_rejectAtAlpha
   * @memberof stats
   * @author Alexander Michalek &amp; Renato Amorim, IFC, University of Iowa
   * @param {Object} params - contains {alpha: Number} with alpha being the significance level
   * @param {Object[]} data - 2d-JS array containing ordered as [samples_A, samples_B], with each being 1-d arrays
   * @returns {Number} rejection if p is less than the significance level
   * @example
   * hydro.analyze.stats.KS_rejectAtAlpha({params: {alpha: someAlpha}, data: [samples_A, samples_B]})
   */
  static KS_rejectAtAlpha({ params, args, data }) {
    let [p, d] = this.KS_computePValue({ data: data });
    return p &lt; params.alpha;
  }

  /**

Computes the probability density function
of a normal distribution.
@method normalDistribution
@memberof stats
@param {Object} params - Contains:
z-value.
@returns {Number} Probability density
function of the normal distribution.
@example
hydro.analyze.stats.normalDistributio
({params: {z: 1.5}})
*/
  static normalDistribution({ params, args, data }) {
    return Math.exp(-(Math.log(2 * Math.PI) + params.z * params.z) * 0.5);
  }

  /**
   * Generates a random simulated number when run with a dataset
   * @method runSimulation
   * @author riya-patil
   * @memberof stats
   * @param {Object} data - passes data from an object
   * @returns {Number} Returns a simulated number
   * @example 
   * const testData = [
      [1, 2, 3, 4, 5],
      [6, 7, 8, 9, 10],
      [11, 12, 13, 14, 15],
    ];
    hydro.analyze.stats.simulate({data: testData})
   * 
   */
    static runSimulation({ params, args, data } = {}) {
      const { multiplier } = params || 1; //defaults to 1
      const genRan = (min, max) => Math.random() * (max - min) + min;
      const mean = this.mean({ data });
      const std = this.stddev({ data });
      const simNum = genRan(mean - std * multiplier, mean + std * multiplier);
      return simNum;
    }    

/**
   * Generates a random simulated number when run with a dataset
   * @method runMonteCarlo
   * @author riya-patil
   * @memberof stats
   * @param {Object[]} data - passes data from multiple objects
   * @returns {number[]} returns an array of the simulated results
   * @example 
   * const testData = [
      [1, 2, 3, 4, 5],
      [6, 7, 8, 9, 10],
      [11, 12, 13, 14, 15],
    ];
    hydro.analyze.stats.runMonteCarlo({data: testData})
   */
    static runMonteCarlo({ params, args, data } = {}) {
      const { iterations = 100, callback } = params || {};
      // Extract iterations and callback from params
      const results = [];
    
      for (let i = 0; i &lt; iterations; i++) {
        let simResult;
        if (callback) {
          simResult = callback({ params, args, data });
        } else {
          const value = data;
          simResult = this.runSimulation({ data: value });
        }
        results.push(simResult);
      }
    
      return results;
    }
    
  
/**
   * Generates a random simulated number when run with a dataset
   * @method runVegas
   * @author riya-patil
   * @memberof stats
   * @param {Object[]} data - passes data from multiple objects
   * @returns {number[]} returns an array of the simulated results
   * @example
   * const testData = [
      [1, 2, 3, 4, 5],
      [6, 7, 8, 9, 10],
      [11, 12, 13, 14, 15],
    ];
    hydro.analyze.stats.runVegas({data: testData})
   */
    static runVegas({ params, args, data } = {}) {
      const { iterations = 100, callback } = params || {};
      // Extract iterations and callback from params
      const results = [];
    
      for (let i = 0; i &lt; iterations; i++) {
        let simResult;
        if (callback) {
          simResult = callback({ params, args, data });
        } else {
          // Implementation details for the simulation without a callback
          for (let value of data) {
            const simValue = this.runSimulation({ data: value });
            results.push(simValue);
          }
        }
      }
    
      return results;
    }
    

/**
 * Computes the probability density function (PDF) of a Gaussian (normal) distribution
 * @method gaussianDist
 * @author riya-patil
 * @memberof stats
 * @param {Object} params - x (value at which to compute the PDF), mean (mean of the distribution), 
 * and stddev (standard deviation of the distribution)
 * @returns {Number} Probability density function of the Gaussian distribution
 * @example
 * const testData = {
    x: 2.5,
    mean: 3,
    stddev: 1.2
  };
  hydro.analyze.stats.gaussianDist({params: testData});
 */
  static gaussianDist({ params, args, data }) {
    const { x, mean, stddev } = params;
    const exponent = -((x - mean) ** 2) / (2 * stddev ** 2);
    const coefficient = 1 / (stddev * Math.sqrt(2 * Math.PI));
  
    return coefficient * Math.exp(exponent);
  }
  
  /**
   * Probability mass function (PMF) of a Bernoulli distribution
   * The Bernoulli distribution is a discrete probability distribution for a random variable that takes the value 1 
   * with probability of success p and the value 0 with probability of failure (1-p).
   * It models binary outcomes like success/failure, yes/no, or true/false.
   * @method bernoulliDist
   * @author riya-patil
   * @memberof stats
   * @param {Object} params - Contains: f (indicator for failure=0 or success=1) and s (probability of success, between 0 and 1)
   * @returns {Number} Probability mass function of the Bernoulli distribution at the specified point
   * @example
   * // Calculate probability of success (f=1) with p=0.7
   * hydro.analyze.stats.bernoulliDist({ params: { f: 1, s: 0.7 } }); // Returns 0.7
   * 
   * // Calculate probability of failure (f=0) with p=0.7
   * hydro.analyze.stats.bernoulliDist({ params: { f: 0, s: 0.7 } }); // Returns 0.3
   */
  static bernoulliDist({params, args, data} = {}) {
    const { f, s } = params; //f = failure, s = success
    if (f === 0) {
      return 1 - s;
    } else if (f === 1) {
      return s;
    } else {
      return 0;
    }
  }
  
  /**
   * Computes the probability density function (PDF) of the Generalized Extreme Value (GEV) distribution
   * The GEV distribution is widely used in hydrology for modeling extreme events like maximum rainfall
   * or flood discharges. It combines three extreme value distributions: Gumbel (Type I),
   * Fréchet (Type II), and Weibull (Type III) into a single parametric family.
   * @method gevDistribution
   * @author riya-patil
   * @memberof stats
   * @param {Object} params - Contains: 
   *                        x (value at which to compute the PDF), 
   *                        mu (location parameter, determines the mode of the distribution),
   *                        sigma (scale parameter > 0, controls the spread of the distribution), 
   *                        xi (shape parameter, determines the tail behavior - xi=0 gives Gumbel, xi>0 gives Fréchet, xi&lt;0 gives Weibull)
   * @returns {Number} Probability density function value of the GEV distribution at point x
   * @example
   * // Calculate PDF for Gumbel distribution (xi=0)
   * hydro.analyze.stats.gevDistribution({
   *   params: { 
   *     x: 50,      // Value at which to evaluate the PDF
   *     mu: 30,     // Location parameter
   *     sigma: 10,  // Scale parameter
   *     xi: 0       // Shape parameter (Gumbel distribution)
   *   }
   * });
   * 
   * // Calculate PDF for Fréchet distribution (xi>0)
   * hydro.analyze.stats.gevDistribution({
   *   params: { 
   *     x: 50,
   *     mu: 30,
   *     sigma: 10,
   *     xi: 0.2     // Positive shape parameter (heavy tail)
   *   }
   * });
   */
  static gevDistribution({params, args, data} = {}) {
    const { x, mu, sigma, xi } = params;
    const z = (x - mu) / sigma;
    
    if (xi === 0) {
      // Calculate the PDF for the Gumbel distribution
      const exponent = -z - Math.exp(-z);
      return Math.exp(exponent) / sigma;
    } else {
      // Calculate the PDF for the Generalized Extreme Value (GEV) distribution
      const firstTerm = Math.pow(1 + xi * z, -(1 / xi + 1));
      const secondTerm = Math.exp((-(1 + xi * z)) ** (-1 / xi));
      return firstTerm * secondTerm / sigma;
    }
  }

  /**
 * Calculates the probability mass function (PMF) of a Geometric Distribution
 * @method geometricDist
 * @author riya-patil
 * @memberof stats
 * @param {Object} params - Contains the probability of success "s" (where 0 &lt;= s &lt;= 1) as a parameter.
 * @param {Number} args - Contains the number of trials until the first success trials (trials >= 1)
 * @returns {Number} The probability of getting the first success on the n-th trial
 * @example
 * hydro.analyze.stats.geometricDist({ params: { s: 0.5 }, args: { trials: 3 }, data: [] });
 * 0.125
 */
static geometricDist({params, args, data} = {}) {
  const { s } = params || 1;
  const { trials } = args;
  if (trials &lt; 1) {
    return 0;
  }
  return (1 - s) ** (trials - 1) * s;
}

/**
 * Calculates the probability mass function (PMF) of a Binomial Distribution
 * The binomial distribution models the number of successes in a fixed number of independent
 * trials, each with the same probability of success. In hydrology, it can be used to model
 * discrete event occurrences like the number of days with rainfall exceeding a threshold
 * in a given month, or the number of flood events in a year.
 * @method binomialDist
 * @author riya-patil
 * @memberof stats
 * @param {Object} params - Contains: trials (integer n ≥ 0, the total number of independent trials)
 *                        and probSuccess (probability p of success in a single trial, 0 ≤ p ≤ 1)
 * @param {Object} args - Contains: s (integer k, 0 ≤ k ≤ n, representing the number of successes)
 * @returns {Number} The probability of getting exactly k successes in n trials with probability p of success
 * @example
 * // Calculate the probability of exactly 3 rainy days out of 10 days,
 * // when the probability of rain on any given day is 0.3
 * hydro.analyze.stats.binomialDist({ 
 *   params: { 
 *     trials: 10,       // 10 days observed
 *     probSuccess: 0.3  // 30% chance of rain on any given day
 *   }, 
 *   args: { 
 *     s: 3              // We want exactly 3 rainy days
 *   }
 * }); // Returns approximately 0.2668
 * 
 * // Find the probability of having at most 2 flood events in 5 years
 * // when annual probability of a flood is 0.2
 * // First calculate P(X=0) + P(X=1) + P(X=2)
 * const p0 = hydro.analyze.stats.binomialDist({ params: { trials: 5, probSuccess: 0.2 }, args: { s: 0 }});
 * const p1 = hydro.analyze.stats.binomialDist({ params: { trials: 5, probSuccess: 0.2 }, args: { s: 1 }});
 * const p2 = hydro.analyze.stats.binomialDist({ params: { trials: 5, probSuccess: 0.2 }, args: { s: 2 }});
 * const atMost2 = p0 + p1 + p2; // Gives the cumulative probability
 */
static binomialDist({params, args, data} = {}) {
  const { trials, probSuccess } = params;
  const { s } = args;

  if (s &lt; 0 || s > trials) {
    return 0;
  }

  const coefficient = this.binomialCoefficient(trials, s);
  const probability = coefficient * (probSuccess ** s) * ((1 - probSuccess) ** (trials - s));
  return probability;
}

/**
 * Multinomial Distribution - Generates random samples from a multinomial distribution.
 * @method multinomialDistribution
 * @author riya-patil
 * @memberof stats
 * @param {Object} params probabilities: 1D array of probabilities for each category; n: Number of samples to generate
 * @returns {Object} samples: 2D array of generated samples, where each row represents a sample and each column represents a category
 * frequencies: 2D array of frequencies for each category in the generated samples
 * @example
 * const multinomialData = {
 *   probabilities: [0.2, 0.3, 0.5],
 *   n: 100
 * };
 * hydro.analyze.stats.multinomialDistribution({ params: multinomialData });
 */
static multinomialDistribution({params, args, data} = {}) {
  const { probabilities, n } = params;

  const numCategories = probabilities.length;
  const samples = [];
  const frequencies = [];

  for (let i = 0; i &lt; n; i++) {
    const sample = [];
    let remainingProb = 1;

    for (let j = 0; j &lt; numCategories - 1; j++) {
      const prob = probabilities[j];
      const rand = Math.random() * remainingProb;
      const count = Math.floor(rand / prob);
      sample.push(count);
      remainingProb -= count * prob;
    }

    const lastCategoryCount = Math.floor(remainingProb / probabilities[numCategories - 1]);
    sample.push(lastCategoryCount);

    samples.push(sample);
    frequencies.push(this.frequency({data : sample}));
  }

  return { samples, frequencies };
}


/** Calculates the probability mass function (PMF) of the Log series Distribution
   * @method LogSeriesDistribution 
   * @author riya-patil
   * @memberof stats
   * @param {Object} params - Contains the parameter 'probSuccess' which represents the probability of success in a single trial.
   * @param {Object} args - Contains the argument 'trials' (trials >= 1) which represents the number of trials.
   * @returns {Number} Probability of achieving the first success in # of trials.
   * @example
   * hydro.analyze.stats.logSeriesDist({params: {probSuccess: 0.2, trials: 3}})
   */
static logSeriesDist({params, args, data} = {}) {
  const { probSuccess, trials } = params;
  
  if (trials &lt; 1) {
    return 0;
  }
  
  const pmf = -Math.log(1 - probSuccess) * Math.pow(probSuccess, trials) / trials;
  return pmf;
}

 /** Calculates the probability density function (PDF) of the Lognormal Distribution
   * @method lognormalDist 
   * @author riya-patil
   * @memberof stats
   * @param {Object} params - Contains the parameters 'mu' and 'sigma' which represent the mean and standard deviation of the associated normal distribution.
   * @param {Object} args - Contains the argument 'x' which represents the value at which to evaluate the PDF.
   * @returns {Number} Probability density at 'x' in the Lognormal Distribution.
   * @example 
   * hydro.analyze.stats.lognormalDist({params: { mu: 0, sigma: 1 }, args: { x: 2 }})
   */
 static lognormalDist({params, args, data} = {}) {
  const { mu, sigma } = params;
  const { x } = args;

  if (x &lt;= 0) {
    return 0;
  }

  const exponent = -((Math.log(x) - mu) ** 2) / (2 * sigma ** 2);
  const pdf = (1 / (x * sigma * Math.sqrt(2 * Math.PI))) * Math.exp(exponent);

  return pdf;
}

/** Calculates the probability density function (PDF) of the Gumbel Distribution
   * @method gumbelDist 
   * @author riya-patil
   * @memberof stats
   * @param {Object} params - Contains the parameters 'mu' (location parameter) and 'beta' (scale parameter).
   * @returns {Number} Probability density at the given value 'x'.
   * @example
   * hydro.analyze.stats.gumbelDist({ params: { mu: 0, beta: 1, x: 2}})
   */
static gumbelDist({params, args, data} = {}) {
  const { mu, beta } = params;
  const { x } = args;
  
  const z = (x - mu) / beta;
  const pdf = (1 / beta) * Math.exp(-(z + Math.exp(-z)));
  
  return pdf;
}

/** Calculates the probability density function (PDF) of the Uniform Distribution
   * @method uniformDist 
   * @author riya-patil
   * @memberof stats
   * @param {Object} params - Contains the parameters 'a' (lower bound) and 'b' (upper bound).
   * @param {Object} args - Contains the argument 'x' at which to evaluate the PDF.
   * @returns {Number} Probability density at the given value 'x'.
   * @example
   * hydro.analyze.stats.uniformDist({ params: { a: 0, b: 1 }, args: { x: 0.5 } })
   */
static uniformDist({params, args, data} = {}) {
  const { a, b } = params;
  const { x } = args;
  
  if (x >= a &amp;&amp; x &lt;= b) {
    const pdf = 1 / (b - a);
    return pdf;
  } else {
    return 0;
  }
}

/** Calculates the Simple Moving Average of a given data set
   * @method simpleMovingAverage 
   * @author riya-patil
   * @memberof stats
   * @param {Object} params - Contains the parameter 'windowSize' which specifies the size of the moving average window.
   * @param {Object} data - Contains the array of data points.
   * @returns {Array} Array of moving average values.
   * @example
   * const data = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
   * const windowSize = 3;
   * hydro.analyze.stats.simpleMovingAverage({ params: { windowSize }, data });
   */
static simpleMovingAverage({params, args, data} = {}) {
  const { windowSize } = params;

  if (windowSize &lt;= 0 || windowSize > data.length) {
    throw new Error("Invalid window size.");
  }

  const movingAverage = [];

  for (let i = 0; i &lt;= data.length - windowSize; i++) {
    const window = data.slice(i, i + windowSize);
    const sum = window.reduce((total, value) => total + value, 0);
    const average = sum / windowSize;
    movingAverage.push(average);
  }

  return movingAverage;
}

/**
 * Calculates the Linear Moving Average (LMA) of a given dataset.
 * @method linearMovingAverage
 * @author riya-patil
 * @memberof stats
 * @param {Number} params - Contains the windowSize parameter.
 * @param {Array} data - 1D array of numerical values.
 * @returns {Array} Array of moving averages.
 * @throws {Error} If the window size is invalid.
 * @example
 * const windowSize = 5;
 * const data = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
 * hydro.analyze.stats.linearMovingAverage({ windowSize, data });
 */
static linearMovingAverage({params, args, data} = {}) {
  const { windowSize } = params;

  if (windowSize &lt;= 0 || windowSize > data.length) {
    throw new Error("Invalid window size.");
  }

  const movingAverage = [];
  let sum = 0;
 
  for (let i = 0; i &lt; windowSize; i++) {
	sum += data[i];
  }
 
  movingAverage.push(sum / windowSize);
 
  for (let i = windowSize; i &lt; data.length; i++) {
	sum += data[i] - data[i - windowSize];
    movingAverage.push(sum / windowSize);
  }
 
  return movingAverage;
}

/**
 * Computes the Exponential Moving Average (EMA) for a given dataset.
 * @method exponentialMovingAverage
 * @author riya-patil
 * @memberof stats
 * @param {Object} args - Contains the dataset as 'data' (1D JavaScript array) and the 'alpha' value (smoothing factor between 0 and 1)
 * @returns {number[]} The Exponential Moving Average (EMA) values for the dataset
 * @example
 *const dataset= [1,2,3,4,5]
 *const params={alpha: 0.5}
 *hydro.analyze.stats.exponentialMovingAverage({params, data});
*/

static exponentialMovingAverage({params, args, data} = {}) {
  const { alpha } = params;
  const emaValues = [];
  let ema = data[0];

  for (let i = 1; i &lt; data.length; i++) {
    ema = alpha * data[i] + (1 - alpha) * ema;
    emaValues.push(ema);
  }

  return emaValues;
}

/**
 * Generates a sequence of events following a Poisson process
 * A Poisson process models the occurrence of random events where the time between events
 * follows an exponential distribution. In hydrology, this is useful for modeling random
 * occurrences such as rainfall events, flood peaks, or extreme weather phenomena that
 * happen at a known average rate but with random timing.
 * @method poissonProcess
 * @author riya-patil
 * @memberof stats
 * @param {Object} params - Contains: 
 *                         - lambda (event rate, average number of events per time unit)
 *                         - timeFrame (duration for which to simulate the process)
 *                         - type (optional, "time" for event times or "count" for event counts in intervals)
 * @returns {Array} For type="time": Array of time points when events occur
 *                 For type="count": Array of counts per unit time interval
 * @example
 * // Scenario: Generate a synthetic sequence of storm events over a 30-day period
 * // Assuming storms occur at a rate of 0.2 per day (on average, 1 storm every 5 days)
 * 
 * // Get the timing of storm events over the 30-day period
 * const stormTimes = hydro.analyze.stats.poissonProcess({
 *   params: {
 *     lambda: 0.2,      // Rate of 0.2 storms per day
 *     timeFrame: 30,    // 30-day simulation period
 *     type: "time"      // Return the timing of events
 *   }
 * });
 * console.log("Storm events occur at days:", stormTimes);
 * // Example output: [3.2, 8.7, 15.4, 21.1, 28.9]
 * 
 * // Or get the daily count of storms for each day in the 30-day period
 * const dailyStormCounts = hydro.analyze.stats.poissonProcess({
 *   params: {
 *     lambda: 0.2,      // Rate of 0.2 storms per day
 *     timeFrame: 30,    // 30-day simulation period
 *     type: "count"     // Return counts per interval
 *   }
 * });
 * // Example output: [0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0]
 * 
 * // This synthetic data can be used for:
 * // - Testing rainfall-runoff models with varying storm patterns
 * // - Evaluating flood risk under different precipitation scenarios
 * // - Studying reservoir operation under random inflow conditions
 */
static poissonProcess({params, args, data} = {}) {
  const { lambda, timeFrame, type = "time" } = params;
  const { rateFunction } = args;

  if (type === "time") {
    const eventTimes = [];
    let currentTime = 0;
    
    while (currentTime &lt; timeFrame) {
      // Generate time to next event based on exponential distribution
      const timeToNextEvent = -Math.log(Math.random()) / lambda;
      currentTime += timeToNextEvent;
      
      if (currentTime &lt; timeFrame) {
        eventTimes.push(currentTime);
      }
    }
    
    return eventTimes;
  } else if (type === "count") {
    const counts = new Array(Math.ceil(timeFrame)).fill(0);
    
    // Generate event times
    const eventTimes = this.poissonProcess({
      params: { lambda, timeFrame, type: "time" }
    });
    
    // Count events per unit time
    for (const time of eventTimes) {
      const timeIndex = Math.floor(time);
      if (timeIndex &lt; counts.length) {
        counts[timeIndex]++;
      }
    }
    
    return counts;
  } else {
    throw new Error("Invalid type. Use 'time' or 'count'.");
  }
}

/**
 * Calculates the return period for a given probability of occurrence
 * In hydrology, the return period (or recurrence interval) represents the average time between events
 * of a certain magnitude. It is fundamental for flood frequency analysis, infrastructure design, and
 * risk assessment. The return period T is calculated as T = 1/p, where p is the probability of 
 * exceedance in a given year.
 * @method returnPeriod
 * @memberof stats
 * @param {Object} params - Contains probability (decimal between 0 and 1, probability of occurrence in a given time unit)
 * @returns {Number} Return period (average time between events of the specified probability)
 * @throws {Error} If probability is not between 0 and 1
 * @example
 * // Calculate the return period for a flood with a 0.01 (1%) annual exceedance probability
 * const hundredYearFlood = hydro.analyze.stats.returnPeriod({
 *   params: { probability: 0.01 }
 * });
 * // Returns 100 (years)
 * 
 * // Calculate return periods for different design events
 * const designEvents = [
 *   { name: "2-year event", probability: 0.5 },
 *   { name: "10-year event", probability: 0.1 },
 *   { name: "25-year event", probability: 0.04 },
 *   { name: "50-year event", probability: 0.02 },
 *   { name: "100-year event", probability: 0.01 },
 *   { name: "500-year event", probability: 0.002 }
 * ];
 * 
 * // Calculate and display the return periods
 * designEvents.forEach(event => {
 *   const period = hydro.analyze.stats.returnPeriod({
 *     params: { probability: event.probability }
 *   });
 *   console.log(`${event.name}: ${period} years`);
 * });
 * 
 * // This information can be used for:
 * // - Designing hydraulic structures like bridges, culverts, and dams
 * // - Establishing flood insurance rates and floodplain regulations
 * // - Assessing risk for critical infrastructure
 */
static returnPeriod({params, args, data} = {}) {
  const { probability } = params;
  if (probability &lt;= 0 || probability >= 1) {
    throw new Error("Probability must be between 0 and 1 (exclusive).");
  }

  return 1 / probability;
}

/**
 * Performs differencing on a time series dataset to remove trend or seasonality from the data
 * @method differencing
 * @author riya-patil
 * @memberof stats
 * @param {Object} params - Contains the order parameter
 * @param {Array} data - 1D array of numerical values representing a time series
 * @returns {Array} Differenced time series
 * @throws {Error} If the order is invalid
 * @example
 * const order = 1;
 * const timeSeries = [1, 3, 6, 10, 15];
 * const differencedSeries = stats.differencing({ order, data: timeSeries });
 */
static differencing({params, args, data} = {}) {
  const order = params.order;
  const timeSeries = data;

  if (order >= timeSeries.length) {
    throw new Error('Invalid order for differencing.');
  }

  const differencedSeries = timeSeries.slice(order).map((value, i) => value - timeSeries[i]);
  return differencedSeries
}

/**
 * Computes the variance of residuals in a regression model to detect heteroskedasticity
 * @method residualVariance
 * @author riya-patil
 * @memberof stats
 * @param {Array} data - 1D array of numerical values representing the residuals.
 * @returns {number} Variance of residuals
 * @returns {Error} if not given valid array of residuals or not given correct number of arrays
 * @example
 * const residuals = [1.5, -2.1, 0.8, -1.2, 2.5];
 * const variance = stats.residualVariance({ data: residuals });
 */
static residualVariance({params, args, data} = {}) {
  const residuals = data;

  if (!Array.isArray(residuals)) {
    throw new Error('Invalid data. Expecting an array of residuals.');
  }
   
  if (residuals.length &lt; 2) {
    throw new Error('Insufficient data. Expecting an array of at least 2 residuals.');
  }

  const squaredResiduals = residuals.map((residual) => residual * residual);
  const variance = squaredResiduals.reduce((sum, value) => sum + value, 0) / squaredResiduals.length;

  return variance;
}

/**
 * Computes the coefficients of a linear regression model.
 * @method regression
 * @author riya-patil
 * @memberof stats
 * @param {Object} data - Object containing predictor variables (X) and target variable (y).
 * @returns {Array} Coefficients of the linear regression model.
 * @example
 * const X = [[1, 2], [3, 4], [5, 6]];
 * const y = [3, 5, 7];
 * hydro.analyze.stats.regression({ data: { X, y } });
 */
static regression({params, args, data} = {}) {
  const X = data.X; // Matrix of predictor variables
  const y = data.y; // Array of target variable

  const XWithIntercept = X.map((row) => [1, ...row]);

  const Xint = multiplyMatrix(transposeMatrix(XWithIntercept), XWithIntercept);
  const Yint = multiplyMatrix(transposeMatrix(XWithIntercept), y);

  const inverseXtX = matrixInverse(Xint);

  const coefficients = multiplyMatrix(inverseXtX, Yint);

  return coefficients;
}

/**
 * Performs multivariate regression analysis
 * @method multiregression
 * @author riya-patil
 * @memberof stats
 * @param {Object} data - Data for the multivariate regression
 * @returns {Array} Coefficients of the linear regression model.
 * @example
 * const X = [[1, 2], [3, 4], [5, 6]];
 * const y = [3, 5, 7];
 * hydro.analyze.stats.multiregression({ data: { X, y } });
 */
static multiregression({params, args, data} = {}) {
  const X = data.X; // Matrix of predictor variables
  const Y = data.Y; // Array of target variables

  const coefficients = [];
  for (let i = 0; i &lt; Y.length; i++) {
    const y = Y[i];
    const regressionData = { X, y };
    const coefficient = this.regression({ data: regressionData });
    coefficients.push(coefficient);
  }

  return coefficients;
}

/**
 * Performs White's test for heteroscedasticity
 * @method whitesTest
 * @author riya-patil
 * @param {Object} params - Parameters for the test, errors is array of residuals while regressors is array of regressor vars
 * @returns {Object} Object containing test statistic and p-value
 * @throws {Error} If the input arrays have different lengths
 * @example
 * const params = {
 *   errors: [1, 2, 3, 4, 5],
 *   regressors: [[1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]
 * };
 * hydro.analyze.stats.whitesTest({ params });
 */
static whitesTest({ params }) {
  const { errors, regressors } = params;

  if (errors.length !== regressors.length) {
    throw new Error("Input arrays must have the same length.");
  }

  const n = errors.length;
  const k = regressors[0].length; // Number of regressors (variables)

  let XX = 0;
  let XE = 0;
  let EE = 0;

  for (let i = 0; i &lt; n; i++) {
    const error = errors[i];
    const regressor = regressors[i];

    XX += this.dotProduct(regressor, regressor);
    XE += this.dotProduct(regressor, error); // Adjust for the size of the regressors
    EE += error ** 2;
  }

  const testStatistic = n * (XE ** 2) / (XX * EE);
  const pValue = 1 - this.chisqCDF(testStatistic, k);

  return { testStatistic, pValue };
}

/**
 * Performs the Breusch-Pagan test for heteroscedasticity.
 * @method breuschPaganTest
 * @author riya-patil
 * @memberof stats
 * @param {Object} params errors: Array of residuals, regressors: Array of regressor variables
 * @returns {Object} Object containing test statistic and p-value.
 * @throws {Error} If the input arrays have different lengths.
 * @example
 * const params = {
 *   errors: [1, 2, 3, 4, 5],
 *   regressors: [[1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]
 * };
 * hydro.analyze.stats.breuschPaganTest({ params });
 */
static breuschPaganTest({ params }) {
  const { errors, regressors } = params;

  if (errors.length !== regressors.length) {
    throw new Error("Input arrays must have the same length.");
  }

  const n = errors.length;
  const k = regressors[0].length;

  let residualsSquared = [];

  for (let i = 0; i &lt; n; i++) {
    const error = errors[i];
    residualsSquared.push(error ** 2);
  }

  let XX = 0;
  let XR = 0;
  let RR = 0;

  for (let i = 0; i &lt; n; i++) {
    const regressor = regressors[i];
    const residualSquared = residualsSquared[i];

    const dotProduct = dotProduct(regressor, regressor);
    XX += dotProduct;
    XR += dotProduct * residualSquared;
    RR += residualSquared ** 2;
  }

  const testStatistic = (n / 2) * (Math.log(XR) - (1 / n) * Math.log(XX));
  const pValue = 1 - chisqCDF(testStatistic, k);

  return { testStatistic, pValue };
}

/**
 * Performs Goldfeld-Quandt test for heteroscedasticity
 * @method goldfeldQuandtTest
 * @author riya-patil
 * @param {Object} params - residuals (Array of residuals from a regression model), independentVar (Array of values of the independent variable)
 * @returns {Object} Object containing test statistic and p-value
 * @throws {Error} If the input arrays have different lengths
 * @example
 * const residuals = [1.2, 2.3, 0.8, 1.9, 1.5, 2.6];
 * const independentVar = [3, 4, 5, 6, 7, 8];
 * const result = stats.goldfeldQuandtTest({ params: { residuals, independentVar } });
 * console.log(result);
 */
static goldfeldQuandtTest({ params, args, data }) {
  const { residuals, independentVar } = params;

  if (residuals.length !== independentVar.length) {
    throw new Error("Input arrays must have the same length.");
  }

  const n = residuals.length;
  const k = Math.floor(n * 0.4); // 40% of the data in each subset

  const sortedIndices = independentVar.map((_, index) => index).sort((a, b) => independentVar[a] - independentVar[b]);

  const lowSubsetIndices = sortedIndices.slice(0, k);
  const highSubsetIndices = sortedIndices.slice(-k);

  const lowResiduals = lowSubsetIndices.map((index) => residuals[index]);
  const highResiduals = highSubsetIndices.map((index) => residuals[index]);

  const testStatistic = (Math.max(...highResiduals) ** 2) / (Math.min(...lowResiduals) ** 2);

  const pValue = 1 - chisqCDF(testStatistic, k - 1);

  return { testStatistic, pValue };
}



/**
   * Generates a random simulated number when run with a dataset
   * @method runMarkovChainMonteCarlo
   * @author riya-patil
   * @memberof stats
   * @param {Object[]} data - passes data from multiple objects
   * @returns {number[]} returns an array of the simulated results
   * @example 
   * const options = {
      params: {
      iterations: 100,
    },
    data: {
      initialState,
      transitionMatrix,
      },
    };
    hydro.analyze.stats.runMarkovChainMonteCarlo(options);
   */
static runMarkovChainMonteCarlo({ params, args, data } = {}) {
  const { iterations = 100, callback } = params || {};
  const results = [];
  let currentState = data.initialState;

  for (let i = 0; i &lt; iterations; i++) {
    let nextState;
    if (callback) {
      nextState = callback({ params, args, data, currentState });
    } else {
      nextState = getNextState(data.transitionMatrix, currentState);
    }
    results.push(nextState);
    currentState = nextState;
  }

  return results;
}
 
  /***************************/
  /***** Helper functions ****/
  /***************************/

  /**
   * Preprocessing tool for joining arrays for table display.
   * @method joinarray
   * @memberof stats
   * @param {Object} data - 2d-JS array as [[someData1], [someData2]]
   * @returns {Object[]} Array for table display.
   * @example
   * hydro.analyze.stats.joinarray({data: [[someData1], [someData2]]})
   */

  static joinarray({ params, arg, data } = {}) {
    var temp = [];
    for (var i = 1; i &lt; data[0].length; i++) {
      if (!temp[i]) {
        temp[i] = [];
      }
      temp[i] = [data[0], data[1]].reduce((a, b) => a.map((v, i) => v + b[i]));
    }
    return temp;
  }

  /**
   * Helper function for preparing nd-JSarrays for charts and tables for duration/discharge.
   * @method flatenise
   * @memberof stats
   * @param {Object} params - Contains: columns (nd-JS array with names as [someName1, someName2,...])
   * @param {Object} data - Contains: nd-JS array object required to be flatenned as [[somedata1, somedata2,...],[somedata1, somedata2,...],...]
   * @returns {Object[]} Flatenned array.
   * @example
   * hydro.analyze.stats.flatenise({params:{columns: [someName1, someName2,...]},
   * data: [[somedata1, somedata2,...],[somedata1, somedata2,...],...]})
   */

  static flatenise({ params, args, data } = {}) {
    var x = params.columns;
    var d = data;
    var col = [];
    var dat = [];
    for (var i = 0; i &lt; x.length; i++) {
      col.push(x[i]);
    }
    for (var j = 0; j &lt; d.length; j++) {
      dat.push(d[j].flat());
    }
    return [col, dat];
  }

  /**
   * Turns data from numbers to strings. Usable when
   * retrieving data or uploading data.
   * @method numerise
   * @memberof stats
   * @param {Object} data - Contains: 1d-JS array with data composed of strings as [dataValues].
   * @returns {Object[]} Array as numbers.
   * @example
   * hydro.analyze.stats.numerise({data: [someValues]})
   */

  static numerise({ params, args, data } = {}) {
    var result = data.map((x) => parseFloat(x));
    return result;
  }

  /**
   * Filters out items in an array that are undefined, NaN, null, ", etc.
   * @method cleaner
   * @memberof stats
   * @param {Object} data - Contains: 1d-JS array with data to be cleaned as [dataValues]
   * @returns {Object[]} Cleaned array.
   * @example
   * hydro.analyze.stats.cleaner({data: [someValues]})
   */

  static cleaner({ params, args, data } = {}) {
    var x = data.filter((x) => x === undefined || !Number.isNaN(x));
    return x;
  }

  /**
   * Filters out items in an array based on another array.
   * @method itemfilter
   * @memberof stats
   * @param {Object} data - Contains: 2d-JS array with data to be kept and removed as [[dataKept],[dataRemoved]]
   * @returns {Object[]} Cleaned array.
   * @example
   * hydro.analyze.stats.itemfilter({data: [[dataKept], [dataRemoved]]})
   */

  static itemfilter({ params, args, data } = {}) {
    var x = data[0].filter((el) => !data[1].includes(el));
    return x;
  }

  /**
   * Changes a 1d-date array into local strings. Used mainly
   * for changing displaying into google charts.
   * @method dateparser
   * @memberof stats
   * @param {Object[]} data - Contains: 1-dJS array with date values as [dateValue].
   * @returns {Object[]} Array with date parsed.
   * @example
   * hydro.analyze.stats.dateparser({data: [someValues]})
   */

  static dateparser({ params, args, data } = {}) {
    var x = this.copydata({ data: data });
    var xo = [];
    for (var j = 0; j &lt; data.length; j++) {
      xo.push(new Date(data[j]).toLocaleString());
    }
    return xo;
  }

  /**
   * Changes a m x n matrix into a n x m matrix (transpose).
   * Mainly used for creating google charts. M != N.
   * @method arrchange
   * @memberof stats
   * @param {Object} data - Contains: nd-JS array representing [[m],[n]] matrix.
   * @returns {Object[]}  [[n],[m]] array.
   * @example
   * hydro.analyze.stats.arrchange({data: [[someSize1],[someSize2]]})
   */

  static arrchange({ params, args, data } = {}) {
    var x = this.copydata({ data: data });
    var transp = (matrix) => matrix[0].map((x, i) => matrix.map((x) => x[i]));
    return transp(x);
  }

  /**
   * Pushes at the end of an array the data of another array.
   * @method push
   * @memberof stats
   * @param {Object} data - Contains: 2d-JS array with data arranged as [[willPush],[pushed]]
   * @returns {Object[]} Last dataset with pushed data.
   * @example
   * hydro.analyze.stats.push({data: [[dataSet1], [dataSet2]]})
   */

  static push({ params, args, data } = {}) {
    for (var j = 0; j &lt; data[1].length; j++)
      for (var i = 0; i &lt; data[0].length; i++) {
        data[0][j].push(data[1][j][i]);
      }
    return arr1;
  }

  /**
   * Generates an array of random integers within a specified range.
   * @method generateRandomData
   * @memberof stats
   * @param {number} size - The number of
   * elements in the array to be generated.
   * @param {number} [range=100] - The upper
   * limit (exclusive) of the range from which
   * the random integers will be generated.
   * @returns {number[]} An array of random
   * integers between 0 and range-1, of length
   * size.
   * @example
   * hydro.analyze.stats.generateRandomDat
   * (10, 50) // returns [23, 48, 15, 9, 36,
   * 28, 39, 18, 20, 22]
   */
  static generateRandomData(size, range = 100) {
    let data = [];
    for (let i = 0; i &lt; size; i++) {
      data.push(Math.floor(Math.random() * range)); // generates a random integer between 0 and 99
    }
    return data;
  }


 /**
  * **Still needs some testing**
   * Compute the autocovariance matrix from the autocorrelation values
   * @method autocovarianceMatrix
   * @author riya-patil
   * @memberof stats
   * @param {Object} data - array with autocorrelation values
   * @param {number} params - number of lags
   * @returns {Object} Autocovariance matrix
   * @example 
   * const acTestData = [1, 0.7, 0.5, 0.3];
   * const lags = 2
   * hydro.analyze.stats.autocovarianceMatrix({params: lag, data : actestData});
   */
 static autocovarianceMatrix({ params, args, data } = {}) {
  const { lag, lags } = params || { lag: 2, lags: 2 };
  const length = data.length;
  const mean = this.mean({ data });
  const autocorrelation = [];
  const matrix = [];

  for (let l = 0; l &lt;= lag; l++) {
    let sum = 0;
    for (let t = l; t &lt; length; t++) {
      sum += (data[t] - mean) * (data[t - l] - mean);
    }
    autocorrelation.push(sum / ((length - l) * this.variance({ data })));
  }

  for (let i = 0; i &lt;= lags; i++) {
    const row = [];
    for (let j = 0; j &lt;= lags; j++) {
      const ac = autocorrelation[Math.abs(i - j)];
      row.push(i === j ? 1 : ac);
    }
    matrix.push(row);
  }

  return { autocorrelation, matrix };
}

/**
 * Calculates the binomial coefficient (n choose k format)
 * @method binomialCoefficient
 * @author riya-patil
 * @memberof stats
 * @param {Number} trials - The number of trials
 * @param {Number} s - The number of successes
 * @returns {Number} The binomial coefficient (trials choose s)
 */
static binomialCoefficient(trials, s) {
  if (s === 0 || s === trials) {
    return 1;
  }
  if (s > trials) {
    return 0;
  }
  let coefficient = 1;
  for (let i = 1; i &lt;= s; i++) {
    coefficient *= (trials - i + 1) / i;
  }

  return coefficient;
}

/**
 * Multiplies two matrices
 * @method multipleMatrix
 * @author riya-patil
 * @memberof stats
 * @param {Array} matrix1 - First matrix
 * @param {Array} matrix2 - Second matrix
 * @returns {Array} Result of matrix multiplication
 * @example
 * const matrix1 = [[1, 2], [3, 4]];
 * const matrix2 = [[5, 6], [7, 8]];
 * hydro.analyze.stats.multiplyMatrix(matrix1, matrix2)
 */
static multiplyMatrix(matrix1, matrix2) {
  const m1Rows = matrix1.length;
  const m1Cols = matrix1[0].length;
  const m2Cols = matrix2[0].length;
  const result = [];

  for (let i = 0; i &lt; m1Rows; i++) {
    result[i] = [];
    for (let j = 0; j &lt; m2Cols; j++) {
      let sum = 0;
      for (let k = 0; k &lt; m1Cols; k++) {
        sum += matrix1[i][k] * matrix2[k][j];
      }
      result[i][j] = sum;
    }
  }

  return result;
}

/**
 * Transposes a matrix
 * @method transposeMatrix
 * @author riya-patil
 * @memberof stats
 * @param {Array} matrix - Matrix to transpose
 * @returns {Array} Transposed matrix
 * @example
 * const matrix = [[1, 2, 3], [4, 5, 6]];
 * hydro.analyze.stats.transposeMatrix(matrix)
 */
static transposeMatrix(matrix) {
  const rows = matrix.length;
  const cols = matrix[0].length;
  const transposed = [];

  for (let j = 0; j &lt; cols; j++) {
    transposed[j] = [];
    for (let i = 0; i &lt; rows; i++) {
      transposed[j][i] = matrix[i][j];
    }
  }

  return transposed;
}

/**
 * Computes the inverse of a matrix
 * @method matrixInverse
 * @author riya-patil
 * @memberof stats
 * @param {Array} matrix - Matrix to compute inverse of
 * @returns {Array} Inverse of the matrix
 * @example
 * const matrix = [[1, 2, 3], [4, 5, 6]];
 * hydro.analyze.stats.matrixInverse(matrix)
 */

static matrixInverse(matrix) {
  const n = matrix.length;
  const inv = [];
  const inversed = [];

  for (let i = 0; i &lt; n; i++) {
    inversed[i] = [];
    inv[i] = [];
    for (let j = 0; j &lt; n; j++) {
      inversed[i][j] = i === j ? 1 : 0;
      inv[i][j] = matrix[i][j];
    }
  }

  for (let k = 0; k &lt; n; k++) {
    const pivot = inv[k][k]; //elimatination to obtain inversed matrix

    for (let j = 0; j &lt; n; j++) {
      inv[k][j] /= pivot;
      inversed[k][j] /= pivot;
    }
    //row operations to eliminate other elements
    for (let i = 0; i &lt; n; i++) {
      if (i !== k) {
        const factor = inv[i][k];

        for (let j = 0; j &lt; n; j++) {
          inv[i][j] -= factor * inv[k][j];
          inversed[i][j] -= factor * inversed[k][j];
        }
      }
    }
  }

  return inversed;
}

/**
 * Calculates the cumulative distribution function (CDF) of the chi-square distribution
 * NOTE: This will require revision in the future, readjusting considering lookups or fitting to a gamma distribution instead
 * @method chisqCDF
 * @author riya-patil
 * @memberof stats
 * @param {number} x The value at which to evaluate the CDF
 * @param {number} k The degrees of freedom
 * @returns {number} The cumulative probability
 * @example
 * const x = 10
 * const df = 20
 * hydro.analyze.stats.chisCDF(10, 20)
 */
static chisqCDF(x, k) {
  let term = Math.exp(-x / 2);
  let sum = term;
  for (let i = 1; i &lt; k; i++) {
    let prevTerm = term;
    term *= x / (2 * (i + 1));
    sum += term;
    if (term === prevTerm) break;
  }
  return 1 - sum;
}

/**
 * Calculates the dot product of two vectors. Both vectors should be represented as 1D JS arrays with the same length
 * @method dotProduct
 * @author riya-patil
 * @param {Array} a - The first vector
 * @param {Array} b - The second vector
 * @returns {number} The dot product
 * @throws {Error} If the input vectors have different lengths
 * @example
 * const a = [1, 2, 3, 4, 5]
 * const b = [10, 20, 30, 40, 50]
 * hydro.analyze.stats.dotProduct(a,b)
 */
static dotProduct(a, b) {
  if (a.length != b.length) {
    throw new Error("Input vectors must have the same length.");
  }

  let result = 0;
  for (let i = 0; i &lt; a.length; i++) {
    result += a[i] * b[i];
  }

  return result;
}

/**
 * Gets the next state based on the transition probabilities defined in the transition matrix.
 * @method getNextState
 * @author riya-patil
 * @memberof stats
 * @param {number[][]} transitionMatrix transition matrix representing the probabilities of transitioning between states.
 * @param {number} currentState current state of the function
 * @returns {number} Next state selected based on the transition probabilities.
 * @example
 * const transitionMatrix = [
  [0.2, 0.8], 
  [0.5, 0.5],
    ];
  const initialState = 0;
 */
static getNextState(transitionMatrix, currentState) {
  const randomValue = Math.random();
  let cumulativeProbability = 0;

  for (let i = 0; i &lt; transitionMatrix[currentState].length; i++) {
    cumulativeProbability += transitionMatrix[currentState][i];

    if (randomValue &lt;= cumulativeProbability) {
      return i;
    }
  }

  // If no state is selected, return the current state as a fallback
  return currentState;
}

  /**********************************/
  /*** End of Helper functions **/
  /**********************************/
}
</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.7</a> on Fri Sep 05 2025 21:26:06 GMT+0000 (Coordinated Universal Time) using the Toast theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
